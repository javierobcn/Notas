<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../img/favicon.ico">

	<title>Comandos básicos de red en Linux - Notas</title>

        <link href="../../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../../../css/highlight.css">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="../../..">Notas</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../../..">Home</a>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">LPIC3 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../">Home</a>
</li>

                        
                            
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">1 Previos</a>
    <ul class="dropdown-menu">
        
            
<li class="active">
    <a href="./">Comandos básicos de red en Linux</a>
</li>

        
            
<li >
    <a href="../Systemd/">Systemd</a>
</li>

        
    </ul>
  </li>

                        
                        </ul>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="../../">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../Systemd/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
                    <li>
                        <a href="https://github.com/javierobcn/Notas">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#comandos-basicos-de-red-en-linux">Comandos básicos de red en Linux</a></li>
        
            <li><a href="#nomenclatura-de-tarjetas-de-red">Nomenclatura de tarjetas de red</a></li>
        
            <li><a href="#ver-la-configuracion-actual">Ver la configuración actual</a></li>
        
            <li><a href="#establecer-una-configuracion-de-red-estatica-de-forma-temporal">Establecer una configuración de red estática de forma temporal</a></li>
        
            <li><a href="#establecer-una-configuracion-estatica-de-forma-permanente-en-sistemas-debian-clasicos">Establecer una configuración estática de forma permanente (en sistemas Debian clásicos)</a></li>
        
            <li><a href="#establecer-una-configuracion-estatica-de-forma-permanente-en-sistemas-systemd">Establecer una configuración estática de forma permanente (en sistemas systemd)</a></li>
        
            <li><a href="#establecer-una-configuracion-dinamica-de-forma-temporal">Establecer una configuración dinámica de forma temporal</a></li>
        
            <li><a href="#establecer-una-configuracion-dinamica-de-forma-permanente">Establecer una configuración dinámica de forma permanente</a></li>
        
            <li><a href="#ping">ping</a></li>
        
            <li><a href="#mtr">mtr</a></li>
        
            <li><a href="#ss">ss</a></li>
        
            <li><a href="#ncat">ncat</a></li>
        
            <li><a href="#nmap">nmap</a></li>
        
            <li><a href="#nslookup">nslookup</a></li>
        
            <li><a href="#whois">whois</a></li>
        
            <li><a href="#wget">wget</a></li>
        
            <li><a href="#curl">curl</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="comandos-basicos-de-red-en-linux">Comandos básicos de red en Linux<a class="headerlink" href="#comandos-basicos-de-red-en-linux" title="Permanent link"></a></h1>
<h2 id="nomenclatura-de-tarjetas-de-red">Nomenclatura de tarjetas de red<a class="headerlink" href="#nomenclatura-de-tarjetas-de-red" title="Permanent link"></a></h2>
<p>Las tarjetas de red en sistemas Linux se pueden llamar de las siguientes maneras:</p>
<ul>
<li><strong>lo</strong>: Corresponde a la tarjeta "loopback". Recordemos que hemos dicho que esta tarjeta físicamente no existe (es un "invento" del sistema operativo) y suele tener siempre tiene la IP 127.0.0.1/8. Sirve para establecer una conexión con sí misma, de tal forma que podemos tener en la misma máquina un programa cliente que conecte a un programa servidor sin salir "fuera".</li>
<li><strong>eno1, eno2</strong>: Tarjetas Ethernet integradas en la placa base ( "on-board")</li>
<li><strong>ens1, ens2</strong>: Tarjetas Ethernet PCI ( "slot")</li>
<li><strong>enp2s0, p3p1</strong>: Tarjetas Ethernet que no se pueden localizar de otra forma debido a limitaciones de la BIOS</li>
<li><strong>wlp2s0</strong>:tarjetas WiFi</li>
</ul>
<p>Dentro de las máquinas virtuales de VirtualBox las tarjetas de red cogen siempre un nombre concreto: la tarjeta correspondiente a la primera pestaña del cuadro de configuración de red se llamará "enp0s3" dentro del sistema virtualizado, la segunda "enp0s8", la tercera "enp0s9" y la cuarta "enp0s10".</p>
<h2 id="ver-la-configuracion-actual">Ver la configuración actual<a class="headerlink" href="#ver-la-configuracion-actual" title="Permanent link"></a></h2>
<h3 id="estado-y-configuracion-de-las-tarjetas-detectadas">Estado y configuración de las tarjetas detectadas<a class="headerlink" href="#estado-y-configuracion-de-las-tarjetas-detectadas" title="Permanent link"></a></h3>
<p>El comando <code>ip address show</code> (o bien <code>ip address show dev nomTarjeta</code> si sólo se quiere obtener la información de una tarjeta determinada) nos muestra:</p>
<ul>
<li>Las direcciones MAC de las tarjetas</li>
<li>Su estado respectivo (UP, DOWN)</li>
<li>Sus direcciones IP respectivas (y la máscara correspondiente)</li>
<li>Otros datos (como si permite el envío "broadcast", si está en modo "promiscuo", etc).</li>
</ul>
<div class="admonition note">
<p class="admonition-title">NOTA</p>
<p>El comando <code>ip address show</code> se puede escribir de forma más corta así: <code>ip a s</code>. Incluso, se puede dejar de escribir el verbo show (o s) porque es la acción por defecto (por lo tanto, se puede hacer <code>ip address</code> o <code>ip a</code> y sería lo mismo). También es útil el parámetro -c (así: <code>ip -c a s</code>) para ver los datos más relevantes en colores.</p>
</div>
<p>Para activar / desactivar una tarjeta: ip link set {up|down} dev nomTarjeta</p>
<h3 id="puerta-de-enlace">Puerta de enlace<a class="headerlink" href="#puerta-de-enlace" title="Permanent link"></a></h3>
<p>El comando <code>ip route show</code> (o bien <code>ip route show dev nomTarjeta</code> o sus variantes <code>ip route</code>, <code>ip r s</code> o <code>ip r</code>) debe mostrar una línea que comenzará con la expresión <strong>"default vía"</strong> seguida de la dirección IP de la puerta de enlace establecida. 
Este comando puede mostrar más líneas, pero no nos interesarán mucho ... (quizás la más curiosa es una que sirve para indicar que no hay ninguna puerta de enlace para comunicarse con las máquinas que pertenezcan a la misma red a la que pertenece nuestra máquina).</p>
<h3 id="dns">DNS<a class="headerlink" href="#dns" title="Permanent link"></a></h3>
<p>Para saber la dirección IP del servidor DNS configurado en nuestra máquina (o las IPs … si hay más de una se prueba conectar a la primera y si esta falla entonces se prueba la segunda, y así) se puede consultar el archivo <code>etc/resolv.conf</code> (concretamente, las líneas que comienzan por la palabra nameserver). Estos servidores serán los que todas las aplicaciones del sistema (desde el ping hasta el navegador) utilizarán para averiguar cuál es la IP del nombre que el usuario haya escrito.</p>
<p>El contenido de este archivo suele ser gestionado por diferentes programas (como puede ser el cliente <strong>dhclient</strong>, la aplicación <strong>NetworkManager</strong>, el servicio <strong>networking</strong>, el servicio <strong>systemd-networkd/resolved</strong>, etc) y es por ello que no se recomienda modificarlo manualmente ya que los cambios realizados a mano podrían «Machacar» sin avisar en cualquier momento por cualquiera de estos programas.</p>
<p>En este sentido, estos programas (<strong>dhclient, NetworkManager, «networking», «systemd-networkd / resolved, etc</strong>) guardan los servidores DNS que usan dentro de sus propios archivos de configuración y los manipulan allí de forma autónoma (por ejemplo NetworkManager usa /var/run/NetworkManager/resolv.conf, «systemd-resolved» usa /run/systemd/resolve/resolv.conf, «Networking» usa la línea dns-nameservers dentro de /etc/network/interfaces, etc) pero además siempre vinculan en forma de enlace simbólico su archivo propio respectivo al archivo común /etc/resolv.conf para que los programas que utilicen este archivo común no tengan problemas en encontrar los servidores DNS.</p>
<h2 id="establecer-una-configuracion-de-red-estatica-de-forma-temporal">Establecer una configuración de red estática de forma temporal<a class="headerlink" href="#establecer-una-configuracion-de-red-estatica-de-forma-temporal" title="Permanent link"></a></h2>
<ul>
<li>
<p>Para asignar una IP / máscara concreta a una tarjeta: 
<code>ip address add v.x.y.z/n dev nomTarjeta</code></p>
</li>
<li>
<p>Para borrar una IP / máscara concreta de una tarjeta: <code>ip address del v.x.y.z / n dev nomTarjeta</code></p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">NOTA</p>
<p>También se puede hacer <code>ip address flush dev nomTarjeta</code> si lo que se quiere es borrar de golpe cualesquiera de las eventuales diferentes direcciones IP que pueda tener la tarjeta indicada</p>
</div>
<p>Para asignar la puerta de enlace concreta a una tarjeta: <code>ip route add default vía v.x.y.z dev nomTarjeta</code>. Antes, sin embargo, debería borrar la que había asignada antes (si no se hace da error), así: <code>ip route del default dev nomTarjeta</code>.</p>
<div class="admonition note">
<p class="admonition-title">NOTA</p>
<p>También se puede escribir <code>ip route add 0.0.0.0/0 vía v.x.y.z dev nomTarjeta</code>. Es equivalente.</p>
</div>
<div class="admonition note">
<p class="admonition-title">NOTA</p>
<p>De forma alternativa, en vez de hacer <code>ip route del …</code> y después <code>ip route add …</code>, el cambio de puerta de enlace predeterminada se podría hacer directamente en un solo paso, así: <code>ip route change default vía v.x.y.z dev nomTarjeta</code></p>
</div>
<div class="admonition note">
<p class="admonition-title">NOTA</p>
<p>También se puede indicar que se quiere utilizar una determinada puerta de enlace sólo para llegar a una red-destino concreta. En este caso, entonces, no estaríamos hablando de puerta de enlace «por defecto» sino de una puerta de enlace «específica». La puerta de enlace «por defecto» sería usada una vez que el sistema hubiera comprobado que el destino deseado no forma parte del conjunto de destinos indicados en puertas de enlace específicas. Para crear una puerta de enlace específica hay que ejecutar el comando <code>ip route add ip.red.Destino/Mascara vía v.x.y.z dev nomTarjeta</code> Se puede añadir además un último parámetro metric n, que indica la preferencia de la ruta en el caso de que hubieran varias que llevaran al mismo destino (a modo de «backup»): un n menor indica una mayor preferencia.</p>
</div>
<div class="admonition note">
<p class="admonition-title">NOTA</p>
<p>Una vez asignada una dirección IP a una tarjeta, el sistema calcula automáticamente su dirección IP de red correspondiente y genera una ruta a ella (es por eso que es necesario indicar la máscara en ip address add …)
Por ejemplo, si se asigna la IP 203.0.113.25/24 a la tarjeta enp0s3, se creará automáticamente una ruta en la red 203.0.113.0/24 directa, por lo que el sistema sabrá que para comunicarse con hosts de esta red no necesitará ninguna puerta de enlace intermediaria sino que lo podrá hacer directamente.</p>
</div>
<h2 id="establecer-una-configuracion-estatica-de-forma-permanente-en-sistemas-debian-clasicos">Establecer una configuración estática de forma permanente (en sistemas Debian clásicos)<a class="headerlink" href="#establecer-una-configuracion-estatica-de-forma-permanente-en-sistemas-debian-clasicos" title="Permanent link"></a></h2>
<p>Todos los comandos anteriores, sin embargo, sólo «funcionan» mientras la máquina se mantiene encendida: si apaga entonces las direcciones IP / máscaras y puertas de enlace configuradas con las órdenes «ip» anteriores se pierden y hay, pues, que volver a ejecutarlas de nuevo en el siguiente inicio.</p>
<p>Para que la configuración deseada de IP / máscara y puerta de enlace (y servidor DNS también, gestionado con alguno de los programas comentados en párrafos anteriores) para una determinada tarjeta de red se mantenga de forma permanente en cada reinicio de la máquina, hay que escribir los valores adecuados en un determinado archivo. En sistemas Debian/Ubuntu, este archivo se denomina /etc/network/interfaces y debe tener un aspecto similar al siguiente (las líneas que comienzan por # son comentarios, las tabulaciones son opcionales):</p>
<pre><code class="text"># Las líneas &quot;auto&quot; sirven para activar la tarjeta en cuestión (en este #caso la tarjeta &quot;lo&quot;)
auto lo
# La línea siguiente indica que la tarjeta &quot;lo&quot; es de 
# tipo &quot;loopback&quot; (y que, por tanto, tendrá la IP 127.0.0.1)
iface lo inet loopback
# En el mismo archivo se pueden configurar todas las tarjetas que 
# se quieran: la siguiente se llama enp3s0
auto enp3s0
# La palabra &quot;static&quot; indica que los valores de IP, máscara, etc 
# son fijos en cada reinicio
iface enp3s0 inet static
# A continuación se indican los valores de IP, máscara, puerta de 
# enlace y servidores DNS que se quieren asignar
address v.x.y.z
netmask w.w.w.w
gateway v.x.y.z
dns-nameservers v.x.y.z v.x.y.z
</code></pre>

<div class="admonition warning">
<p class="admonition-title">Atención</p>
<p>Atención, la línea «<strong>dns-nameservers</strong>» del archivo anterior sólo funciona (es decir, se copian los servidores DNS indicados allí en el archivo central del sistema donde deben estar para ser utilizados: /etc/resolv.conf) si hay instalado un paquete llamado «<strong>resolvconf</strong>». Si no lo está, estas líneas no se  tendrán en cuenta.</p>
</div>
<p>Este archivo es leído por un servicio del sistema (un demonio) que se pone en marcha automáticamente al arrancar la máquina y que se denomina «networking». Esto quiere decir que en cualquier momento que hagamos un cambio dentro de este archivo, para que se tenga en cuenta o bien habrá que reiniciar la máquina o bien simplemente reiniciar el servicio, así: <code>sudo systemctl restart networking</code></p>
<h2 id="establecer-una-configuracion-estatica-de-forma-permanente-en-sistemas-systemd">Establecer una configuración estática de forma permanente (en sistemas systemd)<a class="headerlink" href="#establecer-una-configuracion-estatica-de-forma-permanente-en-sistemas-systemd" title="Permanent link"></a></h2>
<p><strong>«Systemd-networkd»</strong> es un demonio que gestiona las configuraciones de las diferentes interfaces de red (físicas y / o virtuales) de un sistema systemd, representando, pues, una alternativa al demonio «Networking» de sistemas Debian así como también al scripts ifcfg- * clásicos de Fedora / Suse o al Network Manager integrado en muchos escritorios.</p>
<p>Para empezar a utilizar este demonio es recomendable detener primero la «competencia», por ejemplo, en el caso de Ubuntu ejecutando</p>
<p><code>sudo sytemctl disable networking &amp;&amp; sudo systemctl stop networking)</code></p>
<p>Y entonces encenderlo junto con el servicio «systemd-resolved», así, por ejemplo:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Al igual que ocurría con el paquete «resolvconf» en los sistemas Debian, se necesita tener un servicio adicional instalado (y funcionando) en el sistema llamado «systemd-resolved» si se quieren especificar entradas DNS explícitas en los archivos .network (o bien si se obtienen vía DHCP). Este servicio lo que hace es, a partir de estas entradas, modificar el archivo /run/systemd/resolve/resolv.conf, el cual, por compatibilidad con muchos programas tradicionales, debería apuntar en forma de enlace suave en /etc/resolv.conf (ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf). Alternativamente, se puede no utilizar systemd-resolved y modificar entonces el archivo /etc/resolv.conf a mano.</p>
</div>
<p>Se pueden ver el nombre (y tipo y estado) de las interfaces de red actualmente reconocidas en el sistema (y su tipo y estado) mediante el comando <code>networkctl list</code>. Si en la columna SETUP aparece «unmanaged» significa que esta interfaz concreta no es gestionada por systemd-networkd sino por algún otro servicio alternativo. Otra orden que da más información es <code>networkctl status</code>. En cualquier caso, para hacer que se gestione por systemd-networkd, por cada interfaz hay que crear un archivo * .network dentro de la carpeta /etc/systemd/network (y reiniciar el servicio). En el caso concreto de querer asignar una IP estática, sería necesario, pues, tener un archivo como este (llamado por ejemplo «/etc/systemd/network/lalala.network «):</p>
<pre><code class="text">[Match]
Name=enp1s0
#Identifica la tarjeta a la cual se le aplicará la configuración
[Network]
DHCP=no
Address=10.1.10.9/24
Gateway=10.1.10.1
DNS=10.1.10.2 #Opcional (Es necesario tener el servicio systemd-resolved funcionando)
DNS=10.1.10.3 #Cada servidor DNS ha d'indicar-se en una línia separada
</code></pre>

<p>Los archivos de configuración de systemd-networkd proporcionados por la distribución se encuentran en <code>/usr/lib/systemd/network</code> y los administrados por nosotros se tienen que ubicar en <code>/etc/systemd/network</code>. Todos estos archivos se leen -sin distinción de donde estén ubicados – en orden alfanumérico según el nombre que tienen, ganando siempre la primera configuración encontrada en caso de que afectara a la misma tarjeta. Eso sí, si en las dos carpetas se encuentra un fichero con el mismo nombre, lo que hay bajo <code>/etc/systemd/network</code> anula siempre a lo que hay en <code>/usr/lib/systemd/network</code> (una consecuencia de esto es que si el archivo en /etc/… apunta a /dev/null, lo que se estará haciendo es deshabilitar.</p>
<p>Existen tres tipos diferentes de archivos de configuración:</p>
<ul>
<li>los <strong>«.network»</strong> aplican la configuración descrita bajo su sección [Network] a aquellas tarjetas de red que tengan una característica que concuerde con todos los valores indicados en las diferentes líneas bajo la sección [Match] (normalmente aquí sólo indica su nombre mediante una única línea «Name =»)</li>
<li>los <strong>«.netdev»</strong> sirven para crear nuevas interfaces de red de tipo virtual ( «bridges», «bonds», etc) -la configuración de red se seguirá indicando en su correspondiente archivo .network)</li>
<li>los <strong>«.link»</strong> sirven para definir nombres alternativos a las tarjetas de red en el momento de ser reconocidas por el sistema (vía systemd-udev).</li>
</ul>
<p>En las líneas bajo la sección [Match] -por ejemplo, en «Name =», se puede utilizar el comodín *. En esta línea en concreto también se puede escribir un conjunto de nombres separados por un espacio en blanco a modo de diferentes alternativas.</p>
<p>En los archivos .network puede haber una sección (no vista en los ejemplos anteriores) titulada [Link] bajo la que pueden haber varias líneas más relacionadas con el comportamiento «hardware» de la tarjeta, como la línea «MACAddress = xx: xx: xx: xx: xx: xx», la cual sirve para asignar a la tarjeta en cuestión una dirección MAC ficticia, la línea «MTUBytes = no», la cual sirve para indicar el tamaño de la MTU admitida (útil por ejemplo para activar los «jumbo frames» si se pone 9000 como valor), o la línea «ARP = no» para desactivar el protocolo ARP en la tarjeta en cuestión (activado por defecto).</p>
<p>Los archivos .netdev suelen tener sólo una sección titulada [netdev], la cual debe incluir dos líneas obligatoriamente: «Name =» (por asignar un nombre a la interfaz virtual que se creará) y «Kind =» (para especificar el tipo de interfaz que será: «bridge», «bond», «Vlan», «veth», etc). En el caso de que sea de tipo «vlan», aparecerá entonces una sección titulada [VLAN] incluyendo como mínimo la línea «Id =» para indicar el número de VLAN que se está creando.</p>
<p>Los archivos .link suelen tener una sección [Match] con la línea «MACAddress =» para identificar la tarjeta de red en cuestión y una sección
[Link] que sirve para manipular las características de esta tarjeta, como por ejemplo su nombre (con la línea «Name =» y, opcionalmente, la línea «Description =»). Si no se crea manualmente ningún archivo .link, la mayoría de distribuciones ofrecen un archivo .link predeterminado, generalmente llamado 99-default.link (y ubicado en / usr / lib / systemd / network); es por ello que hay que asegurarse que los ficheros .link «manuales» tengan un nombre que asegure su lectura antes de la del archivo 99-default.link.</p>
<p>Para más información sobre las posibilidades que ofrecen todos estos archivos, consultar las páginas del manual «systemd.network», «Systemd.netdev» y «systemd.link».</p>
<div class="admonition warning">
<p class="admonition-title">Atención</p>
<p>No sólo existen el servicio «networking» y «systemd-networkd» para gestionar las tarjetas de red de nuestro sistema. También podemos encontrar el servicio «NetworkManager» (sobre todo en sistemas con escritorio) y en las últimas versiones de Ubuntu el servicio «Netplan», entre otros. !!!</p>
</div>
<h2 id="establecer-una-configuracion-dinamica-de-forma-temporal">Establecer una configuración dinámica de forma temporal<a class="headerlink" href="#establecer-una-configuracion-dinamica-de-forma-temporal" title="Permanent link"></a></h2>
<p>En las configuraciones anteriores, tanto la temporal como la permanente, se establece una dirección IP / máscara + puerta de enlace concreta, decidida por nosotros. Este método puede ser útil para pocas máquinas, pero en una red con muchos equipos, puede llegar a ser bastante farragoso, además de que fácilmente se pueden cometer errores (IPs duplicadas, IP no asignadas).</p>
<p>Otro método para establecer estos datos es el método «dinámico», en el que la máquina en cuestión no tiene asignada de forma fija IP / máscara + puerta de enlace + servidor DNS sino que estos datos los obtiene de la red: allí deberá haber escuchando un ordenador ejecutando un software especial llamado «Servidor DHCP», el cual sirve precisamente para atender estas peticiones de «datos de red» y asignarlas a quien las pida. De este modo, se tiene una gestión centralizada del reparto de direcciones IP / máscara + puerta de enlace + servidores DNS sin necesidad de realizar ninguna configuración específica en las máquinas clientes. Eso sí, claro: primero se deberá haber instalado y configurado convenientemente en nuestra red este software «servidor DHCP» (un ejemplo es el paquete «isc-dhcp-server «), tarea que no veremos (se presupone que esto ya está hecho).</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Otro cliente similar es el comando host nomDNS [ip.serv.DNS]</p>
</div>
<p>Para pedir en un momento determinado una configuración completa de red (IP, máscara, puerta de enlace, servidores DNS, etc) a un servidor DHCP ya funcionando en nuestra LAN hemos de ejecutar un cliente DHCP, como el comando <code>dhclient</code>
<code>Dhclient nomTarjeta</code> Pide -para la tarjeta indicada- los datos de red (IP, máscara, puerta de enlace, servidor DNS, etc) a algún servidor DHCP que esté escuchando a la LAN de nuestra máquina.</p>
<p>-v Muestra por pantalla todo el proceso de petición y respuesta (útil para ver si va)</p>
<p>-r Borra todos los datos de red que pueda tener actualmente la tarjeta indicada</p>
<h2 id="establecer-una-configuracion-dinamica-de-forma-permanente">Establecer una configuración dinámica de forma permanente<a class="headerlink" href="#establecer-una-configuracion-dinamica-de-forma-permanente" title="Permanent link"></a></h2>
<h3 id="en-sistemas-debian-clasicos">En sistemas Debian clásicos<a class="headerlink" href="#en-sistemas-debian-clasicos" title="Permanent link"></a></h3>
<p>Para pedir los datos de red a algún servidor DHCP de nuestra red, en vez
de tener que hacerlo manualmente con el comando <code>dhclient</code>, se puede hacer de forma automática cada vez que nuestra máquina arranque (de modo que nosotros no tengamos que hacer nada y ya tengamos, si todo va bien, estos datos ya asignadas una vez iniciamos sesión). Esto se logra simplemente escribiendo las siguientes líneas en el archivo /etc/network/interfaces:</p>
<pre><code class="TEXT">auto enp3s0
iface enp3s0 inet dhcp
</code></pre>

<h3 id="en-sistemas-systemd">En sistemas systemd<a class="headerlink" href="#en-sistemas-systemd" title="Permanent link"></a></h3>
<p>En el caso concreto de querer asignar una IP dinámica en un sistema con el demonio systemd-netword funcionando, habrá que tener un archivo como este (llamado por ejemplo «/Etc/systemd/network/lalala.network»):</p>
<pre><code class="TEXT">[Match]
Name = enp1s0
[Network]
DHCP = yes # También podría valer ipv4 o ipv6 según el tipo de direcciones IP que queremos recibir
</code></pre>

<h2 id="ping">ping<a class="headerlink" href="#ping" title="Permanent link"></a></h2>
<p><code>ping ip o Nombre Maq. Remota</code> </p>
<p>Comprueba si la máquina remota indicada responde. Sirve, por tanto, para saber si hay conexión de red con aquella máquina (si no, podría ser debido a cualquier causa: cable mal enchufado o roto, máquina remota apagada, etc). En este sentido, son interesantes los datos estadísticos que aparecen al final (paquetes enviados, recibidos, perdidos, etc) y el tiempo que han tardado en enviarse estos paquetes de prueba (y recibirse la respuesta) -y así comprobar la saturación del medio.</p>
<p>-n No resuelve nombres (es decir, no hace la consulta previa en el servidor DNS del sistema). Por lo tanto, sólo hace que funcione indicando direcciones IP</p>
<p>-c nº Número de paquetes de prueba que se enviarán (si no se indica, son infinitos y hay que detener el envío pulsando CTRL + C)</p>
<p>-i nºNúmero de segundos que se espera para enviar el siguiente paquete</p>
<p>-f Mode «flood». Envía paquetes a la máxima velocidad posible, mostrando un punto por cada paquete enviado y borrándose el por cada respuesta recibida: por lo tanto, para ir bien habría que sólo se viera un punto y fuera desapareciendo: si se ven muchos puntos es que hay pérdida de paquetes. Hay que ser root para que funcione</p>
<p>-I eno1 Indica la tarjeta de red para la que se enviarán los paquetes (por si la máquina tuviera más de una)</p>
<h2 id="mtr">mtr<a class="headerlink" href="#mtr" title="Permanent link"></a></h2>
<p><code>mtr ip.o Nom.Maq.Remota</code></p>
<p>Sirve para conocer el camino seguido por un paquete desde la máquina origen hasta la indicada, mostrando la IP (o nombre) de todos los routers
intermedios a través de los que va pasando. también muestra estadísticas de tiempo empleado en cada paquete, el mejor tiempo, el peor, los paquetes perdidos, etc</p>
<p>-n No resuelve nombres (es decir, no hace la consulta previa en el servidor DNS del sistema).</p>
<p>-c nº Número de paquetes de prueba que se enviarán (si no se indica, son infinitos y hay que parar el envío pulsando CTRL + C)</p>
<p>-i nº Número de segundos que se espera para enviar el siguiente paquete</p>
<h2 id="ss">ss<a class="headerlink" href="#ss" title="Permanent link"></a></h2>
<p>Muestra datos sobre las conexiones existentes (o que pueden existir) en
nuestra máquina. Concretamente, muestra el estado de la conexión (los más habituales son ESTABLISHED y LISTEN -este último indica que el
puerto está abierto pero sin conexión -… otros estados a menudo son
temporales y terminan derivando en una conexión establecida o bien
desapareciendo), muestra la IP y el puerto local utilizados para establecer la conexión (o para escuchar, segundos) y la IP y puerto remoto donde la
correspondiente IP + puerto local están conectados.</p>
<p>NOTA: Otro cliente similar es el comando <code>host nomDNS [ip.serv.DNS]</code></p>
<p>-t Mostrar sólo las conexiones TCP actuales</p>
<p>-u Mostrar sólo las conexiones UDP actuales</p>
<p>-n No resuelve nombres (es decir: muestra IPs y puertos en formato numérico en lugar de con nombres)</p>
<p>-a (Combinado con -t y/o -u): Muestra, además de las conexiones actuales, los puertos a la escucha</p>
<p>-l (Combinado con -t y / o -u): Muestra sólo los puertos a la escucha (las conexiones actuales no)</p>
<p>-p (Combinado con -t y / o -u): Muestra 1 columna más: el ejecutable «detrás» de cada puerto local</p>
<p>–s Muestra un resumen con estadísticas</p>
<h2 id="ncat">ncat<a class="headerlink" href="#ncat" title="Permanent link"></a></h2>
<p><code>ncat ip.oNom.Maq.Remota noport</code></p>
<p>Cliente Netcat que viene dentro del paquete «nmap»: realiza una
conexión (TCP) en la máquina y puerto indicado. Se puede añadir el
parámetro -v (modo verboso) y -n (no resuelve nombres), entre otros.</p>
<p>-v Modo verboso (-vv es más verboso y -vvv más aún)</p>
<p><code>ncat -l -k -p nº</code> Servidor Netcat: pone a la escucha el nº de puerto (TCP) indicado. el argumento -l sirve para «abrir» el puerto, el parámetro -p sirve para indicar el número de puerto a abrir y el parámetro -k permite que se puedan conectar más de un cliente a la vez.</p>
<p>-e /ruta/comando Todo lo que se reciba de la red será pasado al comando indicado, la salida será devuelta al cliente. Si el comando indicado fuera
/Bin/bash, la entrada se entenderá como un comando a ejecutar (y la
salida será la salida del comando ejecutado).
Exemples Ncat</p>
<p><strong>Chat</strong> </p>
<p>Servidor: <code>ncat -l -p 5588</code> &lt;—&gt; Cliente: <code>ncat ipServidor 5588</code></p>
<p>El servidor se pone a escuchar en el puerto 5588 (por defecto siempre es TCP), con lo que todo lo que le llegue de la red -es decir, del cliente-lo pasará a la stdout (pantalla), y todo lo que escriba por stdin (teclado) pasará a la red -es decir, hacia el cliente-. Lo mismo ocurre en el otro lado de la comunicación. Si se añade el parámetro -k al servidor, múltiples clientes podrán enviar mensajes al servidor y este, lo que envíe, lo enviará a todos sin discriminación</p>
<p><strong>Envío de un archivo</strong></p>
<p>Servidor: <code>ncat -l -p 5555 &lt; archivo</code> &lt;-&gt; Cliente: <code>ncat ipServidor 5555 &gt; archivo</code></p>
<p>Muy similar a lo anterior: el servidor se pone a escuchar en el puerto 5555, pero en vez de responder por teclado a la stdin, la entrada proviene de un archivo, el cual esperará latente a que cuando se establezca una comunicación por ese puerto, su contenido viaje bit a bit por la red hacia el cliente, el cual lo recibirá y lo guardará en forma de archivo otra vez. Lo malo es que tal como se ha hecho, no se sabe cuándo se ha acabado la transferencia: hay que esperar un tiempo prudencial y entonces hacer Ctrl+C.</p>
<p><strong>Reproducción de audio en streaming</strong></p>
<p>Servidor: <code>ncat -l -p 5858</code> Cliente: <code>ncat ipServidor 5858 | mpg123 –</code></p>
<p>El ejemplo es idéntico al anterior, teniendo un archivo en este caso de audio. La única diferencia es que en el cliente, el archivo no se redirecciona para grabarlo en disco sino que se entuba a un reproductor de audio por consola, como mpg123 (el guión del final es para indicarle que el fichero o lista de reproducción le proviene de la tubería).</p>
<p><strong>Clonación de discos por red</strong></p>
<p>Servidor: <code>ncat -l -p 5678 | dd of=a.iso.gz</code> &lt;—-&gt;Cliente: <code>dd if=/dev/sda | gzip -c | ncat ipServidor 5678</code></p>
<p>El ejemplo es parecido al anterior: primero en el cliente se comprime bit a bit el contenido del disco «sda» y se le envía ya comprimido al servidor, el cual recibe este contenido binario y lo almacena en un archivo, bit a bit too.</p>
<h2 id="nmap">nmap<a class="headerlink" href="#nmap" title="Permanent link"></a></h2>
<p><code>nmap -sn { ipInici-ipFinal [altraIP …] | ipConAsteriscos }</code></p>
<p>Muestra qué ordenadores están presentes en la red. existen muchos otros parámetros de escaneo (-sU, -sX, -sF, etc) que utilizan diferentes técnicas más
o – rápidas / sigilosas / precisas, pero no las veremos.</p>
<p>-v Modo verboso (-vv es más verboso y -vvv más aún)</p>
<p>-n No resuelve nombres</p>
<p><code>nmap -p nº, nº-nº ipOrdenador</code> Muestra qué puertos (del rango indicado) tiene abiertos un ordenador concreto. Aquí también se pueden utilizar diferentes técnicas pero tampoco profundizaremos</p>
<p>-O Muestra el sistema operativo del ordenador y los programas «detrás» de los
puertos abiertos. Se puede combinar con el parámetro -sV, el cual muestra también las versiones. El parámetro -A es la combinación de los dos.</p>
<h2 id="nslookup">nslookup<a class="headerlink" href="#nslookup" title="Permanent link"></a></h2>
<p><code>nslookup nombreDNS [ip.serv.DNS]</code></p>
<p>Cliente DNS que pregunta al servidor indicado o, si no se indica ninguno, al que esté configurado en <code>/etc/resolv.conf</code>. Normalmente, además de devolver la IP (o IPs equivalentes) asociadas al nombre indicado, también muestra los «alias» que tiene este nombre</p>
<div class="admonition note">
<p class="admonition-title">NOTA</p>
<p>Otro cliente similar es el comando <code>host nomDNS [ip.serv.DNS]</code></p>
</div>
<div class="admonition note">
<p class="admonition-title">NOTA</p>
<p>Otro cliente similar es el comando <code>dig [@ip.serv.DNS] nomDNS.</code> O <code>drill</code></p>
</div>
<div class="admonition note">
<p class="admonition-title">NOTA</p>
<p>Otro cliente pero sólo compatible con systemd-resolved es <code>systemd-resolve</code></p>
</div>
<h2 id="whois">whois<a class="headerlink" href="#whois" title="Permanent link"></a></h2>
<p><code>whois dominioDNS</code></p>
<p>Consulta en los servidores whois publicos (administrados por la IANA) para averiguar el propietario o registrador del dominio</p>
<h2 id="wget">wget<a class="headerlink" href="#wget" title="Permanent link"></a></h2>
<p><code>wget https://url/un/archivo</code></p>
<p>Descarga al disco duro el archivo indicado</p>
<p>-c Continúa la descarga (si anteriormente falló) desde donde se interrumpió</p>
<p>-O nombre Indica el nombre que tendrá el archivo una vez descargado</p>
<p>-r Realiza una descarga recursiva si la URL indicada es la de una carpeta en vez de la de un archivo. Combinado con el parámetro -l nº sirve para indicar hasta qué nivel (1 = una subcarpeta, 2 =dos subcarpetas) se quiere descargar … si no se indica se entiende «infinito»</p>
<p>-N Descarga sólo los archivos más nuevos que los locales</p>
<p>-A «ext1», «ext2», … Descarga sólo los archivos que encuentre con la extensión indicada El parámetro contrario (descarga todo excepto los archivos indicados) es -R</p>
<p>–no-parent No descarga contenido anterior a la URL indicada</p>
<p>-nd Todo lo descarga en la misma carpeta local (sin respetar, pues, la jerarquía de carpetas del sitio remoto)</p>
<p>-k Una vez hecha la descarga, transforma los enlaces para que todo el contenido se pueda visitar offline (cambia las rutas absolutas para relativas y los recursos no descargados los referencia con la URL completa</p>
<h2 id="curl">curl<a class="headerlink" href="#curl" title="Permanent link"></a></h2>
<p><code>curl https://url/un/archivo</code></p>
<p>Descargar el fichero indicado y muestra en pantalla su contenido</p>
<p>-o nombre Descargar archivo indicado y lo guarda en el disco duro con el nombre que se especifique</p>
<p>-O Descargar el fichero indicado y lo guarda en el disco duro con el nombre que tenga el original</p>
<p>-C – Continúa la descarga desde el no de byte indicado (si es un guión, será a partir de donde se paró la descarga -fallida- anterior del mismo archivo</p>
<p>-s Modo «silencioso» (no muestra ni las estadísticas de descarga ni los errores, nada)</p>
<p>-SS Modo «silencioso» pero mostrando los mensajes de error</p>
<p>-v Modo «verboso». Sirve para mostrar las cabeceras de cliente enviadas a la petición</p>
<p>-Y No descarga el archivo: sólo muestra la cabecera de respuesta HTTP del servidor</p>
<p>-y Mostrar en pantalla tanto las cabeceras de respuesta como el contenido del archivo pedido</p>
<p>-D nombre Guarda en el disco duro, en forma de archivo con el nombre indica, las cabeceras de respuesta</p>
<p>-L Si el servidor web devuelve un código de redirección (3xx), lo sigue automáticamente</p>
<p>-H «cabecera: valor» Realiza una petición indicando un valor concreto para la cabecera HTTP de cliente indicada. Se pueden poner múltiples parámetros -H.</p>
<p>–X tipo Realiza una petición del tipo indicado (POST, PUT, etc). Por defecto son GET</p></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        <script src="../../../js/jquery-1.10.2.min.js"></script>
        <script src="../../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../../js/highlight.pack.js"></script>
        <script>var base_url = '../../..';</script>
        <script data-main="../../../mkdocs/js/search.js" src="../../../mkdocs/js/require.js"></script>
        <script src="../../../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
