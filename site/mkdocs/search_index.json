{
    "docs": [
        {
            "location": "/",
            "text": "Notas y Apuntes\n\uf0c1\n\n\n\n\n\n\nLPIC 1\n\uf0c1\n\n\n\n\n\n\nLPIC 2\n\uf0c1\n\n\n\n\n\n\nLPIC 3\n\uf0c1\n\n\n\n\n\n\nMarkdown\n\uf0c1",
            "title": "Home"
        },
        {
            "location": "/#notas-y-apuntes",
            "text": "",
            "title": "Notas y Apuntes"
        },
        {
            "location": "/#lpic-1",
            "text": "",
            "title": "LPIC 1"
        },
        {
            "location": "/#lpic-2",
            "text": "",
            "title": "LPIC 2"
        },
        {
            "location": "/#lpic-3",
            "text": "",
            "title": "LPIC 3"
        },
        {
            "location": "/#markdown",
            "text": "",
            "title": "Markdown"
        },
        {
            "location": "/LPIC3/",
            "text": "Material curs LPIC 3-303\n\uf0c1\n\n\nEnlaces sobre los ex\u00e1menes:\n\uf0c1\n\n\n\n\nResumen de las certificaciones\n\n\nResumen de la certificaci\u00f3n LPIC-3 (303)\n\n\nLo que hace falta saber para superar el examen 303\n\n\n\n\nRecursos para descargar:\n\uf0c1\n\n\n\n\nM\u00e0quina servidora LDAP+Kerberos+NFS4 ja funcional\n\n\nM\u00e0quina client SSSD ja funcional\n\n\nArxiu ldif amb usuaris de mostra\n\n\n\n\nDocumentos del curso\n\uf0c1\n\n\n1.Previos\n\uf0c1\n\n\n\n\nComandos b\u00e1sicos de red en Linux\n\n\nTeoria b\u00e1sica sobre LDAP (i NSS)\n\n\nTeoria b\u00e1sica sobre NFS\n\n\nGesti\u00f3 b\u00e1sica de m\u00f2duls del kernel\n\n\nJournald i journalctl\n\n\nSystemd\n\n\nBreu descripci\u00f3 de /proc i de /sys\n\n\nComanda Jq (per l'eve.json de Suricata, Beats de l'ELK, etc)\n\n\nD-Bus (IPC per Firewalld, Systemd,...)\n\n\nServidor Apache (HTTP)\n\n\n\n\nAutenticaci\u00f3-Autoritzaci\u00f3:\n\uf0c1\n\n\n\n\nIntroducci\u00f3n\n\n\nAutenticaci\u00f3n vs Autorizaci\u00f3n\n\n\nHashes i endevinaci\u00f3 de contrasenyes. Keyloggers\n\n\n\n\nM\u00f3dulos PAM\n\uf0c1\n\n\n\n\nPAM i m\u00f2duls interessants (pam_limit, pam_pwquality, etc) (Pes 3)\n\n\nClient Kerberos+LDAP i FreeIPA (NSS+PAM+SSSD)\n\n\nInstal.laci\u00f3 servidor 389DS\n\n\nAdministraci\u00f3 b\u00e1sica d'un directori 389DS\n\n\nAutenticaci\u00f3 i identificaci\u00f3 contra servidor 389DS fent servir SSSD(Pes 5)\n\n\nInstal.laci\u00f3 i configuraci\u00f3 d'un servidor MIT Kerberos i cooperaci\u00f3 amb servidors LDAP i NFS(Pes 5)PENDENT NFS\n\n\nFreeIPA (client, servidor i r\u00e8plica)(Pes 4)PENDENT\n\n\n\n\nFrameworks d'autoritzaci\u00f3\n\uf0c1\n\n\n\n\nSu i sudo\n\n\nPolkit\n\n\n\n\nACLs, Capabilities y atributos extendidos\n\uf0c1\n\n\n\n\nBits suid,sgid,sticky\n\n\nCapabilities i atributs extesos(Pes 3)\n\n\nACLs(Pes 3)\n\n\n\n\nSELinux\n\uf0c1\n\n\n\n\nSELinux(Pes 4)\n\n\n\n\nRADIUS\nRADIUS(Pes 4)\n\n\nChroot i altres \"bitxos\": namespaces, cgroups, OS/App containers\nIntro contenidors(Pes 3)PENDENT\nExemple pr\u00e0ctic: contenidors mkosi/machinectl(Pes 3)\n\n\nMonitoritzaci\u00f3 local:\nCaptura de crides al sistema (i altres events)\nStrace, Ltrace i llibreries\nSysdig i Falco\nAudit(Pes 4)\nAltres FIMs\nELK (amb Falco i Audit)\n\n\nDetectors de rootkits i malware\nLynis, OpenSCAP, Rkhunter, Maldet, Aide (Pes 4)\nAnsible (com a m\u00e8tode per aplicar de forma autom\u00e0tica els canvis de configuraci\u00f3 suggerits pels programes anteriors)\nHoneypots (com a m\u00e8tode de captura i estudi de malware)\nMetasploit (eina per crear \"malware\" ad-hoc i introduir-lo a v\u00edctimes fent servir algun exploit)\nYara (eina per crear definicions pr\u00f2pies de detecci\u00f3 de malware) PENDENT\n\n\nHardering local:\nEncriptaci\u00f3 de disc amb LUKS i de sistemes de fitxers amb Ecryptfs (Pes 3)\nEncriptaci\u00f3 de fitxers amb GPG\nContrasenyes arranc al gestor Grub (Pes 3)\nSysctl (Pes 3)\nUdev \"i bad usbs\"\n\n\nMonitoritzaci\u00f3 de xarxa:\nInspecci\u00f3 en brut del tr\u00e0fic de xarxa i generaci\u00f3 d'alertes\nBreu descripci\u00f3 del protocol TCP\nWireshark(Pes 4)\nNIDS Snort/Suricata (Pes 4)\nConstructor de paquets Scapy\n\n\nRecol.lectors d'informaci\u00f3 estad\u00edstica sobre el tr\u00e0fic de xarxa\nEines TSBD\nNetflow i IPFIX\nMonitoritzaci\u00f3 d'ample de banda amb Cacti (Pes 4) PENDENT\n\n\nHardering de xarxa i servidors:\nTallafocs\nTallafocs Netfilter (NFTables) (Pes 5)\nTallafocs Firewalld\n\n\nVulnerabilitats\nIntroducci\u00f3 a les vulnerabilitats (web)\nDetector de vulnerabilitats OpenVAS (Pes 4)PENDENT\nDetector de vulnerabilitat Nmap (Pes 4)\nDetector de vulnerabilitats ZAP\n\n\nCriptografia pr\u00e0ctica amb OpenSSL\nConceptes de criptografia (Pes 5)\nXuleta comandes OpenSSL(Pes 5)PENDENT\n\n\nSecuritzaci\u00f3 d'un servidor Apache\nImplementaci\u00f3 servidor Apache segur (HTTPS)(Pes 4)\nDNSSEC\nNFS i CIFS segurs\nVPNs amb OpenVPN i IPSec\n\n\nLlibres:\nLlibre PacktPub",
            "title": "Home"
        },
        {
            "location": "/LPIC3/#material-curs-lpic-3-303",
            "text": "",
            "title": "Material curs LPIC 3-303"
        },
        {
            "location": "/LPIC3/#enlaces-sobre-los-examenes",
            "text": "Resumen de las certificaciones  Resumen de la certificaci\u00f3n LPIC-3 (303)  Lo que hace falta saber para superar el examen 303",
            "title": "Enlaces sobre los ex\u00e1menes:"
        },
        {
            "location": "/LPIC3/#recursos-para-descargar",
            "text": "M\u00e0quina servidora LDAP+Kerberos+NFS4 ja funcional  M\u00e0quina client SSSD ja funcional  Arxiu ldif amb usuaris de mostra",
            "title": "Recursos para descargar:"
        },
        {
            "location": "/LPIC3/#documentos-del-curso",
            "text": "1.Previos \uf0c1   Comandos b\u00e1sicos de red en Linux  Teoria b\u00e1sica sobre LDAP (i NSS)  Teoria b\u00e1sica sobre NFS  Gesti\u00f3 b\u00e1sica de m\u00f2duls del kernel  Journald i journalctl  Systemd  Breu descripci\u00f3 de /proc i de /sys  Comanda Jq (per l'eve.json de Suricata, Beats de l'ELK, etc)  D-Bus (IPC per Firewalld, Systemd,...)  Servidor Apache (HTTP)   Autenticaci\u00f3-Autoritzaci\u00f3: \uf0c1   Introducci\u00f3n  Autenticaci\u00f3n vs Autorizaci\u00f3n  Hashes i endevinaci\u00f3 de contrasenyes. Keyloggers   M\u00f3dulos PAM \uf0c1   PAM i m\u00f2duls interessants (pam_limit, pam_pwquality, etc) (Pes 3)  Client Kerberos+LDAP i FreeIPA (NSS+PAM+SSSD)  Instal.laci\u00f3 servidor 389DS  Administraci\u00f3 b\u00e1sica d'un directori 389DS  Autenticaci\u00f3 i identificaci\u00f3 contra servidor 389DS fent servir SSSD(Pes 5)  Instal.laci\u00f3 i configuraci\u00f3 d'un servidor MIT Kerberos i cooperaci\u00f3 amb servidors LDAP i NFS(Pes 5)PENDENT NFS  FreeIPA (client, servidor i r\u00e8plica)(Pes 4)PENDENT   Frameworks d'autoritzaci\u00f3 \uf0c1   Su i sudo  Polkit   ACLs, Capabilities y atributos extendidos \uf0c1   Bits suid,sgid,sticky  Capabilities i atributs extesos(Pes 3)  ACLs(Pes 3)   SELinux \uf0c1   SELinux(Pes 4)   RADIUS\nRADIUS(Pes 4)  Chroot i altres \"bitxos\": namespaces, cgroups, OS/App containers\nIntro contenidors(Pes 3)PENDENT\nExemple pr\u00e0ctic: contenidors mkosi/machinectl(Pes 3)  Monitoritzaci\u00f3 local:\nCaptura de crides al sistema (i altres events)\nStrace, Ltrace i llibreries\nSysdig i Falco\nAudit(Pes 4)\nAltres FIMs\nELK (amb Falco i Audit)  Detectors de rootkits i malware\nLynis, OpenSCAP, Rkhunter, Maldet, Aide (Pes 4)\nAnsible (com a m\u00e8tode per aplicar de forma autom\u00e0tica els canvis de configuraci\u00f3 suggerits pels programes anteriors)\nHoneypots (com a m\u00e8tode de captura i estudi de malware)\nMetasploit (eina per crear \"malware\" ad-hoc i introduir-lo a v\u00edctimes fent servir algun exploit)\nYara (eina per crear definicions pr\u00f2pies de detecci\u00f3 de malware) PENDENT  Hardering local:\nEncriptaci\u00f3 de disc amb LUKS i de sistemes de fitxers amb Ecryptfs (Pes 3)\nEncriptaci\u00f3 de fitxers amb GPG\nContrasenyes arranc al gestor Grub (Pes 3)\nSysctl (Pes 3)\nUdev \"i bad usbs\"  Monitoritzaci\u00f3 de xarxa:\nInspecci\u00f3 en brut del tr\u00e0fic de xarxa i generaci\u00f3 d'alertes\nBreu descripci\u00f3 del protocol TCP\nWireshark(Pes 4)\nNIDS Snort/Suricata (Pes 4)\nConstructor de paquets Scapy  Recol.lectors d'informaci\u00f3 estad\u00edstica sobre el tr\u00e0fic de xarxa\nEines TSBD\nNetflow i IPFIX\nMonitoritzaci\u00f3 d'ample de banda amb Cacti (Pes 4) PENDENT  Hardering de xarxa i servidors:\nTallafocs\nTallafocs Netfilter (NFTables) (Pes 5)\nTallafocs Firewalld  Vulnerabilitats\nIntroducci\u00f3 a les vulnerabilitats (web)\nDetector de vulnerabilitats OpenVAS (Pes 4)PENDENT\nDetector de vulnerabilitat Nmap (Pes 4)\nDetector de vulnerabilitats ZAP  Criptografia pr\u00e0ctica amb OpenSSL\nConceptes de criptografia (Pes 5)\nXuleta comandes OpenSSL(Pes 5)PENDENT  Securitzaci\u00f3 d'un servidor Apache\nImplementaci\u00f3 servidor Apache segur (HTTPS)(Pes 4)\nDNSSEC\nNFS i CIFS segurs\nVPNs amb OpenVPN i IPSec  Llibres:\nLlibre PacktPub",
            "title": "Documentos del curso"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/",
            "text": "Comandos b\u00e1sicos de red en Linux\n\uf0c1\n\n\nNomenclatura de tarjetas de red:\n\uf0c1\n\n\nLas tarjetas de red en sistemas Linux se pueden llamar de las siguientes maneras:\n\n\n\n\nlo\n: Corresponde a la tarjeta \"loopback\". Recordemos que hemos dicho que esta tarjeta f\u00edsicamente no existe (es un \"invento\" del sistema operativo) y suele tener siempre tiene la IP 127.0.0.1/8. Sirve para establecer una conexi\u00f3n con s\u00ed misma, de tal forma que podemos tener en la misma m\u00e1quina un programa cliente que conecte a un programa servidor sin salir \"fuera\".\n\n\neno1, eno2\n: Tarjetas Ethernet integradas en la placa base ( \"on-board\")\n\n\nens1, ens2\n: Tarjetas Ethernet PCI ( \"slot\")\n\n\nenp2s0, p3p1\n: Tarjetas Ethernet que no se pueden localizar de otra forma debido a limitaciones de la BIOS\n\n\nwlp2s0\n:tarjetas WiFi\n\n\n\n\nDentro de las m\u00e1quinas virtuales de VirtualBox las tarjetas de red cogen siempre un nombre concreto: la tarjeta correspondiente a la primera pesta\u00f1a del cuadro de configuraci\u00f3n de red se llamar\u00e1 \"enp0s3\" dentro del sistema virtualizado, la segunda \"enp0s8\", la tercera \"enp0s9\" y la cuarta \"enp0s10\".\n\n\nVer la configuraci\u00f3n actual\n\uf0c1\n\n\nEstado y configuraci\u00f3n de las tarjetas detectadas\n\uf0c1\n\n\nEl comando \nip address show\n (o bien \nip address show dev nomTarjeta\n si s\u00f3lo se quiere obtener la informaci\u00f3n de una tarjeta determinada) nos muestra:\n\n\n\n\nLas direcciones MAC de las tarjetas\n\n\nSu estado respectivo (UP, DOWN)\n\n\nSus direcciones IP respectivas (y la m\u00e1scara correspondiente)\n\n\nOtros datos (como si permite el env\u00edo \"broadcast\", si est\u00e1 en modo \"promiscuo\", etc).\n\n\n\n\n\n\nNOTA: El comando \nip address show\n se puede escribir de forma m\u00e1s corta as\u00ed: \nip a s\n. Incluso, se puede dejar de escribir el verbo show (o s) porque es la acci\u00f3n por defecto (por lo tanto, se puede hacer \nip address\n o \nip a\n y ser\u00eda lo mismo). Tambi\u00e9n es \u00fatil el par\u00e1metro -c (as\u00ed: \nip -c a s\n) para ver los datos m\u00e1s relevantes en colores.\n\n\n\n\nPara activar / desactivar una tarjeta: ip link set {up|down} dev nomTarjeta\n\n\nPuerta de enlace\n\uf0c1\n\n\nEl comando \nip route show\n (o bien \nip route show dev nomTarjeta\n o sus variantes \nip route\n, \nip r s\n o \nip r\n) debe mostrar una l\u00ednea que comenzar\u00e1 con la expresi\u00f3n \n\"default v\u00eda\"\n seguida de la direcci\u00f3n IP de la puerta de enlace establecida. \nEste comando puede mostrar m\u00e1s l\u00edneas, pero no nos interesar\u00e1n mucho ... (quiz\u00e1s la m\u00e1s curiosa es una que sirve para indicar que no hay ninguna puerta de enlace para comunicarse con las m\u00e1quinas que pertenezcan a la misma red a la que pertenece nuestra m\u00e1quina).\n\n\nDNS\n\uf0c1\n\n\nPara saber la direcci\u00f3n IP del servidor DNS configurado en nuestra m\u00e1quina (o las IPs \u2026 si hay m\u00e1s de una se prueba conectar a la primera y si esta falla entonces se prueba la segunda, y as\u00ed) se puede consultar el archivo \netc/resolv.conf\n (concretamente, las l\u00edneas que comienzan por la palabra nameserver). Estos servidores ser\u00e1n los que todas las aplicaciones del sistema (desde el ping hasta el navegador) utilizar\u00e1n para averiguar cu\u00e1l es la IP del nombre que el usuario haya escrito.\n\n\nEl contenido de este archivo suele ser gestionado por diferentes programas (como puede ser el cliente \ndhclient\n, la aplicaci\u00f3n \nNetworkManager\n, el servicio \nnetworking\n, el servicio \nsystemd-networkd/resolved\n, etc) y es por ello que no se recomienda modificarlo manualmente ya que los cambios realizados a mano podr\u00edan \u00abMachacar\u00bb sin avisar en cualquier momento por cualquiera de estos programas.\n\n\nEn este sentido, estos programas (\ndhclient, NetworkManager, \u00abnetworking\u00bb, \u00absystemd-networkd / resolved, etc\n) guardan los servidores DNS que usan dentro de sus propios archivos de configuraci\u00f3n y los manipulan all\u00ed de forma aut\u00f3noma (por ejemplo NetworkManager usa /var/run/NetworkManager/resolv.conf, \u00absystemd-resolved\u00bb usa /run/systemd/resolve/resolv.conf, \u00abNetworking\u00bb usa la l\u00ednea dns-nameservers dentro de /etc/network/interfaces, etc) pero adem\u00e1s siempre vinculan en forma de enlace simb\u00f3lico su archivo propio respectivo al archivo com\u00fan /etc/resolv.conf para que los programas que utilicen este archivo com\u00fan no tengan problemas en encontrar los servidores DNS.\n\n\nEstablecer una configuraci\u00f3n de red est\u00e1tica de forma temporal\n\uf0c1\n\n\n\n\n\n\nPara asignar una IP / m\u00e1scara concreta a una tarjeta: \n\nip address add v.x.y.z/n dev nomTarjeta\n\n\n\n\n\n\nPara borrar una IP / m\u00e1scara concreta de una tarjeta: \nip address del v.x.y.z / n dev nomTarjeta\n\n\n\n\n\n\n\n\nNOTA: Tambi\u00e9n se puede hacer \nip address flush dev nomTarjeta\n si lo que se quiere es borrar de golpe cualesquiera de las eventuales diferentes direcciones IP que pueda tener la tarjeta indicada\n\n\n\n\nPara asignar la puerta de enlace concreta a una tarjeta: \nip route add default v\u00eda v.x.y.z dev nomTarjeta\n. Antes, sin embargo, deber\u00eda borrar la que hab\u00eda asignada antes (si no se hace da error), as\u00ed: \nip route del default dev nomTarjeta\n.\n\n\n\n\nNOTA: Tambi\u00e9n se puede escribir \nip route add 0.0.0.0/0 v\u00eda v.x.y.z dev nomTarjeta\n. Es equivalente.\n\n\nNOTA: De forma alternativa, en vez de hacer \nip route del \u2026\n y despu\u00e9s \nip route add \u2026\n, el cambio de puerta de enlace predeterminada se podr\u00eda hacer directamente en un solo paso, as\u00ed: \nip route change default v\u00eda v.x.y.z dev nomTarjeta\n\n\nNOTA: Tambi\u00e9n se puede indicar que se quiere utilizar una determinada puerta de enlace s\u00f3lo para llegar a una red-destino concreta. En este caso, entonces, no estar\u00edamos hablando de puerta de enlace \u00abpor defecto\u00bb sino de una puerta de enlace \u00abespec\u00edfica\u00bb. La puerta de enlace \u00abpor defecto\u00bb ser\u00eda usada una vez que el sistema hubiera comprobado que el destino deseado no forma parte del conjunto de destinos indicados en puertas de enlace espec\u00edficas. Para crear una puerta de enlace espec\u00edfica hay que ejecutar el comando \nip route add ip.red.Destino/Mascara v\u00eda v.x.y.z dev nomTarjeta\n Se puede a\u00f1adir adem\u00e1s un \u00faltimo par\u00e1metro metric n, que indica la preferencia de la ruta en el caso de que hubieran varias que llevaran al mismo destino (a modo de \u00abbackup\u00bb): un n menor indica una mayor preferencia.\n\n\nNOTA: Una vez asignada una direcci\u00f3n IP a una tarjeta, el sistema calcula autom\u00e1ticamente su direcci\u00f3n IP de red correspondiente y genera una ruta a ella (es por eso que es necesario indicar la m\u00e1scara en ip address add \u2026)\nPor ejemplo, si se asigna la IP 203.0.113.25/24 a la tarjeta enp0s3, se crear\u00e1 autom\u00e1ticamente una ruta en la red 203.0.113.0/24 directa, por lo que el sistema sabr\u00e1 que para comunicarse con hosts de esta red no necesitar\u00e1 ninguna puerta de enlace intermediaria sino que lo podr\u00e1 hacer directamente.\n\n\n\n\nEstablecer una configuraci\u00f3n est\u00e1tica de forma permanente (en sistemas Debian cl\u00e1sicos)\n\uf0c1\n\n\nTodos los comandos anteriores, sin embargo, s\u00f3lo \u00abfuncionan\u00bb mientras la m\u00e1quina se mantiene encendida: si apaga entonces las direcciones IP / m\u00e1scaras y puertas de enlace configuradas con las \u00f3rdenes \u00abip\u00bb anteriores se pierden y hay, pues, que volver a ejecutarlas de nuevo en el siguiente inicio.\n\n\nPara que la configuraci\u00f3n deseada de IP / m\u00e1scara y puerta de enlace (y servidor DNS tambi\u00e9n, gestionado con alguno de los programas comentados en p\u00e1rrafos anteriores) para una determinada tarjeta de red se mantenga de forma permanente en cada reinicio de la m\u00e1quina, hay que escribir los valores adecuados en un determinado archivo. En sistemas Debian/Ubuntu, este archivo se denomina /etc/network/interfaces y debe tener un aspecto similar al siguiente (las l\u00edneas que comienzan por # son comentarios, las tabulaciones son opcionales):\n\n\n# Las l\u00edneas \"auto\" sirven para activar la tarjeta en cuesti\u00f3n (en este #caso la tarjeta \"lo\")\nauto lo\n# La l\u00ednea siguiente indica que la tarjeta \"lo\" es de \n# tipo \"loopback\" (y que, por tanto, tendr\u00e1 la IP 127.0.0.1)\niface lo inet loopback\n# En el mismo archivo se pueden configurar todas las tarjetas que \n# se quieran: la siguiente se llama enp3s0\nauto enp3s0\n# La palabra \"static\" indica que los valores de IP, m\u00e1scara, etc \n# son fijos en cada reinicio\niface enp3s0 inet static\n# A continuaci\u00f3n se indican los valores de IP, m\u00e1scara, puerta de \n# enlace y servidores DNS que se quieren asignar\naddress v.x.y.z\nnetmask w.w.w.w\ngateway v.x.y.z\ndns-nameservers v.x.y.z v.x.y.z\n\n\n\n\n\nNOTA: Atenci\u00f3n, la l\u00ednea \u00ab\ndns-nameservers\n\u00bb del archivo anterior s\u00f3lo funciona (es decir, se copian los servidores DNS indicados all\u00ed en el archivo central del sistema donde deben estar para ser utilizados: /etc/resolv.conf) si hay instalado un paquete llamado \u00ab\nresolvconf\n\u00bb. Si no lo est\u00e1, estas l\u00edneas no se  tendr\u00e1n en cuenta.\n\n\n\n\nEste archivo es le\u00eddo por un servicio del sistema (un demonio) que se pone en marcha autom\u00e1ticamente al arrancar la m\u00e1quina y que se denomina \u00abnetworking\u00bb. Esto quiere decir que en cualquier momento que hagamos un cambio dentro de este archivo, para que se tenga en cuenta o bien habr\u00e1 que reiniciar la m\u00e1quina o bien simplemente reiniciar el servicio, as\u00ed: \nsudo systemctl restart networking\n\n\nEstablecer una configuraci\u00f3n est\u00e1tica de forma permanente (en sistemas systemd)\n\uf0c1\n\n\n\u00abSystemd-networkd\u00bb\n es un demonio que gestiona las configuraciones de las diferentes interfaces de red (f\u00edsicas y / o virtuales) de un sistema systemd, representando, pues, una alternativa al demonio \u00abNetworking\u00bb de sistemas Debian as\u00ed como tambi\u00e9n al scripts ifcfg- * cl\u00e1sicos de Fedora / Suse o al Network Manager integrado en muchos escritorios.\n\n\nPara empezar a utilizar este demonio es recomendable detener primero la \u00abcompetencia\u00bb, por ejemplo, en el caso de Ubuntu ejecutando\n\n\nsudo sytemctl disable networking && sudo systemctl stop networking)\n\n\nY entonces encenderlo junto con el servicio \u00absystemd-resolved\u00bb, as\u00ed, por ejemplo:\n\n\n\n\nNote\n\n\nAl igual que ocurr\u00eda con el paquete \u00abresolvconf\u00bb en los sistemas Debian, se necesita tener un servicio adicional instalado (y funcionando) en el sistema llamado \u00absystemd-resolved\u00bb si se quieren especificar entradas DNS expl\u00edcitas en los archivos .network (o bien si se obtienen v\u00eda DHCP). Este servicio lo que hace es, a partir de estas entradas, modificar el archivo /run/systemd/resolve/resolv.conf, el cual, por compatibilidad con muchos programas tradicionales, deber\u00eda apuntar en forma de enlace suave en /etc/resolv.conf (ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf). Alternativamente, se puede no utilizar systemd-resolved y modificar entonces el archivo /etc/resolv.conf a mano.\n\n\n\n\nSe pueden ver el nombre (y tipo y estado) de las interfaces de red actualmente reconocidas en el sistema (y su tipo y estado) mediante el comando \nnetworkctl list\n. Si en la columna SETUP aparece \u00abunmanaged\u00bb significa que esta interfaz concreta no es gestionada por systemd-networkd sino por alg\u00fan otro servicio alternativo. Otra orden que da m\u00e1s informaci\u00f3n es \nnetworkctl status\n. En cualquier caso, para hacer que se gestione por systemd-networkd, por cada interfaz hay que crear un archivo * .network dentro de la carpeta /etc/systemd/network (y reiniciar el servicio). En el caso concreto de querer asignar una IP est\u00e1tica, ser\u00eda necesario, pues, tener un archivo como este (llamado por ejemplo \u00ab/etc/systemd/network/lalala.network \u00ab):\n\n\n[Match]\nName=enp1s0\n#Identifica la tarjeta a la cual se le aplicar\u00e1 la configuraci\u00f3n\n[Network]\nDHCP=no\nAddress=10.1.10.9/24\nGateway=10.1.10.1\nDNS=10.1.10.2 #Opcional (Es necesario tener el servicio systemd-resolved funcionando)\nDNS=10.1.10.3 #Cada servidor DNS ha d'indicar-se en una l\u00ednia separada\n\n\n\n\nLos archivos de configuraci\u00f3n de systemd-networkd proporcionados por la distribuci\u00f3n se encuentran en /usr/lib/systemd/network y los administrados por nosotros se tienen que ubicar en /etc/systemd/network. Todos estos archivos se leen -sin distinci\u00f3n de donde est\u00e9n ubicados \u2013 en orden alfanum\u00e9rico seg\u00fan el nombre que tienen, ganando siempre la primera configuraci\u00f3n encontrada en caso de que afectara a la misma tarjeta. Eso s\u00ed, si en las dos carpetas se encuentra un fichero con el mismo nombre, lo que hay bajo /etc/systemd/network anula siempre a lo que hay en /usr/lib/systemd/network (una consecuencia de esto es que si el archivo en /etc/\u2026 apunta a /dev/null, lo que se estar\u00e1 haciendo es deshabilitar.\n\n\nExisten tres tipos diferentes de archivos de configuraci\u00f3n:\n\n\n\n\nlos \u00ab.network\u00bb aplican la configuraci\u00f3n descrita bajo su secci\u00f3n [Network] a aquellas tarjetas de red que tengan una caracter\u00edstica que concuerde con todos los valores indicados en las diferentes l\u00edneas bajo la secci\u00f3n [Match] (normalmente aqu\u00ed s\u00f3lo indica su nombre mediante una \u00fanica l\u00ednea \u00abName =\u00bb)\n\n\nlos \u00ab.netdev\u00bb sirven para crear nuevas interfaces de red de tipo virtual ( \u00abbridges\u00bb, \u00abbonds\u00bb, etc) -la configuraci\u00f3n de red se seguir\u00e1 indicando en su correspondiente archivo .network)\n\n\nlos \u00ab.link\u00bb sirven para definir nombres alternativos a las tarjetas de red en el momento de ser reconocidas por el sistema (v\u00eda systemd-udev).\n\n\n\n\nEn las l\u00edneas bajo la secci\u00f3n [Match] -por ejemplo, en \u00abName =\u00bb, se puede utilizar el comod\u00edn *. En esta l\u00ednea en concreto tambi\u00e9n se puede escribir un conjunto de nombres separados por un espacio en blanco a modo de diferentes alternativas.\n\n\nEn los archivos .network puede haber una secci\u00f3n (no vista en los ejemplos anteriores) titulada [Link] bajo la que pueden haber varias l\u00edneas m\u00e1s relacionadas con el comportamiento \u00abhardware\u00bb de la tarjeta, como la l\u00ednea \u00abMACAddress = xx: xx: xx: xx: xx: xx\u00bb, la cual sirve para asignar a la tarjeta en cuesti\u00f3n una direcci\u00f3n MAC ficticia, la l\u00ednea \u00abMTUBytes = no\u00bb, la cual sirve para indicar el tama\u00f1o de la MTU admitida (\u00fatil por ejemplo para activar los \u00abjumbo frames\u00bb si se pone 9000 como valor), o la l\u00ednea \u00abARP = no\u00bb para desactivar el protocolo ARP en la tarjeta en cuesti\u00f3n (activado por defecto).\n\n\nLos archivos .netdev suelen tener s\u00f3lo una secci\u00f3n titulada [netdev], la cual debe incluir dos l\u00edneas obligatoriamente: \u00abName =\u00bb (por asignar un nombre a la interfaz virtual que se crear\u00e1) y \u00abKind =\u00bb (para especificar el tipo de interfaz que ser\u00e1: \u00abbridge\u00bb, \u00abbond\u00bb, \u00abVlan\u00bb, \u00abveth\u00bb, etc). En el caso de que sea de tipo \u00abvlan\u00bb, aparecer\u00e1 entonces una secci\u00f3n titulada [VLAN] incluyendo como m\u00ednimo la l\u00ednea \u00abId =\u00bb para indicar el n\u00famero de VLAN que se est\u00e1 creando.\n\n\nLos archivos .link suelen tener una secci\u00f3n [Match] con la l\u00ednea \u00abMACAddress =\u00bb para identificar la tarjeta de red en cuesti\u00f3n y una secci\u00f3n\n[Link] que sirve para manipular las caracter\u00edsticas de esta tarjeta, como por ejemplo su nombre (con la l\u00ednea \u00abName =\u00bb y, opcionalmente, la l\u00ednea \u00abDescription =\u00bb). Si no se crea manualmente ning\u00fan archivo .link, la mayor\u00eda de distribuciones ofrecen un archivo .link predeterminado, generalmente llamado 99-default.link (y ubicado en / usr / lib / systemd / network); es por ello que hay que asegurarse que los ficheros .link \u00abmanuales\u00bb tengan un nombre que asegure su lectura antes de la del archivo 99-default.link.\n\n\nPara m\u00e1s informaci\u00f3n sobre las posibilidades que ofrecen todos estos archivos, consultar las p\u00e1ginas del manual \u00absystemd.network\u00bb, \u00abSystemd.netdev\u00bb y \u00absystemd.link\u00bb.\n\n\n\n\nAtenci\u00f3n\n\n\nNo s\u00f3lo existen el servicio \u00abnetworking\u00bb y \u00absystemd-networkd\u00bb para gestionar las tarjetas de red de nuestro sistema. Tambi\u00e9n podemos encontrar el servicio \u00abNetworkManager\u00bb (sobre todo en sistemas con escritorio) y en las \u00faltimas versiones de Ubuntu el servicio \u00abNetplan\u00bb, entre otros. !!!\n\n\n\n\nEstablecer una configuraci\u00f3n din\u00e1mica de forma temporal\n\uf0c1\n\n\nEn las configuraciones anteriores, tanto la temporal como la permanente, se establece una direcci\u00f3n IP / m\u00e1scara + puerta de enlace concreta, decidida por nosotros. Este m\u00e9todo puede ser \u00fatil para pocas m\u00e1quinas, pero en una red con muchos equipos, puede llegar a ser bastante farragoso, adem\u00e1s de que f\u00e1cilmente se pueden cometer errores (IPs duplicadas, IP no asignadas).\n\n\nOtro m\u00e9todo para establecer estos datos es el m\u00e9todo \u00abdin\u00e1mico\u00bb, en el que la m\u00e1quina en cuesti\u00f3n no tiene asignada de forma fija IP / m\u00e1scara + puerta de enlace + servidor DNS sino que estos datos los obtiene de la red: all\u00ed deber\u00e1 haber escuchando un ordenador ejecutando un software especial llamado \u00abServidor DHCP\u00bb, el cual sirve precisamente para atender estas peticiones de \u00abdatos de red\u00bb y asignarlas a quien las pida. De este modo, se tiene una gesti\u00f3n centralizada del reparto de direcciones IP / m\u00e1scara + puerta de enlace + servidores DNS sin necesidad de realizar ninguna configuraci\u00f3n espec\u00edfica en las m\u00e1quinas clientes. Eso s\u00ed, claro: primero se deber\u00e1 haber instalado y configurado convenientemente en nuestra red este software \u00abservidor DHCP\u00bb (un ejemplo es el paquete \u00abisc-dhcp-server \u00ab), tarea que no veremos (se presupone que esto ya est\u00e1 hecho).\n\n\n\n\nNota\n\n\nOtro cliente similar es el comando host nomDNS [ip.serv.DNS]\n\n\n\n\nPara pedir en un momento determinado una configuraci\u00f3n completa de red (IP, m\u00e1scara, puerta de enlace, servidores DNS, etc) a un servidor DHCP ya funcionando en nuestra LAN hemos de ejecutar un cliente DHCP, como el comando \ndhclient\n\n\nDhclient nomTarjeta\n Pide -para la tarjeta indicada- los datos de red (IP, m\u00e1scara, puerta de enlace, servidor DNS, etc) a alg\u00fan servidor DHCP que est\u00e9 escuchando a la LAN de nuestra m\u00e1quina.\n\n\n-v Muestra por pantalla todo el proceso de petici\u00f3n y respuesta (\u00fatil para ver si va)\n\n\n-r Borra todos los datos de red que pueda tener actualmente la tarjeta indicada\n\n\nEstablecer una configuraci\u00f3n din\u00e1mica de forma permanente\n\uf0c1\n\n\nEn sistemas Debian cl\u00e1sicos\n\uf0c1\n\n\nPara pedir los datos de red a alg\u00fan servidor DHCP de nuestra red, en vez\nde tener que hacerlo manualmente con el comando \ndhclient\n, se puede hacer de forma autom\u00e1tica cada vez que nuestra m\u00e1quina arranque (de modo que nosotros no tengamos que hacer nada y ya tengamos, si todo va bien, estos datos ya asignadas una vez iniciamos sesi\u00f3n). Esto se logra simplemente escribiendo las siguientes l\u00edneas en el archivo /etc/network/interfaces:\n\n\nauto enp3s0\niface enp3s0 inet dhcp\n\n\n\n\nEn sistemas systemd\n\uf0c1\n\n\nEn el caso concreto de querer asignar una IP din\u00e1mica en un sistema con el demonio systemd-netword funcionando, habr\u00e1 que tener un archivo como este (llamado por ejemplo \u00ab/Etc/systemd/network/lalala.network\u00bb):\n\n\n[Match]\nName = enp1s0\n[Network]\nDHCP = yes # Tambi\u00e9n podr\u00eda valer ipv4 o ipv6 seg\u00fan el tipo de direcciones IP que queremos recibir\n\n\n\n\nping\n\uf0c1\n\n\nping ip o Nombre Maq. Remota\n \n\n\nComprueba si la m\u00e1quina remota indicada responde. Sirve, por tanto, para saber si hay conexi\u00f3n de red con aquella m\u00e1quina (si no, podr\u00eda ser debido a cualquier causa: cable mal enchufado o roto, m\u00e1quina remota apagada, etc). En este sentido, son interesantes los datos estad\u00edsticos que aparecen al final (paquetes enviados, recibidos, perdidos, etc) y el tiempo que han tardado en enviarse estos paquetes de prueba (y recibirse la respuesta) -y as\u00ed comprobar la saturaci\u00f3n del medio.\n\n\n-n No resuelve nombres (es decir, no hace la consulta previa en el servidor DNS del sistema). Por lo tanto, s\u00f3lo hace que funcione indicando direcciones IP\n\n\n-c n\u00ba N\u00famero de paquetes de prueba que se enviar\u00e1n (si no se indica, son infinitos y hay que detener el env\u00edo pulsando CTRL + C)\n\n\n-i n\u00baN\u00famero de segundos que se espera para enviar el siguiente paquete\n\n\n-f Mode \u00abflood\u00bb. Env\u00eda paquetes a la m\u00e1xima velocidad posible, mostrando un punto por cada paquete enviado y borr\u00e1ndose el por cada respuesta recibida: por lo tanto, para ir bien habr\u00eda que s\u00f3lo se viera un punto y fuera desapareciendo: si se ven muchos puntos es que hay p\u00e9rdida de paquetes. Hay que ser root para que funcione\n\n\n-I eno1 Indica la tarjeta de red para la que se enviar\u00e1n los paquetes (por si la m\u00e1quina tuviera m\u00e1s de una)\n\n\nmtr\n\uf0c1\n\n\nmtr ip.o Nom.Maq.Remota\n\n\nSirve para conocer el camino seguido por un paquete desde la m\u00e1quina origen hasta la indicada, mostrando la IP (o nombre) de todos los routers\nintermedios a trav\u00e9s de los que va pasando. tambi\u00e9n muestra estad\u00edsticas de tiempo empleado en cada paquete, el mejor tiempo, el peor, los paquetes perdidos, etc\n\n\n-n No resuelve nombres (es decir, no hace la consulta previa en el servidor DNS del sistema).\n\n\n-c n\u00ba N\u00famero de paquetes de prueba que se enviar\u00e1n (si no se indica, son infinitos y hay que parar el env\u00edo pulsando CTRL + C)\n\n\n-i n\u00ba N\u00famero de segundos que se espera para enviar el siguiente paquete",
            "title": "Comandos b\u00e1sicos de red en Linux"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#comandos-basicos-de-red-en-linux",
            "text": "",
            "title": "Comandos b\u00e1sicos de red en Linux"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#nomenclatura-de-tarjetas-de-red",
            "text": "Las tarjetas de red en sistemas Linux se pueden llamar de las siguientes maneras:   lo : Corresponde a la tarjeta \"loopback\". Recordemos que hemos dicho que esta tarjeta f\u00edsicamente no existe (es un \"invento\" del sistema operativo) y suele tener siempre tiene la IP 127.0.0.1/8. Sirve para establecer una conexi\u00f3n con s\u00ed misma, de tal forma que podemos tener en la misma m\u00e1quina un programa cliente que conecte a un programa servidor sin salir \"fuera\".  eno1, eno2 : Tarjetas Ethernet integradas en la placa base ( \"on-board\")  ens1, ens2 : Tarjetas Ethernet PCI ( \"slot\")  enp2s0, p3p1 : Tarjetas Ethernet que no se pueden localizar de otra forma debido a limitaciones de la BIOS  wlp2s0 :tarjetas WiFi   Dentro de las m\u00e1quinas virtuales de VirtualBox las tarjetas de red cogen siempre un nombre concreto: la tarjeta correspondiente a la primera pesta\u00f1a del cuadro de configuraci\u00f3n de red se llamar\u00e1 \"enp0s3\" dentro del sistema virtualizado, la segunda \"enp0s8\", la tercera \"enp0s9\" y la cuarta \"enp0s10\".",
            "title": "Nomenclatura de tarjetas de red:"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#ver-la-configuracion-actual",
            "text": "Estado y configuraci\u00f3n de las tarjetas detectadas \uf0c1  El comando  ip address show  (o bien  ip address show dev nomTarjeta  si s\u00f3lo se quiere obtener la informaci\u00f3n de una tarjeta determinada) nos muestra:   Las direcciones MAC de las tarjetas  Su estado respectivo (UP, DOWN)  Sus direcciones IP respectivas (y la m\u00e1scara correspondiente)  Otros datos (como si permite el env\u00edo \"broadcast\", si est\u00e1 en modo \"promiscuo\", etc).    NOTA: El comando  ip address show  se puede escribir de forma m\u00e1s corta as\u00ed:  ip a s . Incluso, se puede dejar de escribir el verbo show (o s) porque es la acci\u00f3n por defecto (por lo tanto, se puede hacer  ip address  o  ip a  y ser\u00eda lo mismo). Tambi\u00e9n es \u00fatil el par\u00e1metro -c (as\u00ed:  ip -c a s ) para ver los datos m\u00e1s relevantes en colores.   Para activar / desactivar una tarjeta: ip link set {up|down} dev nomTarjeta  Puerta de enlace \uf0c1  El comando  ip route show  (o bien  ip route show dev nomTarjeta  o sus variantes  ip route ,  ip r s  o  ip r ) debe mostrar una l\u00ednea que comenzar\u00e1 con la expresi\u00f3n  \"default v\u00eda\"  seguida de la direcci\u00f3n IP de la puerta de enlace establecida. \nEste comando puede mostrar m\u00e1s l\u00edneas, pero no nos interesar\u00e1n mucho ... (quiz\u00e1s la m\u00e1s curiosa es una que sirve para indicar que no hay ninguna puerta de enlace para comunicarse con las m\u00e1quinas que pertenezcan a la misma red a la que pertenece nuestra m\u00e1quina).  DNS \uf0c1  Para saber la direcci\u00f3n IP del servidor DNS configurado en nuestra m\u00e1quina (o las IPs \u2026 si hay m\u00e1s de una se prueba conectar a la primera y si esta falla entonces se prueba la segunda, y as\u00ed) se puede consultar el archivo  etc/resolv.conf  (concretamente, las l\u00edneas que comienzan por la palabra nameserver). Estos servidores ser\u00e1n los que todas las aplicaciones del sistema (desde el ping hasta el navegador) utilizar\u00e1n para averiguar cu\u00e1l es la IP del nombre que el usuario haya escrito.  El contenido de este archivo suele ser gestionado por diferentes programas (como puede ser el cliente  dhclient , la aplicaci\u00f3n  NetworkManager , el servicio  networking , el servicio  systemd-networkd/resolved , etc) y es por ello que no se recomienda modificarlo manualmente ya que los cambios realizados a mano podr\u00edan \u00abMachacar\u00bb sin avisar en cualquier momento por cualquiera de estos programas.  En este sentido, estos programas ( dhclient, NetworkManager, \u00abnetworking\u00bb, \u00absystemd-networkd / resolved, etc ) guardan los servidores DNS que usan dentro de sus propios archivos de configuraci\u00f3n y los manipulan all\u00ed de forma aut\u00f3noma (por ejemplo NetworkManager usa /var/run/NetworkManager/resolv.conf, \u00absystemd-resolved\u00bb usa /run/systemd/resolve/resolv.conf, \u00abNetworking\u00bb usa la l\u00ednea dns-nameservers dentro de /etc/network/interfaces, etc) pero adem\u00e1s siempre vinculan en forma de enlace simb\u00f3lico su archivo propio respectivo al archivo com\u00fan /etc/resolv.conf para que los programas que utilicen este archivo com\u00fan no tengan problemas en encontrar los servidores DNS.",
            "title": "Ver la configuraci\u00f3n actual"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-de-red-estatica-de-forma-temporal",
            "text": "Para asignar una IP / m\u00e1scara concreta a una tarjeta:  ip address add v.x.y.z/n dev nomTarjeta    Para borrar una IP / m\u00e1scara concreta de una tarjeta:  ip address del v.x.y.z / n dev nomTarjeta     NOTA: Tambi\u00e9n se puede hacer  ip address flush dev nomTarjeta  si lo que se quiere es borrar de golpe cualesquiera de las eventuales diferentes direcciones IP que pueda tener la tarjeta indicada   Para asignar la puerta de enlace concreta a una tarjeta:  ip route add default v\u00eda v.x.y.z dev nomTarjeta . Antes, sin embargo, deber\u00eda borrar la que hab\u00eda asignada antes (si no se hace da error), as\u00ed:  ip route del default dev nomTarjeta .   NOTA: Tambi\u00e9n se puede escribir  ip route add 0.0.0.0/0 v\u00eda v.x.y.z dev nomTarjeta . Es equivalente.  NOTA: De forma alternativa, en vez de hacer  ip route del \u2026  y despu\u00e9s  ip route add \u2026 , el cambio de puerta de enlace predeterminada se podr\u00eda hacer directamente en un solo paso, as\u00ed:  ip route change default v\u00eda v.x.y.z dev nomTarjeta  NOTA: Tambi\u00e9n se puede indicar que se quiere utilizar una determinada puerta de enlace s\u00f3lo para llegar a una red-destino concreta. En este caso, entonces, no estar\u00edamos hablando de puerta de enlace \u00abpor defecto\u00bb sino de una puerta de enlace \u00abespec\u00edfica\u00bb. La puerta de enlace \u00abpor defecto\u00bb ser\u00eda usada una vez que el sistema hubiera comprobado que el destino deseado no forma parte del conjunto de destinos indicados en puertas de enlace espec\u00edficas. Para crear una puerta de enlace espec\u00edfica hay que ejecutar el comando  ip route add ip.red.Destino/Mascara v\u00eda v.x.y.z dev nomTarjeta  Se puede a\u00f1adir adem\u00e1s un \u00faltimo par\u00e1metro metric n, que indica la preferencia de la ruta en el caso de que hubieran varias que llevaran al mismo destino (a modo de \u00abbackup\u00bb): un n menor indica una mayor preferencia.  NOTA: Una vez asignada una direcci\u00f3n IP a una tarjeta, el sistema calcula autom\u00e1ticamente su direcci\u00f3n IP de red correspondiente y genera una ruta a ella (es por eso que es necesario indicar la m\u00e1scara en ip address add \u2026)\nPor ejemplo, si se asigna la IP 203.0.113.25/24 a la tarjeta enp0s3, se crear\u00e1 autom\u00e1ticamente una ruta en la red 203.0.113.0/24 directa, por lo que el sistema sabr\u00e1 que para comunicarse con hosts de esta red no necesitar\u00e1 ninguna puerta de enlace intermediaria sino que lo podr\u00e1 hacer directamente.",
            "title": "Establecer una configuraci\u00f3n de red est\u00e1tica de forma temporal"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-estatica-de-forma-permanente-en-sistemas-debian-clasicos",
            "text": "Todos los comandos anteriores, sin embargo, s\u00f3lo \u00abfuncionan\u00bb mientras la m\u00e1quina se mantiene encendida: si apaga entonces las direcciones IP / m\u00e1scaras y puertas de enlace configuradas con las \u00f3rdenes \u00abip\u00bb anteriores se pierden y hay, pues, que volver a ejecutarlas de nuevo en el siguiente inicio.  Para que la configuraci\u00f3n deseada de IP / m\u00e1scara y puerta de enlace (y servidor DNS tambi\u00e9n, gestionado con alguno de los programas comentados en p\u00e1rrafos anteriores) para una determinada tarjeta de red se mantenga de forma permanente en cada reinicio de la m\u00e1quina, hay que escribir los valores adecuados en un determinado archivo. En sistemas Debian/Ubuntu, este archivo se denomina /etc/network/interfaces y debe tener un aspecto similar al siguiente (las l\u00edneas que comienzan por # son comentarios, las tabulaciones son opcionales):  # Las l\u00edneas \"auto\" sirven para activar la tarjeta en cuesti\u00f3n (en este #caso la tarjeta \"lo\")\nauto lo\n# La l\u00ednea siguiente indica que la tarjeta \"lo\" es de \n# tipo \"loopback\" (y que, por tanto, tendr\u00e1 la IP 127.0.0.1)\niface lo inet loopback\n# En el mismo archivo se pueden configurar todas las tarjetas que \n# se quieran: la siguiente se llama enp3s0\nauto enp3s0\n# La palabra \"static\" indica que los valores de IP, m\u00e1scara, etc \n# son fijos en cada reinicio\niface enp3s0 inet static\n# A continuaci\u00f3n se indican los valores de IP, m\u00e1scara, puerta de \n# enlace y servidores DNS que se quieren asignar\naddress v.x.y.z\nnetmask w.w.w.w\ngateway v.x.y.z\ndns-nameservers v.x.y.z v.x.y.z   NOTA: Atenci\u00f3n, la l\u00ednea \u00ab dns-nameservers \u00bb del archivo anterior s\u00f3lo funciona (es decir, se copian los servidores DNS indicados all\u00ed en el archivo central del sistema donde deben estar para ser utilizados: /etc/resolv.conf) si hay instalado un paquete llamado \u00ab resolvconf \u00bb. Si no lo est\u00e1, estas l\u00edneas no se  tendr\u00e1n en cuenta.   Este archivo es le\u00eddo por un servicio del sistema (un demonio) que se pone en marcha autom\u00e1ticamente al arrancar la m\u00e1quina y que se denomina \u00abnetworking\u00bb. Esto quiere decir que en cualquier momento que hagamos un cambio dentro de este archivo, para que se tenga en cuenta o bien habr\u00e1 que reiniciar la m\u00e1quina o bien simplemente reiniciar el servicio, as\u00ed:  sudo systemctl restart networking",
            "title": "Establecer una configuraci\u00f3n est\u00e1tica de forma permanente (en sistemas Debian cl\u00e1sicos)"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-estatica-de-forma-permanente-en-sistemas-systemd",
            "text": "\u00abSystemd-networkd\u00bb  es un demonio que gestiona las configuraciones de las diferentes interfaces de red (f\u00edsicas y / o virtuales) de un sistema systemd, representando, pues, una alternativa al demonio \u00abNetworking\u00bb de sistemas Debian as\u00ed como tambi\u00e9n al scripts ifcfg- * cl\u00e1sicos de Fedora / Suse o al Network Manager integrado en muchos escritorios.  Para empezar a utilizar este demonio es recomendable detener primero la \u00abcompetencia\u00bb, por ejemplo, en el caso de Ubuntu ejecutando  sudo sytemctl disable networking && sudo systemctl stop networking)  Y entonces encenderlo junto con el servicio \u00absystemd-resolved\u00bb, as\u00ed, por ejemplo:   Note  Al igual que ocurr\u00eda con el paquete \u00abresolvconf\u00bb en los sistemas Debian, se necesita tener un servicio adicional instalado (y funcionando) en el sistema llamado \u00absystemd-resolved\u00bb si se quieren especificar entradas DNS expl\u00edcitas en los archivos .network (o bien si se obtienen v\u00eda DHCP). Este servicio lo que hace es, a partir de estas entradas, modificar el archivo /run/systemd/resolve/resolv.conf, el cual, por compatibilidad con muchos programas tradicionales, deber\u00eda apuntar en forma de enlace suave en /etc/resolv.conf (ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf). Alternativamente, se puede no utilizar systemd-resolved y modificar entonces el archivo /etc/resolv.conf a mano.   Se pueden ver el nombre (y tipo y estado) de las interfaces de red actualmente reconocidas en el sistema (y su tipo y estado) mediante el comando  networkctl list . Si en la columna SETUP aparece \u00abunmanaged\u00bb significa que esta interfaz concreta no es gestionada por systemd-networkd sino por alg\u00fan otro servicio alternativo. Otra orden que da m\u00e1s informaci\u00f3n es  networkctl status . En cualquier caso, para hacer que se gestione por systemd-networkd, por cada interfaz hay que crear un archivo * .network dentro de la carpeta /etc/systemd/network (y reiniciar el servicio). En el caso concreto de querer asignar una IP est\u00e1tica, ser\u00eda necesario, pues, tener un archivo como este (llamado por ejemplo \u00ab/etc/systemd/network/lalala.network \u00ab):  [Match]\nName=enp1s0\n#Identifica la tarjeta a la cual se le aplicar\u00e1 la configuraci\u00f3n\n[Network]\nDHCP=no\nAddress=10.1.10.9/24\nGateway=10.1.10.1\nDNS=10.1.10.2 #Opcional (Es necesario tener el servicio systemd-resolved funcionando)\nDNS=10.1.10.3 #Cada servidor DNS ha d'indicar-se en una l\u00ednia separada  Los archivos de configuraci\u00f3n de systemd-networkd proporcionados por la distribuci\u00f3n se encuentran en /usr/lib/systemd/network y los administrados por nosotros se tienen que ubicar en /etc/systemd/network. Todos estos archivos se leen -sin distinci\u00f3n de donde est\u00e9n ubicados \u2013 en orden alfanum\u00e9rico seg\u00fan el nombre que tienen, ganando siempre la primera configuraci\u00f3n encontrada en caso de que afectara a la misma tarjeta. Eso s\u00ed, si en las dos carpetas se encuentra un fichero con el mismo nombre, lo que hay bajo /etc/systemd/network anula siempre a lo que hay en /usr/lib/systemd/network (una consecuencia de esto es que si el archivo en /etc/\u2026 apunta a /dev/null, lo que se estar\u00e1 haciendo es deshabilitar.  Existen tres tipos diferentes de archivos de configuraci\u00f3n:   los \u00ab.network\u00bb aplican la configuraci\u00f3n descrita bajo su secci\u00f3n [Network] a aquellas tarjetas de red que tengan una caracter\u00edstica que concuerde con todos los valores indicados en las diferentes l\u00edneas bajo la secci\u00f3n [Match] (normalmente aqu\u00ed s\u00f3lo indica su nombre mediante una \u00fanica l\u00ednea \u00abName =\u00bb)  los \u00ab.netdev\u00bb sirven para crear nuevas interfaces de red de tipo virtual ( \u00abbridges\u00bb, \u00abbonds\u00bb, etc) -la configuraci\u00f3n de red se seguir\u00e1 indicando en su correspondiente archivo .network)  los \u00ab.link\u00bb sirven para definir nombres alternativos a las tarjetas de red en el momento de ser reconocidas por el sistema (v\u00eda systemd-udev).   En las l\u00edneas bajo la secci\u00f3n [Match] -por ejemplo, en \u00abName =\u00bb, se puede utilizar el comod\u00edn *. En esta l\u00ednea en concreto tambi\u00e9n se puede escribir un conjunto de nombres separados por un espacio en blanco a modo de diferentes alternativas.  En los archivos .network puede haber una secci\u00f3n (no vista en los ejemplos anteriores) titulada [Link] bajo la que pueden haber varias l\u00edneas m\u00e1s relacionadas con el comportamiento \u00abhardware\u00bb de la tarjeta, como la l\u00ednea \u00abMACAddress = xx: xx: xx: xx: xx: xx\u00bb, la cual sirve para asignar a la tarjeta en cuesti\u00f3n una direcci\u00f3n MAC ficticia, la l\u00ednea \u00abMTUBytes = no\u00bb, la cual sirve para indicar el tama\u00f1o de la MTU admitida (\u00fatil por ejemplo para activar los \u00abjumbo frames\u00bb si se pone 9000 como valor), o la l\u00ednea \u00abARP = no\u00bb para desactivar el protocolo ARP en la tarjeta en cuesti\u00f3n (activado por defecto).  Los archivos .netdev suelen tener s\u00f3lo una secci\u00f3n titulada [netdev], la cual debe incluir dos l\u00edneas obligatoriamente: \u00abName =\u00bb (por asignar un nombre a la interfaz virtual que se crear\u00e1) y \u00abKind =\u00bb (para especificar el tipo de interfaz que ser\u00e1: \u00abbridge\u00bb, \u00abbond\u00bb, \u00abVlan\u00bb, \u00abveth\u00bb, etc). En el caso de que sea de tipo \u00abvlan\u00bb, aparecer\u00e1 entonces una secci\u00f3n titulada [VLAN] incluyendo como m\u00ednimo la l\u00ednea \u00abId =\u00bb para indicar el n\u00famero de VLAN que se est\u00e1 creando.  Los archivos .link suelen tener una secci\u00f3n [Match] con la l\u00ednea \u00abMACAddress =\u00bb para identificar la tarjeta de red en cuesti\u00f3n y una secci\u00f3n\n[Link] que sirve para manipular las caracter\u00edsticas de esta tarjeta, como por ejemplo su nombre (con la l\u00ednea \u00abName =\u00bb y, opcionalmente, la l\u00ednea \u00abDescription =\u00bb). Si no se crea manualmente ning\u00fan archivo .link, la mayor\u00eda de distribuciones ofrecen un archivo .link predeterminado, generalmente llamado 99-default.link (y ubicado en / usr / lib / systemd / network); es por ello que hay que asegurarse que los ficheros .link \u00abmanuales\u00bb tengan un nombre que asegure su lectura antes de la del archivo 99-default.link.  Para m\u00e1s informaci\u00f3n sobre las posibilidades que ofrecen todos estos archivos, consultar las p\u00e1ginas del manual \u00absystemd.network\u00bb, \u00abSystemd.netdev\u00bb y \u00absystemd.link\u00bb.   Atenci\u00f3n  No s\u00f3lo existen el servicio \u00abnetworking\u00bb y \u00absystemd-networkd\u00bb para gestionar las tarjetas de red de nuestro sistema. Tambi\u00e9n podemos encontrar el servicio \u00abNetworkManager\u00bb (sobre todo en sistemas con escritorio) y en las \u00faltimas versiones de Ubuntu el servicio \u00abNetplan\u00bb, entre otros. !!!",
            "title": "Establecer una configuraci\u00f3n est\u00e1tica de forma permanente (en sistemas systemd)"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-dinamica-de-forma-temporal",
            "text": "En las configuraciones anteriores, tanto la temporal como la permanente, se establece una direcci\u00f3n IP / m\u00e1scara + puerta de enlace concreta, decidida por nosotros. Este m\u00e9todo puede ser \u00fatil para pocas m\u00e1quinas, pero en una red con muchos equipos, puede llegar a ser bastante farragoso, adem\u00e1s de que f\u00e1cilmente se pueden cometer errores (IPs duplicadas, IP no asignadas).  Otro m\u00e9todo para establecer estos datos es el m\u00e9todo \u00abdin\u00e1mico\u00bb, en el que la m\u00e1quina en cuesti\u00f3n no tiene asignada de forma fija IP / m\u00e1scara + puerta de enlace + servidor DNS sino que estos datos los obtiene de la red: all\u00ed deber\u00e1 haber escuchando un ordenador ejecutando un software especial llamado \u00abServidor DHCP\u00bb, el cual sirve precisamente para atender estas peticiones de \u00abdatos de red\u00bb y asignarlas a quien las pida. De este modo, se tiene una gesti\u00f3n centralizada del reparto de direcciones IP / m\u00e1scara + puerta de enlace + servidores DNS sin necesidad de realizar ninguna configuraci\u00f3n espec\u00edfica en las m\u00e1quinas clientes. Eso s\u00ed, claro: primero se deber\u00e1 haber instalado y configurado convenientemente en nuestra red este software \u00abservidor DHCP\u00bb (un ejemplo es el paquete \u00abisc-dhcp-server \u00ab), tarea que no veremos (se presupone que esto ya est\u00e1 hecho).   Nota  Otro cliente similar es el comando host nomDNS [ip.serv.DNS]   Para pedir en un momento determinado una configuraci\u00f3n completa de red (IP, m\u00e1scara, puerta de enlace, servidores DNS, etc) a un servidor DHCP ya funcionando en nuestra LAN hemos de ejecutar un cliente DHCP, como el comando  dhclient  Dhclient nomTarjeta  Pide -para la tarjeta indicada- los datos de red (IP, m\u00e1scara, puerta de enlace, servidor DNS, etc) a alg\u00fan servidor DHCP que est\u00e9 escuchando a la LAN de nuestra m\u00e1quina.  -v Muestra por pantalla todo el proceso de petici\u00f3n y respuesta (\u00fatil para ver si va)  -r Borra todos los datos de red que pueda tener actualmente la tarjeta indicada",
            "title": "Establecer una configuraci\u00f3n din\u00e1mica de forma temporal"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-dinamica-de-forma-permanente",
            "text": "En sistemas Debian cl\u00e1sicos \uf0c1  Para pedir los datos de red a alg\u00fan servidor DHCP de nuestra red, en vez\nde tener que hacerlo manualmente con el comando  dhclient , se puede hacer de forma autom\u00e1tica cada vez que nuestra m\u00e1quina arranque (de modo que nosotros no tengamos que hacer nada y ya tengamos, si todo va bien, estos datos ya asignadas una vez iniciamos sesi\u00f3n). Esto se logra simplemente escribiendo las siguientes l\u00edneas en el archivo /etc/network/interfaces:  auto enp3s0\niface enp3s0 inet dhcp  En sistemas systemd \uf0c1  En el caso concreto de querer asignar una IP din\u00e1mica en un sistema con el demonio systemd-netword funcionando, habr\u00e1 que tener un archivo como este (llamado por ejemplo \u00ab/Etc/systemd/network/lalala.network\u00bb):  [Match]\nName = enp1s0\n[Network]\nDHCP = yes # Tambi\u00e9n podr\u00eda valer ipv4 o ipv6 seg\u00fan el tipo de direcciones IP que queremos recibir",
            "title": "Establecer una configuraci\u00f3n din\u00e1mica de forma permanente"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#ping",
            "text": "ping ip o Nombre Maq. Remota    Comprueba si la m\u00e1quina remota indicada responde. Sirve, por tanto, para saber si hay conexi\u00f3n de red con aquella m\u00e1quina (si no, podr\u00eda ser debido a cualquier causa: cable mal enchufado o roto, m\u00e1quina remota apagada, etc). En este sentido, son interesantes los datos estad\u00edsticos que aparecen al final (paquetes enviados, recibidos, perdidos, etc) y el tiempo que han tardado en enviarse estos paquetes de prueba (y recibirse la respuesta) -y as\u00ed comprobar la saturaci\u00f3n del medio.  -n No resuelve nombres (es decir, no hace la consulta previa en el servidor DNS del sistema). Por lo tanto, s\u00f3lo hace que funcione indicando direcciones IP  -c n\u00ba N\u00famero de paquetes de prueba que se enviar\u00e1n (si no se indica, son infinitos y hay que detener el env\u00edo pulsando CTRL + C)  -i n\u00baN\u00famero de segundos que se espera para enviar el siguiente paquete  -f Mode \u00abflood\u00bb. Env\u00eda paquetes a la m\u00e1xima velocidad posible, mostrando un punto por cada paquete enviado y borr\u00e1ndose el por cada respuesta recibida: por lo tanto, para ir bien habr\u00eda que s\u00f3lo se viera un punto y fuera desapareciendo: si se ven muchos puntos es que hay p\u00e9rdida de paquetes. Hay que ser root para que funcione  -I eno1 Indica la tarjeta de red para la que se enviar\u00e1n los paquetes (por si la m\u00e1quina tuviera m\u00e1s de una)",
            "title": "ping"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#mtr",
            "text": "mtr ip.o Nom.Maq.Remota  Sirve para conocer el camino seguido por un paquete desde la m\u00e1quina origen hasta la indicada, mostrando la IP (o nombre) de todos los routers\nintermedios a trav\u00e9s de los que va pasando. tambi\u00e9n muestra estad\u00edsticas de tiempo empleado en cada paquete, el mejor tiempo, el peor, los paquetes perdidos, etc  -n No resuelve nombres (es decir, no hace la consulta previa en el servidor DNS del sistema).  -c n\u00ba N\u00famero de paquetes de prueba que se enviar\u00e1n (si no se indica, son infinitos y hay que parar el env\u00edo pulsando CTRL + C)  -i n\u00ba N\u00famero de segundos que se espera para enviar el siguiente paquete",
            "title": "mtr"
        }
    ]
}