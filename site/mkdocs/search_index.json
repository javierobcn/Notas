{
    "docs": [
        {
            "location": "/",
            "text": "Notas y Apuntes\n\uf0c1\n\n\n\n\n\n\nLPIC 1\n\uf0c1\n\n\n\n\n\n\nLPIC 2\n\uf0c1\n\n\n\n\n\n\nLPIC 3\n\uf0c1\n\n\n\n\n\n\nMarkdown\n\uf0c1",
            "title": "Home"
        },
        {
            "location": "/About/",
            "text": "About\n\uf0c1\n\n\nMarkmin Syntax\n\uf0c1\n\n\nmkdocs\n\uf0c1\n\n\nSnippets\n\uf0c1",
            "title": "About"
        },
        {
            "location": "/About/#about",
            "text": "",
            "title": "About"
        },
        {
            "location": "/About/#markmin-syntax",
            "text": "",
            "title": "Markmin Syntax"
        },
        {
            "location": "/About/#mkdocs",
            "text": "",
            "title": "mkdocs"
        },
        {
            "location": "/About/#snippets",
            "text": "",
            "title": "Snippets"
        },
        {
            "location": "/LPIC3/",
            "text": "Material curs LPIC 3-303\n\uf0c1\n\n\nEnlaces sobre los ex\u00e1menes:\n\uf0c1\n\n\n\n\nResumen de las certificaciones\n\n\nResumen de la certificaci\u00f3n LPIC-3 (303)\n\n\nLo que hace falta saber para superar el examen 303\n\n\n\n\nRecursos para descargar:\n\uf0c1\n\n\n\n\nM\u00e0quina servidora LDAP+Kerberos+NFS4 ja funcional\n\n\nM\u00e0quina client SSSD ja funcional\n\n\nArxiu ldif amb usuaris de mostra\n\n\n\n\nDocumentos del curso\n\uf0c1\n\n\n1.Previos\n\uf0c1\n\n\n\n\nComandos b\u00e1sicos de red en Linux\n\n\nTeoria b\u00e1sica sobre LDAP (i NSS)\n\n\nTeoria b\u00e1sica sobre NFS\n\n\nGesti\u00f3 b\u00e1sica de m\u00f2duls del kernel\n\n\nJournald i journalctl\n\n\nSystemd\n\n\nBreu descripci\u00f3 de /proc i de /sys\n\n\nComanda Jq (per l'eve.json de Suricata, Beats de l'ELK, etc)\n\n\nD-Bus (IPC per Firewalld, Systemd,...)\n\n\nServidor Apache (HTTP)\n\n\n\n\nAutenticaci\u00f3-Autoritzaci\u00f3:\n\uf0c1\n\n\n\n\nIntroducci\u00f3n\n\n\nAutenticaci\u00f3n vs Autorizaci\u00f3n\n\n\nHashes i endevinaci\u00f3 de contrasenyes. Keyloggers\n\n\n\n\nM\u00f3dulos PAM\n\uf0c1\n\n\n\n\nPAM i m\u00f2duls interessants (pam_limit, pam_pwquality, etc) (Pes 3)\n\n\nClient Kerberos+LDAP i FreeIPA (NSS+PAM+SSSD)\n\n\nInstal.laci\u00f3 servidor 389DS\n\n\nAdministraci\u00f3 b\u00e1sica d'un directori 389DS\n\n\nAutenticaci\u00f3 i identificaci\u00f3 contra servidor 389DS fent servir SSSD(Pes 5)\n\n\nInstal.laci\u00f3 i configuraci\u00f3 d'un servidor MIT Kerberos i cooperaci\u00f3 amb servidors LDAP i NFS(Pes 5)PENDENT NFS\n\n\nFreeIPA (client, servidor i r\u00e8plica)(Pes 4)PENDENT\n\n\n\n\nFrameworks d'autoritzaci\u00f3\n\uf0c1\n\n\n\n\nSu i sudo\n\n\nPolkit\n\n\n\n\nACLs, Capabilities y atributos extendidos\n\uf0c1\n\n\n\n\nBits suid,sgid,sticky\n\n\nCapabilities i atributs extesos(Pes 3)\n\n\nACLs(Pes 3)\n\n\n\n\nSELinux\n\uf0c1\n\n\n\n\nSELinux(Pes 4)\n\n\n\n\nRADIUS\nRADIUS(Pes 4)\n\n\nChroot i altres \"bitxos\": namespaces, cgroups, OS/App containers\nIntro contenidors(Pes 3)PENDENT\nExemple pr\u00e0ctic: contenidors mkosi/machinectl(Pes 3)\n\n\nMonitoritzaci\u00f3 local:\nCaptura de crides al sistema (i altres events)\nStrace, Ltrace i llibreries\nSysdig i Falco\nAudit(Pes 4)\nAltres FIMs\nELK (amb Falco i Audit)\n\n\nDetectors de rootkits i malware\nLynis, OpenSCAP, Rkhunter, Maldet, Aide (Pes 4)\nAnsible (com a m\u00e8tode per aplicar de forma autom\u00e0tica els canvis de configuraci\u00f3 suggerits pels programes anteriors)\nHoneypots (com a m\u00e8tode de captura i estudi de malware)\nMetasploit (eina per crear \"malware\" ad-hoc i introduir-lo a v\u00edctimes fent servir algun exploit)\nYara (eina per crear definicions pr\u00f2pies de detecci\u00f3 de malware) PENDENT\n\n\nHardering local:\nEncriptaci\u00f3 de disc amb LUKS i de sistemes de fitxers amb Ecryptfs (Pes 3)\nEncriptaci\u00f3 de fitxers amb GPG\nContrasenyes arranc al gestor Grub (Pes 3)\nSysctl (Pes 3)\nUdev \"i bad usbs\"\n\n\nMonitoritzaci\u00f3 de xarxa:\nInspecci\u00f3 en brut del tr\u00e0fic de xarxa i generaci\u00f3 d'alertes\nBreu descripci\u00f3 del protocol TCP\nWireshark(Pes 4)\nNIDS Snort/Suricata (Pes 4)\nConstructor de paquets Scapy\n\n\nRecol.lectors d'informaci\u00f3 estad\u00edstica sobre el tr\u00e0fic de xarxa\nEines TSBD\nNetflow i IPFIX\nMonitoritzaci\u00f3 d'ample de banda amb Cacti (Pes 4) PENDENT\n\n\nHardering de xarxa i servidors:\nTallafocs\nTallafocs Netfilter (NFTables) (Pes 5)\nTallafocs Firewalld\n\n\nVulnerabilitats\nIntroducci\u00f3 a les vulnerabilitats (web)\nDetector de vulnerabilitats OpenVAS (Pes 4)PENDENT\nDetector de vulnerabilitat Nmap (Pes 4)\nDetector de vulnerabilitats ZAP\n\n\nCriptografia pr\u00e0ctica amb OpenSSL\nConceptes de criptografia (Pes 5)\nXuleta comandes OpenSSL(Pes 5)PENDENT\n\n\nSecuritzaci\u00f3 d'un servidor Apache\nImplementaci\u00f3 servidor Apache segur (HTTPS)(Pes 4)\nDNSSEC\nNFS i CIFS segurs\nVPNs amb OpenVPN i IPSec\n\n\nLlibres:\nLlibre PacktPub",
            "title": "Home"
        },
        {
            "location": "/LPIC3/#material-curs-lpic-3-303",
            "text": "",
            "title": "Material curs LPIC 3-303"
        },
        {
            "location": "/LPIC3/#enlaces-sobre-los-examenes",
            "text": "Resumen de las certificaciones  Resumen de la certificaci\u00f3n LPIC-3 (303)  Lo que hace falta saber para superar el examen 303",
            "title": "Enlaces sobre los ex\u00e1menes:"
        },
        {
            "location": "/LPIC3/#recursos-para-descargar",
            "text": "M\u00e0quina servidora LDAP+Kerberos+NFS4 ja funcional  M\u00e0quina client SSSD ja funcional  Arxiu ldif amb usuaris de mostra",
            "title": "Recursos para descargar:"
        },
        {
            "location": "/LPIC3/#documentos-del-curso",
            "text": "1.Previos \uf0c1   Comandos b\u00e1sicos de red en Linux  Teoria b\u00e1sica sobre LDAP (i NSS)  Teoria b\u00e1sica sobre NFS  Gesti\u00f3 b\u00e1sica de m\u00f2duls del kernel  Journald i journalctl  Systemd  Breu descripci\u00f3 de /proc i de /sys  Comanda Jq (per l'eve.json de Suricata, Beats de l'ELK, etc)  D-Bus (IPC per Firewalld, Systemd,...)  Servidor Apache (HTTP)   Autenticaci\u00f3-Autoritzaci\u00f3: \uf0c1   Introducci\u00f3n  Autenticaci\u00f3n vs Autorizaci\u00f3n  Hashes i endevinaci\u00f3 de contrasenyes. Keyloggers   M\u00f3dulos PAM \uf0c1   PAM i m\u00f2duls interessants (pam_limit, pam_pwquality, etc) (Pes 3)  Client Kerberos+LDAP i FreeIPA (NSS+PAM+SSSD)  Instal.laci\u00f3 servidor 389DS  Administraci\u00f3 b\u00e1sica d'un directori 389DS  Autenticaci\u00f3 i identificaci\u00f3 contra servidor 389DS fent servir SSSD(Pes 5)  Instal.laci\u00f3 i configuraci\u00f3 d'un servidor MIT Kerberos i cooperaci\u00f3 amb servidors LDAP i NFS(Pes 5)PENDENT NFS  FreeIPA (client, servidor i r\u00e8plica)(Pes 4)PENDENT   Frameworks d'autoritzaci\u00f3 \uf0c1   Su i sudo  Polkit   ACLs, Capabilities y atributos extendidos \uf0c1   Bits suid,sgid,sticky  Capabilities i atributs extesos(Pes 3)  ACLs(Pes 3)   SELinux \uf0c1   SELinux(Pes 4)   RADIUS\nRADIUS(Pes 4)  Chroot i altres \"bitxos\": namespaces, cgroups, OS/App containers\nIntro contenidors(Pes 3)PENDENT\nExemple pr\u00e0ctic: contenidors mkosi/machinectl(Pes 3)  Monitoritzaci\u00f3 local:\nCaptura de crides al sistema (i altres events)\nStrace, Ltrace i llibreries\nSysdig i Falco\nAudit(Pes 4)\nAltres FIMs\nELK (amb Falco i Audit)  Detectors de rootkits i malware\nLynis, OpenSCAP, Rkhunter, Maldet, Aide (Pes 4)\nAnsible (com a m\u00e8tode per aplicar de forma autom\u00e0tica els canvis de configuraci\u00f3 suggerits pels programes anteriors)\nHoneypots (com a m\u00e8tode de captura i estudi de malware)\nMetasploit (eina per crear \"malware\" ad-hoc i introduir-lo a v\u00edctimes fent servir algun exploit)\nYara (eina per crear definicions pr\u00f2pies de detecci\u00f3 de malware) PENDENT  Hardering local:\nEncriptaci\u00f3 de disc amb LUKS i de sistemes de fitxers amb Ecryptfs (Pes 3)\nEncriptaci\u00f3 de fitxers amb GPG\nContrasenyes arranc al gestor Grub (Pes 3)\nSysctl (Pes 3)\nUdev \"i bad usbs\"  Monitoritzaci\u00f3 de xarxa:\nInspecci\u00f3 en brut del tr\u00e0fic de xarxa i generaci\u00f3 d'alertes\nBreu descripci\u00f3 del protocol TCP\nWireshark(Pes 4)\nNIDS Snort/Suricata (Pes 4)\nConstructor de paquets Scapy  Recol.lectors d'informaci\u00f3 estad\u00edstica sobre el tr\u00e0fic de xarxa\nEines TSBD\nNetflow i IPFIX\nMonitoritzaci\u00f3 d'ample de banda amb Cacti (Pes 4) PENDENT  Hardering de xarxa i servidors:\nTallafocs\nTallafocs Netfilter (NFTables) (Pes 5)\nTallafocs Firewalld  Vulnerabilitats\nIntroducci\u00f3 a les vulnerabilitats (web)\nDetector de vulnerabilitats OpenVAS (Pes 4)PENDENT\nDetector de vulnerabilitat Nmap (Pes 4)\nDetector de vulnerabilitats ZAP  Criptografia pr\u00e0ctica amb OpenSSL\nConceptes de criptografia (Pes 5)\nXuleta comandes OpenSSL(Pes 5)PENDENT  Securitzaci\u00f3 d'un servidor Apache\nImplementaci\u00f3 servidor Apache segur (HTTPS)(Pes 4)\nDNSSEC\nNFS i CIFS segurs\nVPNs amb OpenVPN i IPSec  Llibres:\nLlibre PacktPub",
            "title": "Documentos del curso"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/",
            "text": "Comandos b\u00e1sicos de red en Linux\n\uf0c1\n\n\nNomenclatura de tarjetas de red\n\uf0c1\n\n\nLas tarjetas de red en sistemas Linux se pueden llamar de las siguientes maneras:\n\n\n\n\nlo\n: Corresponde a la tarjeta \"loopback\". Recordemos que hemos dicho que esta tarjeta f\u00edsicamente no existe (es un \"invento\" del sistema operativo) y suele tener siempre tiene la IP 127.0.0.1/8. Sirve para establecer una conexi\u00f3n con s\u00ed misma, de tal forma que podemos tener en la misma m\u00e1quina un programa cliente que conecte a un programa servidor sin salir \"fuera\".\n\n\neno1, eno2\n: Tarjetas Ethernet integradas en la placa base ( \"on-board\")\n\n\nens1, ens2\n: Tarjetas Ethernet PCI ( \"slot\")\n\n\nenp2s0, p3p1\n: Tarjetas Ethernet que no se pueden localizar de otra forma debido a limitaciones de la BIOS\n\n\nwlp2s0\n:tarjetas WiFi\n\n\n\n\nDentro de las m\u00e1quinas virtuales de VirtualBox las tarjetas de red cogen siempre un nombre concreto: la tarjeta correspondiente a la primera pesta\u00f1a del cuadro de configuraci\u00f3n de red se llamar\u00e1 \"enp0s3\" dentro del sistema virtualizado, la segunda \"enp0s8\", la tercera \"enp0s9\" y la cuarta \"enp0s10\".\n\n\nVer la configuraci\u00f3n actual\n\uf0c1\n\n\nEstado y configuraci\u00f3n de las tarjetas detectadas\n\uf0c1\n\n\nEl comando \nip address show\n (o bien \nip address show dev nomTarjeta\n si s\u00f3lo se quiere obtener la informaci\u00f3n de una tarjeta determinada) nos muestra:\n\n\n\n\nLas direcciones MAC de las tarjetas\n\n\nSu estado respectivo (UP, DOWN)\n\n\nSus direcciones IP respectivas (y la m\u00e1scara correspondiente)\n\n\nOtros datos (como si permite el env\u00edo \"broadcast\", si est\u00e1 en modo \"promiscuo\", etc).\n\n\n\n\n\n\nNOTA\n\n\nEl comando \nip address show\n se puede escribir de forma m\u00e1s corta as\u00ed: \nip a s\n. Incluso, se puede dejar de escribir el verbo show (o s) porque es la acci\u00f3n por defecto (por lo tanto, se puede hacer \nip address\n o \nip a\n y ser\u00eda lo mismo). Tambi\u00e9n es \u00fatil el par\u00e1metro -c (as\u00ed: \nip -c a s\n) para ver los datos m\u00e1s relevantes en colores.\n\n\n\n\nPara activar / desactivar una tarjeta: ip link set {up|down} dev nomTarjeta\n\n\nPuerta de enlace\n\uf0c1\n\n\nEl comando \nip route show\n (o bien \nip route show dev nomTarjeta\n o sus variantes \nip route\n, \nip r s\n o \nip r\n) debe mostrar una l\u00ednea que comenzar\u00e1 con la expresi\u00f3n \n\"default v\u00eda\"\n seguida de la direcci\u00f3n IP de la puerta de enlace establecida. \nEste comando puede mostrar m\u00e1s l\u00edneas, pero no nos interesar\u00e1n mucho ... (quiz\u00e1s la m\u00e1s curiosa es una que sirve para indicar que no hay ninguna puerta de enlace para comunicarse con las m\u00e1quinas que pertenezcan a la misma red a la que pertenece nuestra m\u00e1quina).\n\n\nDNS\n\uf0c1\n\n\nPara saber la direcci\u00f3n IP del servidor DNS configurado en nuestra m\u00e1quina (o las IPs \u2026 si hay m\u00e1s de una se prueba conectar a la primera y si esta falla entonces se prueba la segunda, y as\u00ed) se puede consultar el archivo \netc/resolv.conf\n (concretamente, las l\u00edneas que comienzan por la palabra nameserver). Estos servidores ser\u00e1n los que todas las aplicaciones del sistema (desde el ping hasta el navegador) utilizar\u00e1n para averiguar cu\u00e1l es la IP del nombre que el usuario haya escrito.\n\n\nEl contenido de este archivo suele ser gestionado por diferentes programas (como puede ser el cliente \ndhclient\n, la aplicaci\u00f3n \nNetworkManager\n, el servicio \nnetworking\n, el servicio \nsystemd-networkd/resolved\n, etc) y es por ello que no se recomienda modificarlo manualmente ya que los cambios realizados a mano podr\u00edan \u00abMachacar\u00bb sin avisar en cualquier momento por cualquiera de estos programas.\n\n\nEn este sentido, estos programas (\ndhclient, NetworkManager, \u00abnetworking\u00bb, \u00absystemd-networkd / resolved, etc\n) guardan los servidores DNS que usan dentro de sus propios archivos de configuraci\u00f3n y los manipulan all\u00ed de forma aut\u00f3noma (por ejemplo NetworkManager usa /var/run/NetworkManager/resolv.conf, \u00absystemd-resolved\u00bb usa /run/systemd/resolve/resolv.conf, \u00abNetworking\u00bb usa la l\u00ednea dns-nameservers dentro de /etc/network/interfaces, etc) pero adem\u00e1s siempre vinculan en forma de enlace simb\u00f3lico su archivo propio respectivo al archivo com\u00fan /etc/resolv.conf para que los programas que utilicen este archivo com\u00fan no tengan problemas en encontrar los servidores DNS.\n\n\nEstablecer una configuraci\u00f3n de red est\u00e1tica de forma temporal\n\uf0c1\n\n\n\n\n\n\nPara asignar una IP / m\u00e1scara concreta a una tarjeta: \n\nip address add v.x.y.z/n dev nomTarjeta\n\n\n\n\n\n\nPara borrar una IP / m\u00e1scara concreta de una tarjeta: \nip address del v.x.y.z / n dev nomTarjeta\n\n\n\n\n\n\n\n\nNOTA\n\n\nTambi\u00e9n se puede hacer \nip address flush dev nomTarjeta\n si lo que se quiere es borrar de golpe cualesquiera de las eventuales diferentes direcciones IP que pueda tener la tarjeta indicada\n\n\n\n\nPara asignar la puerta de enlace concreta a una tarjeta: \nip route add default v\u00eda v.x.y.z dev nomTarjeta\n. Antes, sin embargo, deber\u00eda borrar la que hab\u00eda asignada antes (si no se hace da error), as\u00ed: \nip route del default dev nomTarjeta\n.\n\n\n\n\nNOTA\n\n\nTambi\u00e9n se puede escribir \nip route add 0.0.0.0/0 v\u00eda v.x.y.z dev nomTarjeta\n. Es equivalente.\n\n\n\n\n\n\nNOTA\n\n\nDe forma alternativa, en vez de hacer \nip route del \u2026\n y despu\u00e9s \nip route add \u2026\n, el cambio de puerta de enlace predeterminada se podr\u00eda hacer directamente en un solo paso, as\u00ed: \nip route change default v\u00eda v.x.y.z dev nomTarjeta\n\n\n\n\n\n\nNOTA\n\n\nTambi\u00e9n se puede indicar que se quiere utilizar una determinada puerta de enlace s\u00f3lo para llegar a una red-destino concreta. En este caso, entonces, no estar\u00edamos hablando de puerta de enlace \u00abpor defecto\u00bb sino de una puerta de enlace \u00abespec\u00edfica\u00bb. La puerta de enlace \u00abpor defecto\u00bb ser\u00eda usada una vez que el sistema hubiera comprobado que el destino deseado no forma parte del conjunto de destinos indicados en puertas de enlace espec\u00edficas. Para crear una puerta de enlace espec\u00edfica hay que ejecutar el comando \nip route add ip.red.Destino/Mascara v\u00eda v.x.y.z dev nomTarjeta\n Se puede a\u00f1adir adem\u00e1s un \u00faltimo par\u00e1metro metric n, que indica la preferencia de la ruta en el caso de que hubieran varias que llevaran al mismo destino (a modo de \u00abbackup\u00bb): un n menor indica una mayor preferencia.\n\n\n\n\n\n\nNOTA\n\n\nUna vez asignada una direcci\u00f3n IP a una tarjeta, el sistema calcula autom\u00e1ticamente su direcci\u00f3n IP de red correspondiente y genera una ruta a ella (es por eso que es necesario indicar la m\u00e1scara en ip address add \u2026)\nPor ejemplo, si se asigna la IP 203.0.113.25/24 a la tarjeta enp0s3, se crear\u00e1 autom\u00e1ticamente una ruta en la red 203.0.113.0/24 directa, por lo que el sistema sabr\u00e1 que para comunicarse con hosts de esta red no necesitar\u00e1 ninguna puerta de enlace intermediaria sino que lo podr\u00e1 hacer directamente.\n\n\n\n\nEstablecer una configuraci\u00f3n est\u00e1tica de forma permanente (en sistemas Debian cl\u00e1sicos)\n\uf0c1\n\n\nTodos los comandos anteriores, sin embargo, s\u00f3lo \u00abfuncionan\u00bb mientras la m\u00e1quina se mantiene encendida: si apaga entonces las direcciones IP / m\u00e1scaras y puertas de enlace configuradas con las \u00f3rdenes \u00abip\u00bb anteriores se pierden y hay, pues, que volver a ejecutarlas de nuevo en el siguiente inicio.\n\n\nPara que la configuraci\u00f3n deseada de IP / m\u00e1scara y puerta de enlace (y servidor DNS tambi\u00e9n, gestionado con alguno de los programas comentados en p\u00e1rrafos anteriores) para una determinada tarjeta de red se mantenga de forma permanente en cada reinicio de la m\u00e1quina, hay que escribir los valores adecuados en un determinado archivo. En sistemas Debian/Ubuntu, este archivo se denomina /etc/network/interfaces y debe tener un aspecto similar al siguiente (las l\u00edneas que comienzan por # son comentarios, las tabulaciones son opcionales):\n\n\n# Las l\u00edneas \"auto\" sirven para activar la tarjeta en cuesti\u00f3n (en este #caso la tarjeta \"lo\")\nauto lo\n# La l\u00ednea siguiente indica que la tarjeta \"lo\" es de \n# tipo \"loopback\" (y que, por tanto, tendr\u00e1 la IP 127.0.0.1)\niface lo inet loopback\n# En el mismo archivo se pueden configurar todas las tarjetas que \n# se quieran: la siguiente se llama enp3s0\nauto enp3s0\n# La palabra \"static\" indica que los valores de IP, m\u00e1scara, etc \n# son fijos en cada reinicio\niface enp3s0 inet static\n# A continuaci\u00f3n se indican los valores de IP, m\u00e1scara, puerta de \n# enlace y servidores DNS que se quieren asignar\naddress v.x.y.z\nnetmask w.w.w.w\ngateway v.x.y.z\ndns-nameservers v.x.y.z v.x.y.z\n\n\n\n\n\n\nAtenci\u00f3n\n\n\nAtenci\u00f3n, la l\u00ednea \u00ab\ndns-nameservers\n\u00bb del archivo anterior s\u00f3lo funciona (es decir, se copian los servidores DNS indicados all\u00ed en el archivo central del sistema donde deben estar para ser utilizados: /etc/resolv.conf) si hay instalado un paquete llamado \u00ab\nresolvconf\n\u00bb. Si no lo est\u00e1, estas l\u00edneas no se  tendr\u00e1n en cuenta.\n\n\n\n\nEste archivo es le\u00eddo por un servicio del sistema (un demonio) que se pone en marcha autom\u00e1ticamente al arrancar la m\u00e1quina y que se denomina \u00abnetworking\u00bb. Esto quiere decir que en cualquier momento que hagamos un cambio dentro de este archivo, para que se tenga en cuenta o bien habr\u00e1 que reiniciar la m\u00e1quina o bien simplemente reiniciar el servicio, as\u00ed: \nsudo systemctl restart networking\n\n\nEstablecer una configuraci\u00f3n est\u00e1tica de forma permanente (en sistemas systemd)\n\uf0c1\n\n\n\u00abSystemd-networkd\u00bb\n es un demonio que gestiona las configuraciones de las diferentes interfaces de red (f\u00edsicas y / o virtuales) de un sistema systemd, representando, pues, una alternativa al demonio \u00abNetworking\u00bb de sistemas Debian as\u00ed como tambi\u00e9n al scripts ifcfg- * cl\u00e1sicos de Fedora / Suse o al Network Manager integrado en muchos escritorios.\n\n\nPara empezar a utilizar este demonio es recomendable detener primero la \u00abcompetencia\u00bb, por ejemplo, en el caso de Ubuntu ejecutando\n\n\nsudo sytemctl disable networking && sudo systemctl stop networking)\n\n\nY entonces encenderlo junto con el servicio \u00absystemd-resolved\u00bb, as\u00ed, por ejemplo:\n\n\n\n\nNote\n\n\nAl igual que ocurr\u00eda con el paquete \u00abresolvconf\u00bb en los sistemas Debian, se necesita tener un servicio adicional instalado (y funcionando) en el sistema llamado \u00absystemd-resolved\u00bb si se quieren especificar entradas DNS expl\u00edcitas en los archivos .network (o bien si se obtienen v\u00eda DHCP). Este servicio lo que hace es, a partir de estas entradas, modificar el archivo /run/systemd/resolve/resolv.conf, el cual, por compatibilidad con muchos programas tradicionales, deber\u00eda apuntar en forma de enlace suave en /etc/resolv.conf (ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf). Alternativamente, se puede no utilizar systemd-resolved y modificar entonces el archivo /etc/resolv.conf a mano.\n\n\n\n\nSe pueden ver el nombre (y tipo y estado) de las interfaces de red actualmente reconocidas en el sistema (y su tipo y estado) mediante el comando \nnetworkctl list\n. Si en la columna SETUP aparece \u00abunmanaged\u00bb significa que esta interfaz concreta no es gestionada por systemd-networkd sino por alg\u00fan otro servicio alternativo. Otra orden que da m\u00e1s informaci\u00f3n es \nnetworkctl status\n. En cualquier caso, para hacer que se gestione por systemd-networkd, por cada interfaz hay que crear un archivo * .network dentro de la carpeta /etc/systemd/network (y reiniciar el servicio). En el caso concreto de querer asignar una IP est\u00e1tica, ser\u00eda necesario, pues, tener un archivo como este (llamado por ejemplo \u00ab/etc/systemd/network/lalala.network \u00ab):\n\n\n[Match]\nName=enp1s0\n#Identifica la tarjeta a la cual se le aplicar\u00e1 la configuraci\u00f3n\n[Network]\nDHCP=no\nAddress=10.1.10.9/24\nGateway=10.1.10.1\nDNS=10.1.10.2 #Opcional (Es necesario tener el servicio systemd-resolved funcionando)\nDNS=10.1.10.3 #Cada servidor DNS ha d'indicar-se en una l\u00ednia separada\n\n\n\n\nLos archivos de configuraci\u00f3n de systemd-networkd proporcionados por la distribuci\u00f3n se encuentran en \n/usr/lib/systemd/network\n y los administrados por nosotros se tienen que ubicar en \n/etc/systemd/network\n. Todos estos archivos se leen -sin distinci\u00f3n de donde est\u00e9n ubicados \u2013 en orden alfanum\u00e9rico seg\u00fan el nombre que tienen, ganando siempre la primera configuraci\u00f3n encontrada en caso de que afectara a la misma tarjeta. Eso s\u00ed, si en las dos carpetas se encuentra un fichero con el mismo nombre, lo que hay bajo \n/etc/systemd/network\n anula siempre a lo que hay en \n/usr/lib/systemd/network\n (una consecuencia de esto es que si el archivo en /etc/\u2026 apunta a /dev/null, lo que se estar\u00e1 haciendo es deshabilitar.\n\n\nExisten tres tipos diferentes de archivos de configuraci\u00f3n:\n\n\n\n\nlos \n\u00ab.network\u00bb\n aplican la configuraci\u00f3n descrita bajo su secci\u00f3n [Network] a aquellas tarjetas de red que tengan una caracter\u00edstica que concuerde con todos los valores indicados en las diferentes l\u00edneas bajo la secci\u00f3n [Match] (normalmente aqu\u00ed s\u00f3lo indica su nombre mediante una \u00fanica l\u00ednea \u00abName =\u00bb)\n\n\nlos \n\u00ab.netdev\u00bb\n sirven para crear nuevas interfaces de red de tipo virtual ( \u00abbridges\u00bb, \u00abbonds\u00bb, etc) -la configuraci\u00f3n de red se seguir\u00e1 indicando en su correspondiente archivo .network)\n\n\nlos \n\u00ab.link\u00bb\n sirven para definir nombres alternativos a las tarjetas de red en el momento de ser reconocidas por el sistema (v\u00eda systemd-udev).\n\n\n\n\nEn las l\u00edneas bajo la secci\u00f3n [Match] -por ejemplo, en \u00abName =\u00bb, se puede utilizar el comod\u00edn *. En esta l\u00ednea en concreto tambi\u00e9n se puede escribir un conjunto de nombres separados por un espacio en blanco a modo de diferentes alternativas.\n\n\nEn los archivos .network puede haber una secci\u00f3n (no vista en los ejemplos anteriores) titulada [Link] bajo la que pueden haber varias l\u00edneas m\u00e1s relacionadas con el comportamiento \u00abhardware\u00bb de la tarjeta, como la l\u00ednea \u00abMACAddress = xx: xx: xx: xx: xx: xx\u00bb, la cual sirve para asignar a la tarjeta en cuesti\u00f3n una direcci\u00f3n MAC ficticia, la l\u00ednea \u00abMTUBytes = no\u00bb, la cual sirve para indicar el tama\u00f1o de la MTU admitida (\u00fatil por ejemplo para activar los \u00abjumbo frames\u00bb si se pone 9000 como valor), o la l\u00ednea \u00abARP = no\u00bb para desactivar el protocolo ARP en la tarjeta en cuesti\u00f3n (activado por defecto).\n\n\nLos archivos .netdev suelen tener s\u00f3lo una secci\u00f3n titulada [netdev], la cual debe incluir dos l\u00edneas obligatoriamente: \u00abName =\u00bb (por asignar un nombre a la interfaz virtual que se crear\u00e1) y \u00abKind =\u00bb (para especificar el tipo de interfaz que ser\u00e1: \u00abbridge\u00bb, \u00abbond\u00bb, \u00abVlan\u00bb, \u00abveth\u00bb, etc). En el caso de que sea de tipo \u00abvlan\u00bb, aparecer\u00e1 entonces una secci\u00f3n titulada [VLAN] incluyendo como m\u00ednimo la l\u00ednea \u00abId =\u00bb para indicar el n\u00famero de VLAN que se est\u00e1 creando.\n\n\nLos archivos .link suelen tener una secci\u00f3n [Match] con la l\u00ednea \u00abMACAddress =\u00bb para identificar la tarjeta de red en cuesti\u00f3n y una secci\u00f3n\n[Link] que sirve para manipular las caracter\u00edsticas de esta tarjeta, como por ejemplo su nombre (con la l\u00ednea \u00abName =\u00bb y, opcionalmente, la l\u00ednea \u00abDescription =\u00bb). Si no se crea manualmente ning\u00fan archivo .link, la mayor\u00eda de distribuciones ofrecen un archivo .link predeterminado, generalmente llamado 99-default.link (y ubicado en / usr / lib / systemd / network); es por ello que hay que asegurarse que los ficheros .link \u00abmanuales\u00bb tengan un nombre que asegure su lectura antes de la del archivo 99-default.link.\n\n\nPara m\u00e1s informaci\u00f3n sobre las posibilidades que ofrecen todos estos archivos, consultar las p\u00e1ginas del manual \u00absystemd.network\u00bb, \u00abSystemd.netdev\u00bb y \u00absystemd.link\u00bb.\n\n\n\n\nAtenci\u00f3n\n\n\nNo s\u00f3lo existen el servicio \u00abnetworking\u00bb y \u00absystemd-networkd\u00bb para gestionar las tarjetas de red de nuestro sistema. Tambi\u00e9n podemos encontrar el servicio \u00abNetworkManager\u00bb (sobre todo en sistemas con escritorio) y en las \u00faltimas versiones de Ubuntu el servicio \u00abNetplan\u00bb, entre otros. !!!\n\n\n\n\nEstablecer una configuraci\u00f3n din\u00e1mica de forma temporal\n\uf0c1\n\n\nEn las configuraciones anteriores, tanto la temporal como la permanente, se establece una direcci\u00f3n IP / m\u00e1scara + puerta de enlace concreta, decidida por nosotros. Este m\u00e9todo puede ser \u00fatil para pocas m\u00e1quinas, pero en una red con muchos equipos, puede llegar a ser bastante farragoso, adem\u00e1s de que f\u00e1cilmente se pueden cometer errores (IPs duplicadas, IP no asignadas).\n\n\nOtro m\u00e9todo para establecer estos datos es el m\u00e9todo \u00abdin\u00e1mico\u00bb, en el que la m\u00e1quina en cuesti\u00f3n no tiene asignada de forma fija IP / m\u00e1scara + puerta de enlace + servidor DNS sino que estos datos los obtiene de la red: all\u00ed deber\u00e1 haber escuchando un ordenador ejecutando un software especial llamado \u00abServidor DHCP\u00bb, el cual sirve precisamente para atender estas peticiones de \u00abdatos de red\u00bb y asignarlas a quien las pida. De este modo, se tiene una gesti\u00f3n centralizada del reparto de direcciones IP / m\u00e1scara + puerta de enlace + servidores DNS sin necesidad de realizar ninguna configuraci\u00f3n espec\u00edfica en las m\u00e1quinas clientes. Eso s\u00ed, claro: primero se deber\u00e1 haber instalado y configurado convenientemente en nuestra red este software \u00abservidor DHCP\u00bb (un ejemplo es el paquete \u00abisc-dhcp-server \u00ab), tarea que no veremos (se presupone que esto ya est\u00e1 hecho).\n\n\n\n\nNota\n\n\nOtro cliente similar es el comando host nomDNS [ip.serv.DNS]\n\n\n\n\nPara pedir en un momento determinado una configuraci\u00f3n completa de red (IP, m\u00e1scara, puerta de enlace, servidores DNS, etc) a un servidor DHCP ya funcionando en nuestra LAN hemos de ejecutar un cliente DHCP, como el comando \ndhclient\n\n\nDhclient nomTarjeta\n Pide -para la tarjeta indicada- los datos de red (IP, m\u00e1scara, puerta de enlace, servidor DNS, etc) a alg\u00fan servidor DHCP que est\u00e9 escuchando a la LAN de nuestra m\u00e1quina.\n\n\n-v Muestra por pantalla todo el proceso de petici\u00f3n y respuesta (\u00fatil para ver si va)\n\n\n-r Borra todos los datos de red que pueda tener actualmente la tarjeta indicada\n\n\nEstablecer una configuraci\u00f3n din\u00e1mica de forma permanente\n\uf0c1\n\n\nEn sistemas Debian cl\u00e1sicos\n\uf0c1\n\n\nPara pedir los datos de red a alg\u00fan servidor DHCP de nuestra red, en vez\nde tener que hacerlo manualmente con el comando \ndhclient\n, se puede hacer de forma autom\u00e1tica cada vez que nuestra m\u00e1quina arranque (de modo que nosotros no tengamos que hacer nada y ya tengamos, si todo va bien, estos datos ya asignadas una vez iniciamos sesi\u00f3n). Esto se logra simplemente escribiendo las siguientes l\u00edneas en el archivo /etc/network/interfaces:\n\n\nauto enp3s0\niface enp3s0 inet dhcp\n\n\n\n\nEn sistemas systemd\n\uf0c1\n\n\nEn el caso concreto de querer asignar una IP din\u00e1mica en un sistema con el demonio systemd-netword funcionando, habr\u00e1 que tener un archivo como este (llamado por ejemplo \u00ab/Etc/systemd/network/lalala.network\u00bb):\n\n\n[Match]\nName = enp1s0\n[Network]\nDHCP = yes # Tambi\u00e9n podr\u00eda valer ipv4 o ipv6 seg\u00fan el tipo de direcciones IP que queremos recibir\n\n\n\n\nping\n\uf0c1\n\n\nping ip o Nombre Maq. Remota\n \n\n\nComprueba si la m\u00e1quina remota indicada responde. Sirve, por tanto, para saber si hay conexi\u00f3n de red con aquella m\u00e1quina (si no, podr\u00eda ser debido a cualquier causa: cable mal enchufado o roto, m\u00e1quina remota apagada, etc). En este sentido, son interesantes los datos estad\u00edsticos que aparecen al final (paquetes enviados, recibidos, perdidos, etc) y el tiempo que han tardado en enviarse estos paquetes de prueba (y recibirse la respuesta) -y as\u00ed comprobar la saturaci\u00f3n del medio.\n\n\n-n No resuelve nombres (es decir, no hace la consulta previa en el servidor DNS del sistema). Por lo tanto, s\u00f3lo hace que funcione indicando direcciones IP\n\n\n-c n\u00ba N\u00famero de paquetes de prueba que se enviar\u00e1n (si no se indica, son infinitos y hay que detener el env\u00edo pulsando CTRL + C)\n\n\n-i n\u00baN\u00famero de segundos que se espera para enviar el siguiente paquete\n\n\n-f Mode \u00abflood\u00bb. Env\u00eda paquetes a la m\u00e1xima velocidad posible, mostrando un punto por cada paquete enviado y borr\u00e1ndose el por cada respuesta recibida: por lo tanto, para ir bien habr\u00eda que s\u00f3lo se viera un punto y fuera desapareciendo: si se ven muchos puntos es que hay p\u00e9rdida de paquetes. Hay que ser root para que funcione\n\n\n-I eno1 Indica la tarjeta de red para la que se enviar\u00e1n los paquetes (por si la m\u00e1quina tuviera m\u00e1s de una)\n\n\nmtr\n\uf0c1\n\n\nmtr ip.o Nom.Maq.Remota\n\n\nSirve para conocer el camino seguido por un paquete desde la m\u00e1quina origen hasta la indicada, mostrando la IP (o nombre) de todos los routers\nintermedios a trav\u00e9s de los que va pasando. tambi\u00e9n muestra estad\u00edsticas de tiempo empleado en cada paquete, el mejor tiempo, el peor, los paquetes perdidos, etc\n\n\n-n No resuelve nombres (es decir, no hace la consulta previa en el servidor DNS del sistema).\n\n\n-c n\u00ba N\u00famero de paquetes de prueba que se enviar\u00e1n (si no se indica, son infinitos y hay que parar el env\u00edo pulsando CTRL + C)\n\n\n-i n\u00ba N\u00famero de segundos que se espera para enviar el siguiente paquete\n\n\nss\n\uf0c1\n\n\nMuestra datos sobre las conexiones existentes (o que pueden existir) en\nnuestra m\u00e1quina. Concretamente, muestra el estado de la conexi\u00f3n (los m\u00e1s habituales son ESTABLISHED y LISTEN -este \u00faltimo indica que el\npuerto est\u00e1 abierto pero sin conexi\u00f3n -\u2026 otros estados a menudo son\ntemporales y terminan derivando en una conexi\u00f3n establecida o bien\ndesapareciendo), muestra la IP y el puerto local utilizados para establecer la conexi\u00f3n (o para escuchar, segundos) y la IP y puerto remoto donde la\ncorrespondiente IP + puerto local est\u00e1n conectados.\n\n\nNOTA: Otro cliente similar es el comando \nhost nomDNS [ip.serv.DNS]\n\n\n-t Mostrar s\u00f3lo las conexiones TCP actuales\n\n\n-u Mostrar s\u00f3lo las conexiones UDP actuales\n\n\n-n No resuelve nombres (es decir: muestra IPs y puertos en formato num\u00e9rico en lugar de con nombres)\n\n\n-a (Combinado con -t y/o -u): Muestra, adem\u00e1s de las conexiones actuales, los puertos a la escucha\n\n\n-l (Combinado con -t y / o -u): Muestra s\u00f3lo los puertos a la escucha (las conexiones actuales no)\n\n\n-p (Combinado con -t y / o -u): Muestra 1 columna m\u00e1s: el ejecutable \u00abdetr\u00e1s\u00bb de cada puerto local\n\n\n\u2013s Muestra un resumen con estad\u00edsticas\n\n\nncat\n\uf0c1\n\n\nncat ip.oNom.Maq.Remota noport\n\n\nCliente Netcat que viene dentro del paquete \u00abnmap\u00bb: realiza una\nconexi\u00f3n (TCP) en la m\u00e1quina y puerto indicado. Se puede a\u00f1adir el\npar\u00e1metro -v (modo verboso) y -n (no resuelve nombres), entre otros.\n\n\n-v Modo verboso (-vv es m\u00e1s verboso y -vvv m\u00e1s a\u00fan)\n\n\nncat -l -k -p n\u00ba\n Servidor Netcat: pone a la escucha el n\u00ba de puerto (TCP) indicado. el argumento -l sirve para \u00ababrir\u00bb el puerto, el par\u00e1metro -p sirve para indicar el n\u00famero de puerto a abrir y el par\u00e1metro -k permite que se puedan conectar m\u00e1s de un cliente a la vez.\n\n\n-e /ruta/comando Todo lo que se reciba de la red ser\u00e1 pasado al comando indicado, la salida ser\u00e1 devuelta al cliente. Si el comando indicado fuera\n/Bin/bash, la entrada se entender\u00e1 como un comando a ejecutar (y la\nsalida ser\u00e1 la salida del comando ejecutado).\nExemples Ncat\n\n\nChat\n \n\n\nServidor: \nncat -l -p 5588\n <\u2014> Cliente: \nncat ipServidor 5588\n\n\nEl servidor se pone a escuchar en el puerto 5588 (por defecto siempre es TCP), con lo que todo lo que le llegue de la red -es decir, del cliente-lo pasar\u00e1 a la stdout (pantalla), y todo lo que escriba por stdin (teclado) pasar\u00e1 a la red -es decir, hacia el cliente-. Lo mismo ocurre en el otro lado de la comunicaci\u00f3n. Si se a\u00f1ade el par\u00e1metro -k al servidor, m\u00faltiples clientes podr\u00e1n enviar mensajes al servidor y este, lo que env\u00ede, lo enviar\u00e1 a todos sin discriminaci\u00f3n\n\n\nEnv\u00edo de un archivo\n\n\nServidor: \nncat -l -p 5555 < archivo\n <-> Cliente: \nncat ipServidor 5555 > archivo\n\n\nMuy similar a lo anterior: el servidor se pone a escuchar en el puerto 5555, pero en vez de responder por teclado a la stdin, la entrada proviene de un archivo, el cual esperar\u00e1 latente a que cuando se establezca una comunicaci\u00f3n por ese puerto, su contenido viaje bit a bit por la red hacia el cliente, el cual lo recibir\u00e1 y lo guardar\u00e1 en forma de archivo otra vez. Lo malo es que tal como se ha hecho, no se sabe cu\u00e1ndo se ha acabado la transferencia: hay que esperar un tiempo prudencial y entonces hacer Ctrl+C.\n\n\nReproducci\u00f3n de audio en streaming\n\n\nServidor: \nncat -l -p 5858\n Cliente: \nncat ipServidor 5858 | mpg123 \u2013\n\n\nEl ejemplo es id\u00e9ntico al anterior, teniendo un archivo en este caso de audio. La \u00fanica diferencia es que en el cliente, el archivo no se redirecciona para grabarlo en disco sino que se entuba a un reproductor de audio por consola, como mpg123 (el gui\u00f3n del final es para indicarle que el fichero o lista de reproducci\u00f3n le proviene de la tuber\u00eda).\n\n\nClonaci\u00f3n de discos por red\n\n\nServidor: \nncat -l -p 5678 | dd of=a.iso.gz\n <\u2014->Cliente: \ndd if=/dev/sda | gzip -c | ncat ipServidor 5678\n\n\nEl ejemplo es parecido al anterior: primero en el cliente se comprime bit a bit el contenido del disco \u00absda\u00bb y se le env\u00eda ya comprimido al servidor, el cual recibe este contenido binario y lo almacena en un archivo, bit a bit too.\n\n\nnmap\n\uf0c1\n\n\nnmap -sn { ipInici-ipFinal [altraIP \u2026] | ipConAsteriscos }\n\n\nMuestra qu\u00e9 ordenadores est\u00e1n presentes en la red. existen muchos otros par\u00e1metros de escaneo (-sU, -sX, -sF, etc) que utilizan diferentes t\u00e9cnicas m\u00e1s\no \u2013 r\u00e1pidas / sigilosas / precisas, pero no las veremos.\n\n\n-v Modo verboso (-vv es m\u00e1s verboso y -vvv m\u00e1s a\u00fan)\n\n\n-n No resuelve nombres\n\n\nnmap -p n\u00ba, n\u00ba-n\u00ba ipOrdenador\n Muestra qu\u00e9 puertos (del rango indicado) tiene abiertos un ordenador concreto. Aqu\u00ed tambi\u00e9n se pueden utilizar diferentes t\u00e9cnicas pero tampoco profundizaremos\n\n\n-O Muestra el sistema operativo del ordenador y los programas \u00abdetr\u00e1s\u00bb de los\npuertos abiertos. Se puede combinar con el par\u00e1metro -sV, el cual muestra tambi\u00e9n las versiones. El par\u00e1metro -A es la combinaci\u00f3n de los dos.\n\n\nnslookup\n\uf0c1\n\n\nnslookup nombreDNS [ip.serv.DNS]\n\n\nCliente DNS que pregunta al servidor indicado o, si no se indica ninguno, al que est\u00e9 configurado en \n/etc/resolv.conf\n. Normalmente, adem\u00e1s de devolver la IP (o IPs equivalentes) asociadas al nombre indicado, tambi\u00e9n muestra los \u00abalias\u00bb que tiene este nombre\n\n\n\n\nNOTA\n\n\nOtro cliente similar es el comando \nhost nomDNS [ip.serv.DNS]\n\n\n\n\n\n\nNOTA\n\n\nOtro cliente similar es el comando \ndig [@ip.serv.DNS] nomDNS.\n O \ndrill\n\n\n\n\n\n\nNOTA\n\n\nOtro cliente pero s\u00f3lo compatible con systemd-resolved es \nsystemd-resolve\n\n\n\n\nwhois\n\uf0c1\n\n\nwhois dominioDNS\n\n\nConsulta en los servidores whois publicos (administrados por la IANA) para averiguar el propietario o registrador del dominio\n\n\nwget\n\uf0c1\n\n\nwget https://url/un/archivo\n\n\nDescarga al disco duro el archivo indicado\n\n\n-c Contin\u00faa la descarga (si anteriormente fall\u00f3) desde donde se interrumpi\u00f3\n\n\n-O nombre Indica el nombre que tendr\u00e1 el archivo una vez descargado\n\n\n-r Realiza una descarga recursiva si la URL indicada es la de una carpeta en vez de la de un archivo. Combinado con el par\u00e1metro -l n\u00ba sirve para indicar hasta qu\u00e9 nivel (1 = una subcarpeta, 2 =dos subcarpetas) se quiere descargar \u2026 si no se indica se entiende \u00abinfinito\u00bb\n\n\n-N Descarga s\u00f3lo los archivos m\u00e1s nuevos que los locales\n\n\n-A \u00abext1\u00bb, \u00abext2\u00bb, \u2026 Descarga s\u00f3lo los archivos que encuentre con la extensi\u00f3n indicada El par\u00e1metro contrario (descarga todo excepto los archivos indicados) es -R\n\n\n\u2013no-parent No descarga contenido anterior a la URL indicada\n\n\n-nd Todo lo descarga en la misma carpeta local (sin respetar, pues, la jerarqu\u00eda de carpetas del sitio remoto)\n\n\n-k Una vez hecha la descarga, transforma los enlaces para que todo el contenido se pueda visitar offline (cambia las rutas absolutas para relativas y los recursos no descargados los referencia con la URL completa\n\n\ncurl\n\uf0c1\n\n\ncurl https://url/un/archivo\n\n\nDescargar el fichero indicado y muestra en pantalla su contenido\n\n\n-o nombre Descargar archivo indicado y lo guarda en el disco duro con el nombre que se especifique\n\n\n-O Descargar el fichero indicado y lo guarda en el disco duro con el nombre que tenga el original\n\n\n-C \u2013 Contin\u00faa la descarga desde el no de byte indicado (si es un gui\u00f3n, ser\u00e1 a partir de donde se par\u00f3 la descarga -fallida- anterior del mismo archivo\n\n\n-s Modo \u00absilencioso\u00bb (no muestra ni las estad\u00edsticas de descarga ni los errores, nada)\n\n\n-SS Modo \u00absilencioso\u00bb pero mostrando los mensajes de error\n\n\n-v Modo \u00abverboso\u00bb. Sirve para mostrar las cabeceras de cliente enviadas a la petici\u00f3n\n\n\n-Y No descarga el archivo: s\u00f3lo muestra la cabecera de respuesta HTTP del servidor\n\n\n-y Mostrar en pantalla tanto las cabeceras de respuesta como el contenido del archivo pedido\n\n\n-D nombre Guarda en el disco duro, en forma de archivo con el nombre indica, las cabeceras de respuesta\n\n\n-L Si el servidor web devuelve un c\u00f3digo de redirecci\u00f3n (3xx), lo sigue autom\u00e1ticamente\n\n\n-H \u00abcabecera: valor\u00bb Realiza una petici\u00f3n indicando un valor concreto para la cabecera HTTP de cliente indicada. Se pueden poner m\u00faltiples par\u00e1metros -H.\n\n\n\u2013X tipo Realiza una petici\u00f3n del tipo indicado (POST, PUT, etc). Por defecto son GET",
            "title": "Comandos b\u00e1sicos de red en Linux"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#comandos-basicos-de-red-en-linux",
            "text": "",
            "title": "Comandos b\u00e1sicos de red en Linux"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#nomenclatura-de-tarjetas-de-red",
            "text": "Las tarjetas de red en sistemas Linux se pueden llamar de las siguientes maneras:   lo : Corresponde a la tarjeta \"loopback\". Recordemos que hemos dicho que esta tarjeta f\u00edsicamente no existe (es un \"invento\" del sistema operativo) y suele tener siempre tiene la IP 127.0.0.1/8. Sirve para establecer una conexi\u00f3n con s\u00ed misma, de tal forma que podemos tener en la misma m\u00e1quina un programa cliente que conecte a un programa servidor sin salir \"fuera\".  eno1, eno2 : Tarjetas Ethernet integradas en la placa base ( \"on-board\")  ens1, ens2 : Tarjetas Ethernet PCI ( \"slot\")  enp2s0, p3p1 : Tarjetas Ethernet que no se pueden localizar de otra forma debido a limitaciones de la BIOS  wlp2s0 :tarjetas WiFi   Dentro de las m\u00e1quinas virtuales de VirtualBox las tarjetas de red cogen siempre un nombre concreto: la tarjeta correspondiente a la primera pesta\u00f1a del cuadro de configuraci\u00f3n de red se llamar\u00e1 \"enp0s3\" dentro del sistema virtualizado, la segunda \"enp0s8\", la tercera \"enp0s9\" y la cuarta \"enp0s10\".",
            "title": "Nomenclatura de tarjetas de red"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#ver-la-configuracion-actual",
            "text": "Estado y configuraci\u00f3n de las tarjetas detectadas \uf0c1  El comando  ip address show  (o bien  ip address show dev nomTarjeta  si s\u00f3lo se quiere obtener la informaci\u00f3n de una tarjeta determinada) nos muestra:   Las direcciones MAC de las tarjetas  Su estado respectivo (UP, DOWN)  Sus direcciones IP respectivas (y la m\u00e1scara correspondiente)  Otros datos (como si permite el env\u00edo \"broadcast\", si est\u00e1 en modo \"promiscuo\", etc).    NOTA  El comando  ip address show  se puede escribir de forma m\u00e1s corta as\u00ed:  ip a s . Incluso, se puede dejar de escribir el verbo show (o s) porque es la acci\u00f3n por defecto (por lo tanto, se puede hacer  ip address  o  ip a  y ser\u00eda lo mismo). Tambi\u00e9n es \u00fatil el par\u00e1metro -c (as\u00ed:  ip -c a s ) para ver los datos m\u00e1s relevantes en colores.   Para activar / desactivar una tarjeta: ip link set {up|down} dev nomTarjeta  Puerta de enlace \uf0c1  El comando  ip route show  (o bien  ip route show dev nomTarjeta  o sus variantes  ip route ,  ip r s  o  ip r ) debe mostrar una l\u00ednea que comenzar\u00e1 con la expresi\u00f3n  \"default v\u00eda\"  seguida de la direcci\u00f3n IP de la puerta de enlace establecida. \nEste comando puede mostrar m\u00e1s l\u00edneas, pero no nos interesar\u00e1n mucho ... (quiz\u00e1s la m\u00e1s curiosa es una que sirve para indicar que no hay ninguna puerta de enlace para comunicarse con las m\u00e1quinas que pertenezcan a la misma red a la que pertenece nuestra m\u00e1quina).  DNS \uf0c1  Para saber la direcci\u00f3n IP del servidor DNS configurado en nuestra m\u00e1quina (o las IPs \u2026 si hay m\u00e1s de una se prueba conectar a la primera y si esta falla entonces se prueba la segunda, y as\u00ed) se puede consultar el archivo  etc/resolv.conf  (concretamente, las l\u00edneas que comienzan por la palabra nameserver). Estos servidores ser\u00e1n los que todas las aplicaciones del sistema (desde el ping hasta el navegador) utilizar\u00e1n para averiguar cu\u00e1l es la IP del nombre que el usuario haya escrito.  El contenido de este archivo suele ser gestionado por diferentes programas (como puede ser el cliente  dhclient , la aplicaci\u00f3n  NetworkManager , el servicio  networking , el servicio  systemd-networkd/resolved , etc) y es por ello que no se recomienda modificarlo manualmente ya que los cambios realizados a mano podr\u00edan \u00abMachacar\u00bb sin avisar en cualquier momento por cualquiera de estos programas.  En este sentido, estos programas ( dhclient, NetworkManager, \u00abnetworking\u00bb, \u00absystemd-networkd / resolved, etc ) guardan los servidores DNS que usan dentro de sus propios archivos de configuraci\u00f3n y los manipulan all\u00ed de forma aut\u00f3noma (por ejemplo NetworkManager usa /var/run/NetworkManager/resolv.conf, \u00absystemd-resolved\u00bb usa /run/systemd/resolve/resolv.conf, \u00abNetworking\u00bb usa la l\u00ednea dns-nameservers dentro de /etc/network/interfaces, etc) pero adem\u00e1s siempre vinculan en forma de enlace simb\u00f3lico su archivo propio respectivo al archivo com\u00fan /etc/resolv.conf para que los programas que utilicen este archivo com\u00fan no tengan problemas en encontrar los servidores DNS.",
            "title": "Ver la configuraci\u00f3n actual"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-de-red-estatica-de-forma-temporal",
            "text": "Para asignar una IP / m\u00e1scara concreta a una tarjeta:  ip address add v.x.y.z/n dev nomTarjeta    Para borrar una IP / m\u00e1scara concreta de una tarjeta:  ip address del v.x.y.z / n dev nomTarjeta     NOTA  Tambi\u00e9n se puede hacer  ip address flush dev nomTarjeta  si lo que se quiere es borrar de golpe cualesquiera de las eventuales diferentes direcciones IP que pueda tener la tarjeta indicada   Para asignar la puerta de enlace concreta a una tarjeta:  ip route add default v\u00eda v.x.y.z dev nomTarjeta . Antes, sin embargo, deber\u00eda borrar la que hab\u00eda asignada antes (si no se hace da error), as\u00ed:  ip route del default dev nomTarjeta .   NOTA  Tambi\u00e9n se puede escribir  ip route add 0.0.0.0/0 v\u00eda v.x.y.z dev nomTarjeta . Es equivalente.    NOTA  De forma alternativa, en vez de hacer  ip route del \u2026  y despu\u00e9s  ip route add \u2026 , el cambio de puerta de enlace predeterminada se podr\u00eda hacer directamente en un solo paso, as\u00ed:  ip route change default v\u00eda v.x.y.z dev nomTarjeta    NOTA  Tambi\u00e9n se puede indicar que se quiere utilizar una determinada puerta de enlace s\u00f3lo para llegar a una red-destino concreta. En este caso, entonces, no estar\u00edamos hablando de puerta de enlace \u00abpor defecto\u00bb sino de una puerta de enlace \u00abespec\u00edfica\u00bb. La puerta de enlace \u00abpor defecto\u00bb ser\u00eda usada una vez que el sistema hubiera comprobado que el destino deseado no forma parte del conjunto de destinos indicados en puertas de enlace espec\u00edficas. Para crear una puerta de enlace espec\u00edfica hay que ejecutar el comando  ip route add ip.red.Destino/Mascara v\u00eda v.x.y.z dev nomTarjeta  Se puede a\u00f1adir adem\u00e1s un \u00faltimo par\u00e1metro metric n, que indica la preferencia de la ruta en el caso de que hubieran varias que llevaran al mismo destino (a modo de \u00abbackup\u00bb): un n menor indica una mayor preferencia.    NOTA  Una vez asignada una direcci\u00f3n IP a una tarjeta, el sistema calcula autom\u00e1ticamente su direcci\u00f3n IP de red correspondiente y genera una ruta a ella (es por eso que es necesario indicar la m\u00e1scara en ip address add \u2026)\nPor ejemplo, si se asigna la IP 203.0.113.25/24 a la tarjeta enp0s3, se crear\u00e1 autom\u00e1ticamente una ruta en la red 203.0.113.0/24 directa, por lo que el sistema sabr\u00e1 que para comunicarse con hosts de esta red no necesitar\u00e1 ninguna puerta de enlace intermediaria sino que lo podr\u00e1 hacer directamente.",
            "title": "Establecer una configuraci\u00f3n de red est\u00e1tica de forma temporal"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-estatica-de-forma-permanente-en-sistemas-debian-clasicos",
            "text": "Todos los comandos anteriores, sin embargo, s\u00f3lo \u00abfuncionan\u00bb mientras la m\u00e1quina se mantiene encendida: si apaga entonces las direcciones IP / m\u00e1scaras y puertas de enlace configuradas con las \u00f3rdenes \u00abip\u00bb anteriores se pierden y hay, pues, que volver a ejecutarlas de nuevo en el siguiente inicio.  Para que la configuraci\u00f3n deseada de IP / m\u00e1scara y puerta de enlace (y servidor DNS tambi\u00e9n, gestionado con alguno de los programas comentados en p\u00e1rrafos anteriores) para una determinada tarjeta de red se mantenga de forma permanente en cada reinicio de la m\u00e1quina, hay que escribir los valores adecuados en un determinado archivo. En sistemas Debian/Ubuntu, este archivo se denomina /etc/network/interfaces y debe tener un aspecto similar al siguiente (las l\u00edneas que comienzan por # son comentarios, las tabulaciones son opcionales):  # Las l\u00edneas \"auto\" sirven para activar la tarjeta en cuesti\u00f3n (en este #caso la tarjeta \"lo\")\nauto lo\n# La l\u00ednea siguiente indica que la tarjeta \"lo\" es de \n# tipo \"loopback\" (y que, por tanto, tendr\u00e1 la IP 127.0.0.1)\niface lo inet loopback\n# En el mismo archivo se pueden configurar todas las tarjetas que \n# se quieran: la siguiente se llama enp3s0\nauto enp3s0\n# La palabra \"static\" indica que los valores de IP, m\u00e1scara, etc \n# son fijos en cada reinicio\niface enp3s0 inet static\n# A continuaci\u00f3n se indican los valores de IP, m\u00e1scara, puerta de \n# enlace y servidores DNS que se quieren asignar\naddress v.x.y.z\nnetmask w.w.w.w\ngateway v.x.y.z\ndns-nameservers v.x.y.z v.x.y.z   Atenci\u00f3n  Atenci\u00f3n, la l\u00ednea \u00ab dns-nameservers \u00bb del archivo anterior s\u00f3lo funciona (es decir, se copian los servidores DNS indicados all\u00ed en el archivo central del sistema donde deben estar para ser utilizados: /etc/resolv.conf) si hay instalado un paquete llamado \u00ab resolvconf \u00bb. Si no lo est\u00e1, estas l\u00edneas no se  tendr\u00e1n en cuenta.   Este archivo es le\u00eddo por un servicio del sistema (un demonio) que se pone en marcha autom\u00e1ticamente al arrancar la m\u00e1quina y que se denomina \u00abnetworking\u00bb. Esto quiere decir que en cualquier momento que hagamos un cambio dentro de este archivo, para que se tenga en cuenta o bien habr\u00e1 que reiniciar la m\u00e1quina o bien simplemente reiniciar el servicio, as\u00ed:  sudo systemctl restart networking",
            "title": "Establecer una configuraci\u00f3n est\u00e1tica de forma permanente (en sistemas Debian cl\u00e1sicos)"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-estatica-de-forma-permanente-en-sistemas-systemd",
            "text": "\u00abSystemd-networkd\u00bb  es un demonio que gestiona las configuraciones de las diferentes interfaces de red (f\u00edsicas y / o virtuales) de un sistema systemd, representando, pues, una alternativa al demonio \u00abNetworking\u00bb de sistemas Debian as\u00ed como tambi\u00e9n al scripts ifcfg- * cl\u00e1sicos de Fedora / Suse o al Network Manager integrado en muchos escritorios.  Para empezar a utilizar este demonio es recomendable detener primero la \u00abcompetencia\u00bb, por ejemplo, en el caso de Ubuntu ejecutando  sudo sytemctl disable networking && sudo systemctl stop networking)  Y entonces encenderlo junto con el servicio \u00absystemd-resolved\u00bb, as\u00ed, por ejemplo:   Note  Al igual que ocurr\u00eda con el paquete \u00abresolvconf\u00bb en los sistemas Debian, se necesita tener un servicio adicional instalado (y funcionando) en el sistema llamado \u00absystemd-resolved\u00bb si se quieren especificar entradas DNS expl\u00edcitas en los archivos .network (o bien si se obtienen v\u00eda DHCP). Este servicio lo que hace es, a partir de estas entradas, modificar el archivo /run/systemd/resolve/resolv.conf, el cual, por compatibilidad con muchos programas tradicionales, deber\u00eda apuntar en forma de enlace suave en /etc/resolv.conf (ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf). Alternativamente, se puede no utilizar systemd-resolved y modificar entonces el archivo /etc/resolv.conf a mano.   Se pueden ver el nombre (y tipo y estado) de las interfaces de red actualmente reconocidas en el sistema (y su tipo y estado) mediante el comando  networkctl list . Si en la columna SETUP aparece \u00abunmanaged\u00bb significa que esta interfaz concreta no es gestionada por systemd-networkd sino por alg\u00fan otro servicio alternativo. Otra orden que da m\u00e1s informaci\u00f3n es  networkctl status . En cualquier caso, para hacer que se gestione por systemd-networkd, por cada interfaz hay que crear un archivo * .network dentro de la carpeta /etc/systemd/network (y reiniciar el servicio). En el caso concreto de querer asignar una IP est\u00e1tica, ser\u00eda necesario, pues, tener un archivo como este (llamado por ejemplo \u00ab/etc/systemd/network/lalala.network \u00ab):  [Match]\nName=enp1s0\n#Identifica la tarjeta a la cual se le aplicar\u00e1 la configuraci\u00f3n\n[Network]\nDHCP=no\nAddress=10.1.10.9/24\nGateway=10.1.10.1\nDNS=10.1.10.2 #Opcional (Es necesario tener el servicio systemd-resolved funcionando)\nDNS=10.1.10.3 #Cada servidor DNS ha d'indicar-se en una l\u00ednia separada  Los archivos de configuraci\u00f3n de systemd-networkd proporcionados por la distribuci\u00f3n se encuentran en  /usr/lib/systemd/network  y los administrados por nosotros se tienen que ubicar en  /etc/systemd/network . Todos estos archivos se leen -sin distinci\u00f3n de donde est\u00e9n ubicados \u2013 en orden alfanum\u00e9rico seg\u00fan el nombre que tienen, ganando siempre la primera configuraci\u00f3n encontrada en caso de que afectara a la misma tarjeta. Eso s\u00ed, si en las dos carpetas se encuentra un fichero con el mismo nombre, lo que hay bajo  /etc/systemd/network  anula siempre a lo que hay en  /usr/lib/systemd/network  (una consecuencia de esto es que si el archivo en /etc/\u2026 apunta a /dev/null, lo que se estar\u00e1 haciendo es deshabilitar.  Existen tres tipos diferentes de archivos de configuraci\u00f3n:   los  \u00ab.network\u00bb  aplican la configuraci\u00f3n descrita bajo su secci\u00f3n [Network] a aquellas tarjetas de red que tengan una caracter\u00edstica que concuerde con todos los valores indicados en las diferentes l\u00edneas bajo la secci\u00f3n [Match] (normalmente aqu\u00ed s\u00f3lo indica su nombre mediante una \u00fanica l\u00ednea \u00abName =\u00bb)  los  \u00ab.netdev\u00bb  sirven para crear nuevas interfaces de red de tipo virtual ( \u00abbridges\u00bb, \u00abbonds\u00bb, etc) -la configuraci\u00f3n de red se seguir\u00e1 indicando en su correspondiente archivo .network)  los  \u00ab.link\u00bb  sirven para definir nombres alternativos a las tarjetas de red en el momento de ser reconocidas por el sistema (v\u00eda systemd-udev).   En las l\u00edneas bajo la secci\u00f3n [Match] -por ejemplo, en \u00abName =\u00bb, se puede utilizar el comod\u00edn *. En esta l\u00ednea en concreto tambi\u00e9n se puede escribir un conjunto de nombres separados por un espacio en blanco a modo de diferentes alternativas.  En los archivos .network puede haber una secci\u00f3n (no vista en los ejemplos anteriores) titulada [Link] bajo la que pueden haber varias l\u00edneas m\u00e1s relacionadas con el comportamiento \u00abhardware\u00bb de la tarjeta, como la l\u00ednea \u00abMACAddress = xx: xx: xx: xx: xx: xx\u00bb, la cual sirve para asignar a la tarjeta en cuesti\u00f3n una direcci\u00f3n MAC ficticia, la l\u00ednea \u00abMTUBytes = no\u00bb, la cual sirve para indicar el tama\u00f1o de la MTU admitida (\u00fatil por ejemplo para activar los \u00abjumbo frames\u00bb si se pone 9000 como valor), o la l\u00ednea \u00abARP = no\u00bb para desactivar el protocolo ARP en la tarjeta en cuesti\u00f3n (activado por defecto).  Los archivos .netdev suelen tener s\u00f3lo una secci\u00f3n titulada [netdev], la cual debe incluir dos l\u00edneas obligatoriamente: \u00abName =\u00bb (por asignar un nombre a la interfaz virtual que se crear\u00e1) y \u00abKind =\u00bb (para especificar el tipo de interfaz que ser\u00e1: \u00abbridge\u00bb, \u00abbond\u00bb, \u00abVlan\u00bb, \u00abveth\u00bb, etc). En el caso de que sea de tipo \u00abvlan\u00bb, aparecer\u00e1 entonces una secci\u00f3n titulada [VLAN] incluyendo como m\u00ednimo la l\u00ednea \u00abId =\u00bb para indicar el n\u00famero de VLAN que se est\u00e1 creando.  Los archivos .link suelen tener una secci\u00f3n [Match] con la l\u00ednea \u00abMACAddress =\u00bb para identificar la tarjeta de red en cuesti\u00f3n y una secci\u00f3n\n[Link] que sirve para manipular las caracter\u00edsticas de esta tarjeta, como por ejemplo su nombre (con la l\u00ednea \u00abName =\u00bb y, opcionalmente, la l\u00ednea \u00abDescription =\u00bb). Si no se crea manualmente ning\u00fan archivo .link, la mayor\u00eda de distribuciones ofrecen un archivo .link predeterminado, generalmente llamado 99-default.link (y ubicado en / usr / lib / systemd / network); es por ello que hay que asegurarse que los ficheros .link \u00abmanuales\u00bb tengan un nombre que asegure su lectura antes de la del archivo 99-default.link.  Para m\u00e1s informaci\u00f3n sobre las posibilidades que ofrecen todos estos archivos, consultar las p\u00e1ginas del manual \u00absystemd.network\u00bb, \u00abSystemd.netdev\u00bb y \u00absystemd.link\u00bb.   Atenci\u00f3n  No s\u00f3lo existen el servicio \u00abnetworking\u00bb y \u00absystemd-networkd\u00bb para gestionar las tarjetas de red de nuestro sistema. Tambi\u00e9n podemos encontrar el servicio \u00abNetworkManager\u00bb (sobre todo en sistemas con escritorio) y en las \u00faltimas versiones de Ubuntu el servicio \u00abNetplan\u00bb, entre otros. !!!",
            "title": "Establecer una configuraci\u00f3n est\u00e1tica de forma permanente (en sistemas systemd)"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-dinamica-de-forma-temporal",
            "text": "En las configuraciones anteriores, tanto la temporal como la permanente, se establece una direcci\u00f3n IP / m\u00e1scara + puerta de enlace concreta, decidida por nosotros. Este m\u00e9todo puede ser \u00fatil para pocas m\u00e1quinas, pero en una red con muchos equipos, puede llegar a ser bastante farragoso, adem\u00e1s de que f\u00e1cilmente se pueden cometer errores (IPs duplicadas, IP no asignadas).  Otro m\u00e9todo para establecer estos datos es el m\u00e9todo \u00abdin\u00e1mico\u00bb, en el que la m\u00e1quina en cuesti\u00f3n no tiene asignada de forma fija IP / m\u00e1scara + puerta de enlace + servidor DNS sino que estos datos los obtiene de la red: all\u00ed deber\u00e1 haber escuchando un ordenador ejecutando un software especial llamado \u00abServidor DHCP\u00bb, el cual sirve precisamente para atender estas peticiones de \u00abdatos de red\u00bb y asignarlas a quien las pida. De este modo, se tiene una gesti\u00f3n centralizada del reparto de direcciones IP / m\u00e1scara + puerta de enlace + servidores DNS sin necesidad de realizar ninguna configuraci\u00f3n espec\u00edfica en las m\u00e1quinas clientes. Eso s\u00ed, claro: primero se deber\u00e1 haber instalado y configurado convenientemente en nuestra red este software \u00abservidor DHCP\u00bb (un ejemplo es el paquete \u00abisc-dhcp-server \u00ab), tarea que no veremos (se presupone que esto ya est\u00e1 hecho).   Nota  Otro cliente similar es el comando host nomDNS [ip.serv.DNS]   Para pedir en un momento determinado una configuraci\u00f3n completa de red (IP, m\u00e1scara, puerta de enlace, servidores DNS, etc) a un servidor DHCP ya funcionando en nuestra LAN hemos de ejecutar un cliente DHCP, como el comando  dhclient  Dhclient nomTarjeta  Pide -para la tarjeta indicada- los datos de red (IP, m\u00e1scara, puerta de enlace, servidor DNS, etc) a alg\u00fan servidor DHCP que est\u00e9 escuchando a la LAN de nuestra m\u00e1quina.  -v Muestra por pantalla todo el proceso de petici\u00f3n y respuesta (\u00fatil para ver si va)  -r Borra todos los datos de red que pueda tener actualmente la tarjeta indicada",
            "title": "Establecer una configuraci\u00f3n din\u00e1mica de forma temporal"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-dinamica-de-forma-permanente",
            "text": "En sistemas Debian cl\u00e1sicos \uf0c1  Para pedir los datos de red a alg\u00fan servidor DHCP de nuestra red, en vez\nde tener que hacerlo manualmente con el comando  dhclient , se puede hacer de forma autom\u00e1tica cada vez que nuestra m\u00e1quina arranque (de modo que nosotros no tengamos que hacer nada y ya tengamos, si todo va bien, estos datos ya asignadas una vez iniciamos sesi\u00f3n). Esto se logra simplemente escribiendo las siguientes l\u00edneas en el archivo /etc/network/interfaces:  auto enp3s0\niface enp3s0 inet dhcp  En sistemas systemd \uf0c1  En el caso concreto de querer asignar una IP din\u00e1mica en un sistema con el demonio systemd-netword funcionando, habr\u00e1 que tener un archivo como este (llamado por ejemplo \u00ab/Etc/systemd/network/lalala.network\u00bb):  [Match]\nName = enp1s0\n[Network]\nDHCP = yes # Tambi\u00e9n podr\u00eda valer ipv4 o ipv6 seg\u00fan el tipo de direcciones IP que queremos recibir",
            "title": "Establecer una configuraci\u00f3n din\u00e1mica de forma permanente"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#ping",
            "text": "ping ip o Nombre Maq. Remota    Comprueba si la m\u00e1quina remota indicada responde. Sirve, por tanto, para saber si hay conexi\u00f3n de red con aquella m\u00e1quina (si no, podr\u00eda ser debido a cualquier causa: cable mal enchufado o roto, m\u00e1quina remota apagada, etc). En este sentido, son interesantes los datos estad\u00edsticos que aparecen al final (paquetes enviados, recibidos, perdidos, etc) y el tiempo que han tardado en enviarse estos paquetes de prueba (y recibirse la respuesta) -y as\u00ed comprobar la saturaci\u00f3n del medio.  -n No resuelve nombres (es decir, no hace la consulta previa en el servidor DNS del sistema). Por lo tanto, s\u00f3lo hace que funcione indicando direcciones IP  -c n\u00ba N\u00famero de paquetes de prueba que se enviar\u00e1n (si no se indica, son infinitos y hay que detener el env\u00edo pulsando CTRL + C)  -i n\u00baN\u00famero de segundos que se espera para enviar el siguiente paquete  -f Mode \u00abflood\u00bb. Env\u00eda paquetes a la m\u00e1xima velocidad posible, mostrando un punto por cada paquete enviado y borr\u00e1ndose el por cada respuesta recibida: por lo tanto, para ir bien habr\u00eda que s\u00f3lo se viera un punto y fuera desapareciendo: si se ven muchos puntos es que hay p\u00e9rdida de paquetes. Hay que ser root para que funcione  -I eno1 Indica la tarjeta de red para la que se enviar\u00e1n los paquetes (por si la m\u00e1quina tuviera m\u00e1s de una)",
            "title": "ping"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#mtr",
            "text": "mtr ip.o Nom.Maq.Remota  Sirve para conocer el camino seguido por un paquete desde la m\u00e1quina origen hasta la indicada, mostrando la IP (o nombre) de todos los routers\nintermedios a trav\u00e9s de los que va pasando. tambi\u00e9n muestra estad\u00edsticas de tiempo empleado en cada paquete, el mejor tiempo, el peor, los paquetes perdidos, etc  -n No resuelve nombres (es decir, no hace la consulta previa en el servidor DNS del sistema).  -c n\u00ba N\u00famero de paquetes de prueba que se enviar\u00e1n (si no se indica, son infinitos y hay que parar el env\u00edo pulsando CTRL + C)  -i n\u00ba N\u00famero de segundos que se espera para enviar el siguiente paquete",
            "title": "mtr"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#ss",
            "text": "Muestra datos sobre las conexiones existentes (o que pueden existir) en\nnuestra m\u00e1quina. Concretamente, muestra el estado de la conexi\u00f3n (los m\u00e1s habituales son ESTABLISHED y LISTEN -este \u00faltimo indica que el\npuerto est\u00e1 abierto pero sin conexi\u00f3n -\u2026 otros estados a menudo son\ntemporales y terminan derivando en una conexi\u00f3n establecida o bien\ndesapareciendo), muestra la IP y el puerto local utilizados para establecer la conexi\u00f3n (o para escuchar, segundos) y la IP y puerto remoto donde la\ncorrespondiente IP + puerto local est\u00e1n conectados.  NOTA: Otro cliente similar es el comando  host nomDNS [ip.serv.DNS]  -t Mostrar s\u00f3lo las conexiones TCP actuales  -u Mostrar s\u00f3lo las conexiones UDP actuales  -n No resuelve nombres (es decir: muestra IPs y puertos en formato num\u00e9rico en lugar de con nombres)  -a (Combinado con -t y/o -u): Muestra, adem\u00e1s de las conexiones actuales, los puertos a la escucha  -l (Combinado con -t y / o -u): Muestra s\u00f3lo los puertos a la escucha (las conexiones actuales no)  -p (Combinado con -t y / o -u): Muestra 1 columna m\u00e1s: el ejecutable \u00abdetr\u00e1s\u00bb de cada puerto local  \u2013s Muestra un resumen con estad\u00edsticas",
            "title": "ss"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#ncat",
            "text": "ncat ip.oNom.Maq.Remota noport  Cliente Netcat que viene dentro del paquete \u00abnmap\u00bb: realiza una\nconexi\u00f3n (TCP) en la m\u00e1quina y puerto indicado. Se puede a\u00f1adir el\npar\u00e1metro -v (modo verboso) y -n (no resuelve nombres), entre otros.  -v Modo verboso (-vv es m\u00e1s verboso y -vvv m\u00e1s a\u00fan)  ncat -l -k -p n\u00ba  Servidor Netcat: pone a la escucha el n\u00ba de puerto (TCP) indicado. el argumento -l sirve para \u00ababrir\u00bb el puerto, el par\u00e1metro -p sirve para indicar el n\u00famero de puerto a abrir y el par\u00e1metro -k permite que se puedan conectar m\u00e1s de un cliente a la vez.  -e /ruta/comando Todo lo que se reciba de la red ser\u00e1 pasado al comando indicado, la salida ser\u00e1 devuelta al cliente. Si el comando indicado fuera\n/Bin/bash, la entrada se entender\u00e1 como un comando a ejecutar (y la\nsalida ser\u00e1 la salida del comando ejecutado).\nExemples Ncat  Chat    Servidor:  ncat -l -p 5588  <\u2014> Cliente:  ncat ipServidor 5588  El servidor se pone a escuchar en el puerto 5588 (por defecto siempre es TCP), con lo que todo lo que le llegue de la red -es decir, del cliente-lo pasar\u00e1 a la stdout (pantalla), y todo lo que escriba por stdin (teclado) pasar\u00e1 a la red -es decir, hacia el cliente-. Lo mismo ocurre en el otro lado de la comunicaci\u00f3n. Si se a\u00f1ade el par\u00e1metro -k al servidor, m\u00faltiples clientes podr\u00e1n enviar mensajes al servidor y este, lo que env\u00ede, lo enviar\u00e1 a todos sin discriminaci\u00f3n  Env\u00edo de un archivo  Servidor:  ncat -l -p 5555 < archivo  <-> Cliente:  ncat ipServidor 5555 > archivo  Muy similar a lo anterior: el servidor se pone a escuchar en el puerto 5555, pero en vez de responder por teclado a la stdin, la entrada proviene de un archivo, el cual esperar\u00e1 latente a que cuando se establezca una comunicaci\u00f3n por ese puerto, su contenido viaje bit a bit por la red hacia el cliente, el cual lo recibir\u00e1 y lo guardar\u00e1 en forma de archivo otra vez. Lo malo es que tal como se ha hecho, no se sabe cu\u00e1ndo se ha acabado la transferencia: hay que esperar un tiempo prudencial y entonces hacer Ctrl+C.  Reproducci\u00f3n de audio en streaming  Servidor:  ncat -l -p 5858  Cliente:  ncat ipServidor 5858 | mpg123 \u2013  El ejemplo es id\u00e9ntico al anterior, teniendo un archivo en este caso de audio. La \u00fanica diferencia es que en el cliente, el archivo no se redirecciona para grabarlo en disco sino que se entuba a un reproductor de audio por consola, como mpg123 (el gui\u00f3n del final es para indicarle que el fichero o lista de reproducci\u00f3n le proviene de la tuber\u00eda).  Clonaci\u00f3n de discos por red  Servidor:  ncat -l -p 5678 | dd of=a.iso.gz  <\u2014->Cliente:  dd if=/dev/sda | gzip -c | ncat ipServidor 5678  El ejemplo es parecido al anterior: primero en el cliente se comprime bit a bit el contenido del disco \u00absda\u00bb y se le env\u00eda ya comprimido al servidor, el cual recibe este contenido binario y lo almacena en un archivo, bit a bit too.",
            "title": "ncat"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#nmap",
            "text": "nmap -sn { ipInici-ipFinal [altraIP \u2026] | ipConAsteriscos }  Muestra qu\u00e9 ordenadores est\u00e1n presentes en la red. existen muchos otros par\u00e1metros de escaneo (-sU, -sX, -sF, etc) que utilizan diferentes t\u00e9cnicas m\u00e1s\no \u2013 r\u00e1pidas / sigilosas / precisas, pero no las veremos.  -v Modo verboso (-vv es m\u00e1s verboso y -vvv m\u00e1s a\u00fan)  -n No resuelve nombres  nmap -p n\u00ba, n\u00ba-n\u00ba ipOrdenador  Muestra qu\u00e9 puertos (del rango indicado) tiene abiertos un ordenador concreto. Aqu\u00ed tambi\u00e9n se pueden utilizar diferentes t\u00e9cnicas pero tampoco profundizaremos  -O Muestra el sistema operativo del ordenador y los programas \u00abdetr\u00e1s\u00bb de los\npuertos abiertos. Se puede combinar con el par\u00e1metro -sV, el cual muestra tambi\u00e9n las versiones. El par\u00e1metro -A es la combinaci\u00f3n de los dos.",
            "title": "nmap"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#nslookup",
            "text": "nslookup nombreDNS [ip.serv.DNS]  Cliente DNS que pregunta al servidor indicado o, si no se indica ninguno, al que est\u00e9 configurado en  /etc/resolv.conf . Normalmente, adem\u00e1s de devolver la IP (o IPs equivalentes) asociadas al nombre indicado, tambi\u00e9n muestra los \u00abalias\u00bb que tiene este nombre   NOTA  Otro cliente similar es el comando  host nomDNS [ip.serv.DNS]    NOTA  Otro cliente similar es el comando  dig [@ip.serv.DNS] nomDNS.  O  drill    NOTA  Otro cliente pero s\u00f3lo compatible con systemd-resolved es  systemd-resolve",
            "title": "nslookup"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#whois",
            "text": "whois dominioDNS  Consulta en los servidores whois publicos (administrados por la IANA) para averiguar el propietario o registrador del dominio",
            "title": "whois"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#wget",
            "text": "wget https://url/un/archivo  Descarga al disco duro el archivo indicado  -c Contin\u00faa la descarga (si anteriormente fall\u00f3) desde donde se interrumpi\u00f3  -O nombre Indica el nombre que tendr\u00e1 el archivo una vez descargado  -r Realiza una descarga recursiva si la URL indicada es la de una carpeta en vez de la de un archivo. Combinado con el par\u00e1metro -l n\u00ba sirve para indicar hasta qu\u00e9 nivel (1 = una subcarpeta, 2 =dos subcarpetas) se quiere descargar \u2026 si no se indica se entiende \u00abinfinito\u00bb  -N Descarga s\u00f3lo los archivos m\u00e1s nuevos que los locales  -A \u00abext1\u00bb, \u00abext2\u00bb, \u2026 Descarga s\u00f3lo los archivos que encuentre con la extensi\u00f3n indicada El par\u00e1metro contrario (descarga todo excepto los archivos indicados) es -R  \u2013no-parent No descarga contenido anterior a la URL indicada  -nd Todo lo descarga en la misma carpeta local (sin respetar, pues, la jerarqu\u00eda de carpetas del sitio remoto)  -k Una vez hecha la descarga, transforma los enlaces para que todo el contenido se pueda visitar offline (cambia las rutas absolutas para relativas y los recursos no descargados los referencia con la URL completa",
            "title": "wget"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#curl",
            "text": "curl https://url/un/archivo  Descargar el fichero indicado y muestra en pantalla su contenido  -o nombre Descargar archivo indicado y lo guarda en el disco duro con el nombre que se especifique  -O Descargar el fichero indicado y lo guarda en el disco duro con el nombre que tenga el original  -C \u2013 Contin\u00faa la descarga desde el no de byte indicado (si es un gui\u00f3n, ser\u00e1 a partir de donde se par\u00f3 la descarga -fallida- anterior del mismo archivo  -s Modo \u00absilencioso\u00bb (no muestra ni las estad\u00edsticas de descarga ni los errores, nada)  -SS Modo \u00absilencioso\u00bb pero mostrando los mensajes de error  -v Modo \u00abverboso\u00bb. Sirve para mostrar las cabeceras de cliente enviadas a la petici\u00f3n  -Y No descarga el archivo: s\u00f3lo muestra la cabecera de respuesta HTTP del servidor  -y Mostrar en pantalla tanto las cabeceras de respuesta como el contenido del archivo pedido  -D nombre Guarda en el disco duro, en forma de archivo con el nombre indica, las cabeceras de respuesta  -L Si el servidor web devuelve un c\u00f3digo de redirecci\u00f3n (3xx), lo sigue autom\u00e1ticamente  -H \u00abcabecera: valor\u00bb Realiza una petici\u00f3n indicando un valor concreto para la cabecera HTTP de cliente indicada. Se pueden poner m\u00faltiples par\u00e1metros -H.  \u2013X tipo Realiza una petici\u00f3n del tipo indicado (POST, PUT, etc). Por defecto son GET",
            "title": "curl"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/",
            "text": "Systemd (I)\n\uf0c1\n\n\nIntroducci\u00f3n\n\uf0c1\n\n\nSystemd es varias cosas:\n\n\n\n\nEl proceso Init (PID 1) del sistema\n\n\nEl gestor de demonios\n\n\nUn intermediario entre aplicaciones de usuario y ciertas partes de la API del kernel de Linux\n\n\n\n\nLa configuraci\u00f3n general de systemd se encuentra en el archivo \n/etc/systemd/system.conf\n; muchos valores por defecto est\u00e1n all\u00ed establecidos.\n\n\nPara saber la versi\u00f3n actual de systemd que hay funcionando el sistema, hacer \nsystemctl --version\n\n\n\"Units\": tipos y ubicaci\u00f3n\n\uf0c1\n\n\nTodo lo que es gestionado por systemd se llama \"unit\" y cada \"unit\" es descrita por un archivo de configuraci\u00f3n propio, el cual tendr\u00e1 una extensi\u00f3n diferente seg\u00fan el tipo de de unidad que se trate:\n\n\n\n\n.service\n: Describe la configuraci\u00f3n de un demonio\n\n\n.socket\n: Describe la configuraci\u00f3n de un socket (de tipo UNIX o TCP / IP) asociado a un .service\n\n\n.device\n: Describe un dispositivo hardware reconocido por el kernel (v\u00eda udev o sysfs) gestionado por systemd\n\n\n.mount\n: Describe un punto de montaje gestionado por systemd\n\n\n.automount\n: Describe un punto de automontaje asociado a un .mount\n\n\n.swap\n: Describe una partici\u00f3n o archivo de intercambio gestionado por systemd\n\n\n.target\n: Define un grupo de Units (se utiliza a modo de \"metapaquete\" de Units)\n\n\n.path\n: Describe una carpeta o archivo monitorizado por la API Inotify del kernel\n\n\n.timer\n: Describe la temporizaci\u00f3n / activaci\u00f3n de una tarea programada (usando el programador systemd)\n\n\n.slice\n: Define un grupo de Units asociadas a procesos para administrar y limitar los recursos comunes (CPU, memoria, discos, red). Usa internamente los llamados \"cgroups\" del kernel\n\n\n\n\nLos archivos de configuraci\u00f3n de las Units (sean del tipo que sean) pueden estar repartidos en tres carpetas distintas:\n\n\n\n\n/usr/lib/systemd/system\n: Para Units proporcionadas por los paquetes instalados en el sistema\n\n\n/run/systemd/system\n: Para Units generadas en tiempo real durante la ejecuci\u00f3n del sistema. no persistentes\n\n\n/etc/systemd/system\n: Para Units proporcionadas por el administrador del sistema\n\n\n\n\nLos archivos en \n/etc/...\n \nsobreescriben\n los archivos \nhom\u00f3nimos\n que est\u00e9n en \n/run/...\n los cuales sobreescriben los que est\u00e9n en \n/usr/lib/...\n (o en algunas distribuciones, \n/lib/...\n). Si no tienen el mismo nombre, todos los archivos de las tres carpetas se mezclan ordenados por su nombre de forma numericoalfab\u00e8tica y se van leyendo en este orden hasta el final.\n\n\nPor otra parte, si dentro de \n/usr/lib/...\n, \n/run/...\n o \n/etc/...\n hay una carpeta llamada como una unit seguido del sufijo \".d\", cualquier archivo con extensi\u00f3n * .conf que haya en su interior ser\u00e1 le\u00eddo justo despu\u00e9s de los ficheros de configuraci\u00f3n de la unit pertinente. Esto sirve para poder a\u00f1adir (o sobreescribir) opciones de configuraci\u00f3n concretas (las presentes en estos archivos) sin tener que tocar las configuraciones \"gen\u00e9ricas\" de la unit. por\nejemplo: el archivo \n/usr/lib/systemd/system/beep.service.d/foo.conf\n puede ser \u00fatil para modificar la configuraci\u00f3n definida en \n/usr/lib/systemd/systemd/beep.service\n (y de este modo, hacer posible que un paquete pueda cambiar la configuraci\u00f3n establecida por otro) y el archivo \n/etc/systemd/system/beep.service.d/foo.conf\n puede ser \u00fatil para modificar la configuraci\u00f3n definida en \n/usr/lib/systemd/system/beep.service\n (y de este modo, hacer\nposible que un administrador pueda cambiar ciertas partes de la configuraci\u00f3n de la unit preempaquetada al sistema sin tener que reemplazar completamente). Estos archivos \"override\" (concretamente con el nombre \n/etc/systemd/system/nomUnit.d/override.conf\n) se pueden generar de una manera muy c\u00f3moda y r\u00e1pida con la orden \nsystemctl edit nomUnit\n\n\nAlgunas \"units\" contienen un s\u00edmbolo @ en su nombre (por ejemplo, nom@cadena.service); esto significa que son instancias de una unit-plantilla, el archivo de configuraci\u00f3n de la cual es el que no contiene la parte\n\"Cadena\" en su nombre (as\u00ed: nombre @.service). La parte \"cadena\" es el identificador de la instancia (de hecho, dentro del archivo de configuraci\u00f3n de la unit-plantilla el valor \"cadena\" sustituye todas las ocurrencias del especificador especial %i).\n\n\nComandos para gestionar Units (principalmente de tipo \"service\")\n\uf0c1\n\n\nA continuaci\u00f3n mostramos algunos de los comandos m\u00e1s importantes para gestionar Units principalmente (No exclusivamente) de tipo \"service\":\n\n\nsystemctl [list-Units] [-t {service | socket | ...}] [--all | --failed | --state = inactive]\n Muestra el estado de las Units que est\u00e1n \"activas\" (del tipo indicado, si no se indica, aparecen todas).\n\n\n\n\nSi se escribe --state = inactive se muestra el estado de las Units que est\u00e1n \"inactivas\"\n\n\nComo valor del par\u00e1metro \n--state\n tambi\u00e9n se puede poner cualquier valor v\u00e1lido de la columna SUB\n\n\nSi se escribe \n--failed\n se muestra el estado de todas las Units con errores\n\n\n\n\nSi se escribe --all se muestra el estado de todas las Units ( \"activas\", \"inactivas\", con errores y otros)\n-La diferencia entre las columnas LOAD, ACTIVE y SUB la dice la salida de la propia comando:\n\n\n\n\n\n\nLOAD\n = Indica si la Unit ha sido cargada en RAM. Posibles valores: \"loaded\", \"error\", \"Masked\"\n\n\n\n\n\n\nACTIVE\n = Estado gen\u00e9rico de la unit. Posibles valores: \"active\", \"inactive\", \"failed\", \"(des) activating\"\n\n\n\n\n\n\nSUB\n = Estado m\u00e1s concreto de la unit, depende del tipo de unit, posibles valores \"plugged\", \"mounted\", \"running\", \"exited\", \"waiting\", \"listening\", etc\n\n\n\n\n\n\n\n\n\n\nsystemctl [-t {service | socket | ...}] list-unit-files\n\n\nEl comando \nlist-units\n s\u00f3lo muestra las units que systemd ha intentado leer y cargar en memoria. Ya que systemd s\u00f3lo lee las units que \u00e9l piensa que necesita, as\u00ed no incluye necesariamente todas las units disponibles en el  sistema. Para ver todas las units, incluyendo aquellas que systemd no ha intentando ni siquiera cargar, hay que utilizar \nlist-unit-files\n. Este subcomando muestra el \"estado de carga\" de cada unit y sus posibles valores son:\n\n\n\n\n\n\n\"enabled\"\n o \n\"enabled-runtime\"\n : La unit se activar\u00e1 en el siguiente reinicio -y subsiguientes-.\n\n\n\n\nNOTA\n\n\nEsto se consigue gracias a la existencia de un enlace al archivo de configuraci\u00f3n de la unit en cuesti\u00f3n dentro de la carpeta \n/etc/systemd/system/nomTarget.target.wants\n, creado en alg\u00fan momento previo con el comando systemctl enable (ver m\u00e1s abajo) o de forma manual con ln -s\n\n\n\n\n\n\n\n\n\"static\"\n: La unit no tiene secci\u00f3n \"[Install]\" en su archivo de configuraci\u00f3n. Esto hace que los comandos \nsystemctl enable\n (y sobre todo \nsystemctl disable\n) no funcionen. Por tanto, el hecho de que la unit est\u00e9\nactivada o no en un determinado \"target\" depender\u00e1 de la existencia \"est\u00e1tica\" de su enlace correspondiente dentro de la carpeta \n/etc/systemd/system/nomTarget.target.wants\n. Este tipo de units suelen estar asociadas a las que realizan una acci\u00f3n \"oneshot\" o bien a las que son usadas s\u00f3lo como\ndependencia de alguna otra unit (y por tanto no deben ejecutarse por s\u00ed mismas)\n\n\n\n\n\n\n\"generated\"\n: La unit se activar\u00e1 mediante un mecanismo autom\u00e1tico especial llamado \"generator\", ejecutado al arrancar el sistema. Cada unit en este estado tiene su propio \"generator\".\n\n\n\n\n\n\n\"transient\"\n : La unit es temporal y no sobrevivir\u00e1 al siguiente reinicio\n\n\n\n\n\n\n\"disabled\"\n: La unit est\u00e1 desactivada y, por tanto, no se pondr\u00e1 en marcha en los siguientes reinicios (gracias a la inexistencia del enlace correspondiente dentro de \n/etc/systemd/system/nomTarget.target.wants\n).\nTampoco podr\u00e1 ser iniciada autom\u00e1ticamente mediante otros sistemas (como v\u00eda socket, v\u00eda D-Bus o bien v\u00eda conexi\u00f3n de hardware. No obstante, podr\u00e1 ser puesta en marcha en cualquier momento \"manualmente\" ejecutando \nsystemctl start\n( ver m\u00e1s abajo)\n\n\n\n\n\n\n\"Masked\"\n o \n\"Masked-runtime\"\n: La unit est\u00e1 Enmascarada (es decir, est\u00e1 desactivada y, por tanto, no se pondr\u00e1 en marcha en los siguientes reinicios ni autom\u00e1ticamente, pero adem\u00e1s, tampoco podr\u00e1 ser puesta nunca\nen marcha manualmente con systemctl start ni siquiera si es una dependencia de otro servicio)\n\n\n\n\n\n\nsystemctl {start | stop | restart} nomUnit[.service]\n Activa / Desactiva / Reiniciar la unit indicada inmediatamente siguiendo las indicaciones escritas en su archivo de configuraci\u00f3n correspondiente.\n\n\n\n\nNOTA\n\n\nSi la unit no fuera de tipo \".service\", entonces habr\u00e1 que indicar su tipo expl\u00edcitamente \u00faltima su nombre (por ejemplo, \nsystemctl start nomUnit.socket\n). Esta norma es extensiva para el resto de comandos \n\n\n\n\nsystemctl {enable | disable} nomUnit[.service]\n Activar\u00e1 / desactivar\u00e1 autom\u00e1ticamente la unit indicada a partir del siguiente reinicio (y siguientes)\n\n\n\n\nNOTA\n\n\nEn realidad lo que hace enable / disable es crear / eliminar un enlace dentro de la carpeta \n/etc/systemd/systemd/nomTarget.target.wants\n al archivo de configuraci\u00f3n de la unit en cuesti\u00f3n (donde \"nomTarget\" viene definido en la directiva WantedBy de la secci\u00f3n \"[Install]\" de dicho archivo).\n\n\n\n\nsystemctl {mask | unmask} nomUnit [.service]\n Enmascara / desenmascarar la unit indicada.\n\n\n\n\nNOTA\n\n\nEsto lo consigue vinculando el archivo de configuraci\u00f3n ubicado en \n/etc/...\n de la unit en cuesti\u00f3n a /dev/null\n\n\n\n\nsystemctl is-enabled nomUnit[.service]\n Devuelve \n$? = 0\n si la unit indicada est\u00e1 configurada para activarse en los siguientes reinicios (es decir, si est\u00e1 en los estados listados para \nsystemctl list-unit-files\n : \"enabled\", \"enabled-runtime\", \"static\", \"Generated\" o \"transient\") y adem\u00e1s, muestra en pantalla este estado.\n\n\nsystemctl is-active nomUnit [.service]\n Devuelve $? = 0 si la unit indicada est\u00e1 activa y, adem\u00e1s, muestra en pantalla este estado (valor listado en la columna ACTIVE de systemctl list-units)\n\n\nsystemctl is-failed nomUnit[.service]\n Devuelve $? = 0 si la unit indicada fall\u00f3 al intentar activarse y, adem\u00e1s, muestra en pantalla este estado. Si no queremos que se muestren los estados en pantalla (esto tambi\u00e9n por is-enabled y is-active ), se puede a\u00f1adir el par\u00e1metro -q\n\n\n\n\nNOTA\n\n\nUna unit puede estar en estado \"failed\" por m\u00faltiples razones: porque el proceso ha terminado con un c\u00f3digo de error diferente de 0, porque ha finalizado de forma anormal, porque se ha superado un timeout determinado, etc.\n\n\n\n\nsystemctl status {nomUnit [.service] | PID}\n Muestra el estado e informaci\u00f3n variada sobre la Unit o proceso indicado. Si se indica una unit se puede ver ...:\n\n\n    Loaded: loaded (/usr/lib/systemd/system/cups.service; enabled; vendor preset: disabled)\n    Active: active (running) since Sat 2017-11-18 20:48:06 CET; 4h 2min agosto\n    Docs: man: cupsd (8)\n    Main PID : 745 (cupsd)\n    Status: \"Scheduler is running ...\"\n    Tasks: 1 (l\u00edmite: 4915)\n    CGroup: /system.slice/cups.service\n    \u2514\u2500745 / usr / sbin / cupsd -l\n\n    \u00daltimas l\u00edneas de journald -u (se puede usar los par\u00e1metros hom\u00f3nimos -n n\u00ba y -o xxx)\n\n\n\n\nLos valores para la l\u00ednea \"Loaded:\" son los mismos que aparecen en la columna LOAD de list-units\n\n\nSeguidamente se indican los valores del estado actual y el predefinido por paquete, que ser\u00e1n uno de los detallados anteriormente al hablar de list-unit-files\n\n\nLos valores para la l\u00ednea \"Active:\" son los mismos que aparecen en la columna ACTIVE de list-Units\n\n\nEl punto ( \"\u25cf\") es blanco si la unit est\u00e1 \"inactive\"; rojo si \"failed\" o verde si \"active\"\n\n\nSi se indica un PID en vez de una unit, se puede ver la misma informaci\u00f3n, pero esta manera puede ser \u00fatil para conocer la unit a la que est\u00e1 asociado un determinado proceso, por ejemplo (aunque para conocer esta informaci\u00f3n tambi\u00e9n se podr\u00edan observar los valores de la columna \"unit\" mostrada para el comando \nps -o\n si as\u00ed se indica con el par\u00e1metro -o ):\n\n\ncups.service - CUPS Scheduler\nLoaded: loaded ( /usr/lib/systemd/system/cups.service ; enabled; vendor preset:\nActive: active (running) since Sat 2017-11-18 20:48:06 CET; 4h 2min agosto\nDocs: man: cupsd (8)\nMain PID: 745 (cupsd)\nStatus: \"Scheduler is running ...\"\nTasks: 1 (l\u00edmite: 4915)\nCGroup: /system.slice/cups.service\n\u2514\u2500745 / usr / sbin / cupsd -l\n\u00daltimas l\u00edneas de journald _PID = (se puede usar los par\u00e1metros hom\u00f3nimos -n n\u00ba y -o xxx)\n\n\n\n\nsystemctl show {nomUnit [.service] | PID}\n Muestra la configuraci\u00f3n actual de la Unit (obtenida a partir del archivo general system.conf y del archivo de configuraci\u00f3n propio de la unit) indicada en un formato adecuado para ser procesado por m\u00e1quinas. con el par\u00e1metro \n-p \"nomClave, OtroNombre,...\n se pueden obtener s\u00f3lo las parejas clave <-> valor deseadas.\n\n\nsystemctl daemon-reload\n Actualizar todos los archivos de configuraci\u00f3n de Units nuevas o modificadas desde la \u00faltima vez que se puso en marcha systemd (incluyendo los generators).\n\n\nsystemctl help nomUnit [.service]\n Abre la p\u00e1gina man asociada a la Unit indicada (en su fichero de configuraci\u00f3n debe venir indicada)\n\n\nsystemctl edit nomUnit [.service]\n Crea (con el editor de texto predeterminado del sistema) un fichero de configuraci\u00f3n (inicialmente vac\u00edo) para la Unit indicada llamado \n/etc/systemd/system/nomUnit.tipusUnit.d/override.conf\n para sobrescribir (o ampliar) la configuraci\u00f3n ya existente por ella. Una vez guardados los cambios, recarga la Unit autom\u00e1ticamente con esta nueva configuraci\u00f3n. Si se quisiera editar directamente el archivo \n/etc/systemd/system/nomUnit.tipoUnit\n, hay que a\u00f1adir entonces el par\u00e1metro \n--full\n\n\nsystemctl cat nomUnit [.service]\n Muestra la configuraci\u00f3n final actual resultante de haber le\u00eddo los diferentes ficheros de configuraci\u00f3n\nposibles de la Unit indicada\n\n\nsystemd-delta\n Muestra qu\u00e9 archivos de configuraci\u00f3n de Units est\u00e1n sobreescritos o ampliados (de /usr /lib a /etc y / o con\narchivos \"overrides\"), enmascarados, redireccionados (con la l\u00ednea Alias \u200b\u200b= de la secci\u00f3n [Install]), etc y por cu\u00e1les\n\n\nsystemctl kill [--signal = n\u00ba] nomUnit [.service]\n Env\u00eda una se\u00f1al concreta (indicada con el par\u00e1metro --signal ; por defecto es la n\u00ba15, SIGTERM) a\ntodos los procesos asociados a la Unit indicada.\n\n\n\n\nNOTA\n\n\nkill  goes directly and sends a signal to every process in the group, however  stop  goes through the  official configured way to shut down a service, i.e. invokes the stop command configured with ExecStop= in the service file. Usually stop should be sufficient. kill is the tougher version, for cases where you either don't want the official shutdown command of a service to run, or when the service is hosed and hung in other ways.\n\n\n\n\nServicios Systemd por Usuario\n\uf0c1\n\n\nSystemd tambi\u00e9n permite definir servicios para que no est\u00e9n asociados al sistema global sino que \u00fanicamente formen parte de la sesi\u00f3n de un usuario est\u00e1ndar, gener\u00e1ndose una instancia particular del servicio para cada usuario\nactivo en la m\u00e1quina. De este modo, cada instancia se iniciar\u00e1 autom\u00e1ticamente despu\u00e9s de iniciar la sesi\u00f3n de un usuario y se parar\u00e1 al salir.\n\n\n\n\nNOTA\n\n\nEsto es posible gracias a que justo despu\u00e9s del primer inicio de sesi\u00f3n que se realice al sistema se pone en marcha (gracias al m\u00f3dulo PAM \"pam_systemd\") el comando \nsystemd -user\n  ( que es quien permitir\u00e1 este funcionamiento individual para todas las sesiones de usuarios que se inicien a partir de entonces), adem\u00e1s del proceso con PID 1 propiamente dicho, que es \nsystemd -system\n . El proceso \nsystemd -user\n finalizar\u00e1 autom\u00e1ticamente justo despu\u00e9s de haberse cerrado el \u00faltimo inicio de sesi\u00f3n existente al sistema.\n\n\n\n\nLos ficheros de configuraci\u00f3n de las Units \"de tipo usuario\" se encuentran en otras carpetas separadas de las de las Units \"de sistema\". Concretamente (se muestran en orden de precedencia ascendente):\n\n\n\n\n\"/Usr/lib/systemd/user\": Para Units proporcionados por los paquetes instalados en el sistema\n\n\n\"~ / .Local / share / systemd / user\": Para Units de paquetes que han sido instaladas en la carpeta personal\n\n\n\"/ Etc / systemd / user\": Para Units proporcionados por administrador del sistema\n\n\n\"~ / .Config / systemd / user\": Para Units construidas por el propio usuario\n\n\n\n\n\n\nNOTA\n\n\nLa variable especial \n%h\n se puede utilizar dentro de los archivos de configuraci\u00f3n de las Units \"de usuario\" para indicar la ruta de la carpeta personal del usuario en cuesti\u00f3n.\n\n\n\n\nOtra caracter\u00edstica de las Units \"de usuario\" es que pueden ser gestionadas por parte de este usuario sin que deba ser administrador del sistema; esto lo puede hacer con las mismas \u00f3rdenes \nsystemctl...\n  ya conocidas s\u00f3lo que a\u00f1adiendo el par\u00e1metro --user As\u00ed, por ejemplo, para arrancar un servicio autom\u00e1ticamente cada vez que se inicie nuestra sesi\u00f3n habr\u00e1 que ejecutar \nsystemctl --user enable nomUnit\n ; para ver el estado de\ntodas nuestras Units \"de usuario\" habr\u00e1 que hacer \nsystemctl --user list-units\n ; para recargar las Units modificadas habr\u00e1 que hacer \nsystemctl --user daemon-reload\n , etc\n\n\nSecciones y directivas comunes en los ficheros de configuraci\u00f3n de las Units\n\uf0c1\n\n\nLa estructura interna de los archivos de configuraci\u00f3n de las Units est\u00e1 organizada en secciones, distinguidas cada una por un encabezamiento sensible a may\u00fasculas y min\u00fasculas rodeado de corchetes ( [Encabezamiento] ). Dentro de las secciones se definen diferentes directivas (tambi\u00e9n may\u00fasculas y min\u00fasculas) en la forma de parejas NomDirectiva = valor , donde el valor puede ser una palabra, una frase, una ruta, un n\u00famero, true/yes, false/no, una\nfecha, etc, dependiendo de su significado.\n\n\n\n\nNOTA\n\n\nNOTA: Tambi\u00e9n pueden existir directivas donde no se escriba ning\u00fan valor (es decir, as\u00ed: NomDirectiva = ). En este caso, se estar\u00e1 \"Reseteando\" (es decir, anulando) el valor que previamente se hubiera dado en otro sitio\n\n\n\n\nLa primera secci\u00f3n (aunque el orden no importa) siempre suele ser la llamada [Unit] y se utiliza para definir datos sobre la propia Unit en s\u00ed como Unit que es y la relaci\u00f3n que tiene \u00e9sta con otros Units. algunas de sus directivas m\u00e1s habituales son:\n\n\n\n\n\n\nDescription\n = Una breve descripci\u00f3n de la Unit\n\n\nSu valor es devuelto por diferente herramientas systemd\n\n\n\n\n\n\nDocumentation\n = man: sshd (8) https: //ruta/pag.html\n\n\nProporciona una lista de URIS que apuntan a documentaci\u00f3n de la Unit.\n\n\nEl comando \nsystemctl status\n las muestra\n\n\n\n\n\n\nWants\n = unservei.service unaltre.service untarget.target ...\n\n\nLista las Units que deber\u00edan estar iniciadas para que el Unit en cuesti\u00f3n pueda funcionar correctamente. Si no lo est\u00e1n ya, systemd las iniciar\u00e1 en paralelo junto con el Unit en cuesti\u00f3n; si se quiere indicar un cierto orden en vez de iniciar todas en paralelo, se puede utilizar las directivas After = o Before =. Si alguna de las Units listadas falla al iniciarse, el Unit en cuesti\u00f3n se iniciar\u00e1 igualmente\n\n\n\n\n\n\nRequires\n = unservei.service unaltre.service untarget.target ...\n\n\nLista las Units que imprescindiblemente deben estar iniciadas para que el Unit en cuesti\u00f3n pueda funcionar correctamente. Si no lo est\u00e1n ya, systemd las iniciar\u00e1 en paralelo junto con el Unit en cuesti\u00f3n; si se quiere indicar un cierto orden en vez de iniciar todas en paralelo, se puede utilizar las directivas After = o Before =. Si alguna de las Units listadas falla al iniciarse, el Unit en cuesti\u00f3n tambi\u00e9n fallar\u00e1 autom\u00e1ticamente\n\n\n\n\n\n\nBindsTo\n = unservei.service unaltre.service untarget.target ...\n    Similar a Requires = pero, adem\u00e1s, hace que el Unit en cuesti\u00f3n se detenga autom\u00e1ticamente si alguna de las Units asociadas finaliza.\n\n\n\n\n\n\nBefore\n = unservei.service unaltre.service untarget.target ...\n    Indica, de las Units listadas en las directivas Wants = o Requires =, qu\u00e9 no se iniciar\u00e1n en paralelo sino tras la Unit en cuesti\u00f3n. Si aqu\u00ed se indicara alguna Unit que no se encontrara listada en Wants = o Requires =, esta directiva no se tendr\u00e1 en cuenta.\n\n\n\n\n\n\nAfter\n = unservei.service unaltre.service untarget.target ...\n    Indica, de las Units listadas en las directivas Wants = o Requires =, qu\u00e9 no se iniciar\u00e1n en paralelo sino antes de la Unit en cuesti\u00f3n. Si aqu\u00ed se indicara alguna Unit que no se encontrara listada en Wants = o Requires =, esta directiva no se tendr\u00e1 en cuenta.\n\n\n\n\n\n\n\n\nNOTA\n\n\nLo m\u00e1s t\u00edpico es tener una Unit A que necesita que la Unit B est\u00e9 funcionando previamente para poderse poner en marcha. En este caso, simplemente habr\u00eda que a\u00f1adir las l\u00edneas Requires = B y After = B en la secci\u00f3n [Unido] del Unit A. Si la dependencia es opcional, se puede sustituir Requires = B para Wants = B\n\n\n\n\n\n\n\n\nConflicts\n = unservei.service unaltre.service ...\n    Lista las Units que no pueden estar funcionando a la vez que el Unit en cuesti\u00f3n. iniciar una Unit con esta directiva causar\u00e1 que las aqu\u00ed listadas se detengan autom\u00e1ticamente.\n\n\n\n\n\n\nConditionXXXX\n = ...\n    Hay un conjunto de directivas que empiezan por \"Condition\" que permiten al administrador comprobar ciertas condiciones antes de iniciar el Unit. Si la condici\u00f3n no se cumple, la Unit es ignorada. Algunos ejemplos son:\n\n\nConditionKernelCommandLine = param [= valor]\nConditionACPower = {yes | no}\nConditionPathExists = [!] / Ruta / archivo / o / carpeta\nConditionPathExistsGlob = [!] / Ruta / archivos / o / carpetas\nConditionPathIsDirectory = [!] / Ruta / carpeta\nConditionPathIsSymbolicLink = [!] / Ruta / enlace\nConditionPathIsMountPoint = [!] / Ruta / carpeta\nConditionPathIsReadWrite = [!] / Ruta / archivo / o / carpeta\nConditionDirectoryNotEmpty = [!] / Ruta / carpeta\nConditionFileNotEmpty = [!] / Ruta / archivo\nConditionFileIsExecutable = [!] / Ruta / archivo\nAssertXXXX = ...\n\n\n\n\n\n\n\nAl igual que con \"ConditionXXX\", hay un conjunto de directivas que empiezan por \"Assert\" que permiten al administrador comprobar ciertas condiciones antes de iniciar el Unit. la diferencia es que aqu\u00ed, si la condici\u00f3n no se cumple, se emite un error.\n\n\n\n\n\n\n.OnFailure\n = unaunit.service otro.service ...\n    Indica las Units que se activar\u00e1n cuando la Unit en cuesti\u00f3n entre en estado \"failed\". esta directiva puede utilizarse, por ejemplo, para ejecutar una Unit que env\u00ede un correo electr\u00f3nico cuando la Unit en cuesti\u00f3n, que podr\u00e1 ser un servicio, falle.\n\n\n\n\n\n\nAllowIsolate\n = yes\n    Esta directiva s\u00f3lo tiene sentido para Units de tipo target. Si su valor es \"yes\" (por defecto es \"no\") indica que el target en cuesti\u00f3n admitir\u00e1 que se le aplique el comando systemctl Isolate (ver m\u00e1s abajo)\n\n\n\n\n\n\nPor otra parte, la \u00faltima secci\u00f3n (aunque el orden no importa) de un archivo de configuraci\u00f3n de una Unit siempre suele ser la llamada [\nInstall\n] , la cual, atenci\u00f3n, es opcional. Se utiliza para definir c\u00f3mo y cuando la Unit puede\nser activada o desactivada. Algunas de sus directivas m\u00e1s habituales son:\n\n\n\n\n\n\nWantedBy\n = untarget.target unaltre.target ...\n\n\nIndica los targets donde el Unit en cuesti\u00f3n se activar\u00e1 al ejecutar el comando \nsystemctl enable\n Cuando se ejecuta este comando, lo que pasa es que por cada target indicado aqu\u00ed aparecer\u00e1,dentro de cada carpeta \n/etc/systemd/system/nomTarget.wants\n respectiva, un enlace simb\u00f3lico apuntando al propio archivo de configuraci\u00f3n del Unit en cuesti\u00f3n. La existencia de este enlace es el que realmente activa de forma efectiva un servicio autom\u00e1ticamente. Eliminar los links de todas las carpetas \"nomTarget.wants\" pertinentes implica desactivar la Unit (que es lo que hace, de hecho,el comando \nsystemctl disable\n a partir de la lista de targets que encuentra en la l\u00ednea WantedBy = ).\n\n\nPor ejemplo, si el archivo de configuraci\u00f3n de la Unit en cuesti\u00f3n (que llamaremos pepito.service) tiene una l\u00ednea como WantedBy = multi-user.target, al ejecutar \nsystemctl enable pepito.service\n aparecer\u00e1 dentro de la carpeta \n/etc/systemd/system/multi-user.wants\n un link apuntando a este archivo de configuraci\u00f3n\n\n\n\n\n\n\nRequiredBy\n = untarget.target unaltre.target ...\n\n\nSimilar a WantedBy = pero donde el fallo del Unit en cuesti\u00f3n en ejecutar systemctl enable har\u00e1 que los targets indicados aqu\u00ed no puedan llegar a alcanzar. La carpeta donde se encuentra el link de el Unit en este caso se denomina \n/etc/systemd/system/nomTarget.requires\n\n\n\n\n\n\nAlias\n \u200b\u200b= unaltrenom.tipusUnit\n\n\nPermite al Unit en cuesti\u00f3n ser activada con \nsystemctl enable\n utilizando otro nombre diferente\n\n\n\n\n\n\nAlso\n = unservei.service unaltre.service ...\n\n\nPermite activar o desactivar diferentes Units como conjunto. La lista debe consistir en todas las Units que tambi\u00e9n se quieren tener habilitadas cuando la Unit en cuesti\u00f3n est\u00e9 habilitada\n\n\n\n\n\n\nSecci\u00f3n [Service] (por Units de tipo .service):\n\uf0c1\n\n\nDependiendo del tipo de Unit que tengamos nos podremos encontrar con diferentes secciones espec\u00edficas dentro de su fichero de configuraci\u00f3n, normalmente escritas entre la secci\u00f3n [Unit] el principio y la secci\u00f3n [Install] del final (si existe). En el caso de las Units de tipo \"service\", por ejemplo, nos encontramos con la secci\u00f3n espec\u00edfica llamada [Service] , la cual puede incluir diferentes directivas como las siguientes:\n\n\n\n\nNOTA\n\n\nLas Units de tipo device, snapshot y target no tienen secciones espec\u00edficas\n\n\n\n\n\n\n\n\nType\n = maneraDarrancar \n\n\nExisten diferentes m\u00e9todos para iniciar un servicio, y el m\u00e9todo elegido, el cual depender\u00e1 del tipo de ejecutable a poner en marcha, se indicar\u00e1 en esta directiva. Las posibilidades m\u00e1s comunes son:\n\n\n\n\n\n\nsimple\n: El servicio nativamente se queda en primer plano de forma indefinida y es systemd quien lo pone en segundo plano (le crea un fichero PID, lo para cuando sea necesario, etc). Systemd interpreta que el servicio est\u00e1 listo luego que el ejecutable asociado se pone en marcha (aunque esto sea demasiado pronto para que no est\u00e9 listo todav\u00eda para recibir peticiones)\n\n\n\n\n\n\nforking\n: El servicio nativamente ya se pone en segundo plano. Systemd interpreta que el servicio est\u00e1 listo cuando pasa efectivamente a segundo plano. En este caso conviene indicar tambi\u00e9n la directiva PidFile=/ruta/fitxer.pid para que systemd tenga un control sobre qu\u00e9 proceso es el que est\u00e1 en segundo plano y lo pueda identificar\n\n\n\n\n\n\noneshot\n: \u00datil para scripts, que se ejecutan (haciendo \nsystemctl start\n igualmente) una vez y finalizan.Systemd esperar\u00e1 hasta que el proceso finalice e interpreta que est\u00e1 listo cuando haya finalizado.\nSe puede considerar el uso de la directiva RemainAfterExit = yes para \"enga\u00f1ar\" a systemd dici\u00e9ndole que el servicio contin\u00faa activo aunque el proceso haya finalizado; en este caso, la directiva ExecStop = no se llegar\u00e1 a hacer efectiva nunca. \n\n\n\n\n\n\nTambi\u00e9n est\u00e1n las posibilidades \"dbus\" (similar a \"simple\" pero systemd interpreta que est\u00e1 listo cuando el nombre indicado en BusName = ha sido adquirido), \"idle\" (similar a \"simple\" pero con la ejecuci\u00f3n retrasada hasta que no se ejecute nada m\u00e1s; se puede utilizar este m\u00e9todo, por ejemplo, para emitir un sonido justo despu\u00e9s de la finalizaci\u00f3n del arranque del sistema.) y \"notify\" (El sistema m\u00e1s completo, donde se establece un canal de comunicaci\u00f3n interno entre el servicio y Systemd para notificarse estados y eventos v\u00eda la API propia de systemd sd_notify () y donde Systemd interpreta que est\u00e1 listo cuando recibe el estado correspondiente a trav\u00e9s de este canal; si queremos que scripts utilicen este m\u00e9todo hay que usar el comando systemd-notify )\n\n\n\n\n\n\nExecStart\n = /ruta/ejecutable param1 param2 ...\n    Indica el comando (y par\u00e1metros) a ejecutar cuando se realiza un \nsystemctl start\n Si la ruta de el ejecutable comienza con un gui\u00f3n ( \"-\"), valores de retorno del comando diferentes de 0 (que normalmente se considerar\u00edan se\u00f1al de error) se considerar\u00e1n como v\u00e1lidos.\n\n\n\n\nNota\n\n\nPodemos utilizar incluso la directiva SuccessExitStatus = para indicar qu\u00e9 valor consideramos como salida exitosa del programa\n\n\n\n\n\n\nNota\n\n\nNo habr\u00eda que escribir la ruta absoluta del ejecutable si \u00e9sta se encuentra en la lista de rutas que muestra el comando \nsystemd-path\n , pero en general se recomienda escribirla para evitar sorpresas\n\n\n\n\n\n\nNota\n\n\nNo se permiten escribir redireccionador ( \">\", \">>\", \"<\". \"|\") Ni el s\u00edmbolo \"&\" para pasar a segundo plano\n\n\n\n\n\n\n\n\nExecStartPre\n = /ruta/ejecutable param1 param2 ...\n    Indica el comando (y par\u00e1metros) a ejecutar antes de lo indicado en ExecStart. pueden haber m\u00e1s de una l\u00ednea ExecStartPre en el mismo archivo, ejecut\u00e1ndose entonces cada una por orden. la ruta del ejecutable tambi\u00e9n puede ir precedida de un gui\u00f3n ( \"-\"), con el mismo significado\n\n\n\n\n\n\nExecStartPost\n = / ruta / ejecutable param1 param2 ...\n    Indica el comando (y par\u00e1metros) a ejecutar despu\u00e9s de la indicada en ExecStart. pueden haber m\u00e1s de una l\u00ednea ExecStartPost en el mismo archivo, ejecut\u00e1ndose entonces cada por orden. un ejemplo de posible uso: \n    el env\u00edo de un correo justo despu\u00e9s de haberse puesto en marcha el servicio correspondiente.La ruta del ejecutable tambi\u00e9n puede ir precedida de un gui\u00f3n ( \"-\"), con el mismo significado\n\n\n\n\n\n\nExecStop\n = /ruta/ejecutable param1 param2 ...\n    Indica el comando (y par\u00e1metros) a ejecutar cuando se realiza un \nsystemctl stop\n Hay que tener en cuenta que en el caso de un servicio de tipo \"oneshot\", si no se especifica la directiva RemainAfterExit = yes , el comando indicada en ExecStop se ejecutar\u00e1 autom\u00e1ticamente justo tras ExecStart.\n\n\n\n\n\n\nExecStopPost\n = / ruta / ejecutable param1 param2 ...\n    Indica el comando (y par\u00e1metros) a ejecutar despu\u00e9s de lo indicado en ExecStop. pueden haber m\u00e1s de una l\u00ednea ExecStartPost al mismo archivo, ejecut\u00e1ndose entonces cada por orden.\n\n\n\n\n\n\nRestart\n = {always | no | on-success | on-failure | ...}\n    Indica las circunstancias bajo las que systemd intentar\u00e1 reiniciar autom\u00e1ticamente un servicio que haya finalizado. En concreto, el valor \"always\" indica que en cualquier tipo de finalizaci\u00f3n se volver\u00e1 a intentar reiniciar; el valor \"no\" indica que en ning\u00fan finalizaci\u00f3n intentar\u00e1 reiniciar, el valor \"on-success\" indica que s\u00f3lo se intentar\u00e1 reiniciar si la finalizaci\u00f3n ha sido correcta y \"on-failure\" si la finalizaci\u00f3n no lo ha sido debido a cualquier tipo de fallo (ya sea que se ha sobrepasado el tiempo de espera del arranque o el apagado, que se ha devuelto un valor diferente de 0, etc)\n\n\n\n\nNota\n\n\nSe podr\u00eda dar el caso de que un servicio estuviera reinici\u00e1ndose todo el rato. Con StartLimitBurts = se puede configurar el n\u00famero m\u00e1ximo de veces que se quiere que se reinicie y con StartLimitIntervalSec = se puede configurar el tiempo durante el cual se contar\u00e1 este n\u00famero m\u00e1ximo de veces. Si se llega a este n\u00famero dentro de este tiempo, el servicio no se volver\u00e1 a reiniciar autom\u00e1ticamente y tampoco se podr\u00e1 iniciar manualmente hasta pasado el tiempo indicado (momento en el que se vuelve a contar). Tambi\u00e9n existe la directiva StartLimitAction = , que sirve para indicar la acci\u00f3n a realizar cuando se alcanza el n\u00famero m\u00e1ximo de reinicios; su valor por defecto es \"None\" pero puede valer tambi\u00e9n \"reboot\" (reinicio limpio), \"reboot-force\" (reinicio abrupto) y \"reboot-immediate\" (reinicio muy abrupto)\n\n\n\n\n\n\n\n\nRestartSec\n = n\u00bas\n    Indica el n\u00famero de segundos que systemd esperar\u00e1 al reiniciar el servicio despu\u00e9s de que haya detenido (si as\u00ed lo marca la directiva Restart =).\n\n\n\n\n\n\nTimeoutSec\n = n\u00ba\n    Indica el n\u00famero de segundos que systemd esperar\u00e1 a que el servicio en cuesti\u00f3n inicie o detenga antes de marcarlo como \"failed\" (y reiniciarlo si fuera el caso debido a la configuraci\u00f3n de la directiva Restart =). Se puede indicar espec\u00edficamente un tiempo de espera s\u00f3lo para el inicio con la directiva TimeoutStartSec = y otro tiempo de espera diferente por el apag\u00f3n con la directiva TimeoutStopSec = . Si no se especifica nada, se toma el valor por defecto (5 min) que est\u00e1 indicado en /etc/systemd/system.conf\n\n\n\n\n\n\nRemainAfterExit\n = yes\n    Tal como ya lo hemos comentado, esta directiva se utiliza en servicios de tipo \"oneshot\" para que la directiva ExecStop = no se ejecute al terminar la ejecuci\u00f3n del comando sino al hacer systemctl stop\n\n\n\n\n\n\nPidFile\n = /ruta/fitxer.pid\n    Tal como ya lo hemos comentado, esta directiva se utiliza en servicios de tipo \"forking\" para se\u00f1alar a systemd cu\u00e1l ser\u00e1 el archivo PID utilizado por el servicio de manera que pueda controlar m\u00e1s f\u00e1cilmente.\n\n\n\n\n\n\nUser\n = unusuari\n\n\n\n\n\n\nGroup\n = ungrup\n    Set the user or group that the processes are executed as, respectively. They can take a single user/group name, or a numeric ID as argument. For system services (services run by the system service manager, i.e. managed by PID 1) the default is \"root\". For user services of any other user, switching user identity is not permitted, hence the only valid setting is the same user the user's service manager is running as. If no group is set, the default group of the user is used.\n\n\n\n\n\n\nWorkingDirectory\n = / ruta / carpeta\n    Indica el directorio de trabajo del servicio en cuesti\u00f3n. Si no se especifica esta directiva, el valor por defecto es \"/\" (en el caso de servicios de sistema) o $ HOME (en el caso de servicios de usuario, es decir, iniciados con --user -). Si la ruta se precede con un s\u00edmbolo \"-\", el hecho de que la carpeta correspondiente no exista no se interpretar\u00e1 como un error. Si se ha indicado la directiva User =, se puede escribir \"~\" como valor de esta directiva, equivalente as\u00ed a la ruta de la carpeta personal del usuario indicado en User =.\n\n\n\n\n\n\nStandardOutput\n = {null | tty | journal | socket}\n    Indica donde se imprimir\u00e1 la salida est\u00e1ndar de los programas indicados en las directivas ExecStart =, y ExecStop =. El valor \"null\" representa el destino / dev / null. El valor \"tty\" representa un terminal (ya sea de tipo virtual - / dev / ttyX- o pseudo - / dev / pts / X-), el cual deber\u00e1 ser especificado mediante la directiva TTYPath = . El valor \"journal\" es el valor por defecto (es decir, que si el programa en cuesti\u00f3n imprimiera algo en la pantalla del terminal al ejecutarse en primer plano, esta salida se redireccionar\u00e1 el Journal en ejecutarse v\u00eda un archivo .service). El valor \"socket\" sirve para indicar que la salida debe enviarse al socket asociado al servidor con el fin de viajar al otro extremo de la comunicaci\u00f3n (ver m\u00e1s adelante).\n\n\n\n\nNOTA\n\n\nNOTA: El hecho de que por defecto la salida est\u00e1ndar vaya a parar en el Journal se puede cambiar de forma general para todas las Units en la directiva DefaultStandardOutput del archivo \n/etc/systemd/system.conf\n\n\n\n\n\n\nNOTA\n\n\nTambi\u00e9n existe la directiva StandardError = {null | tty | journal | socket} , similar a StandardOutput = pero para la salida de error\n\n\n\n\n\n\n\n\nEJERCICIOS\n\uf0c1\n\n\nTodos los ejercicios se har\u00e1n en una m\u00e1quina virtual donde el usuario pueda tener permisos de administrador:\n\n\n\n\n\n\nA) Ejecutar \nsystemctl list-Units -t service | grep ufw\n (si est\u00e1s en Ubuntu) o \nsystemctl list-Units -t service | grep firewalld\n (si est\u00e1 en Fedora). \u00bfQu\u00e9 significa la palabra \"loaded\"? Y \"active\"? Confirma esto ejecutando \nsystemctl status ufw / systemctl status firewalld\n\n\nB) Ahora enmascara la Unit ufw / firewalld. \u00bfQu\u00e9 pasa realmente cuando s'enmascara una Unit? Pista: consulte donde apunta el reci\u00e9n creado archivo \n/etc/systemd/system/ufw.service\n (o \n/etc/systemd/system/firewalld.service\n)\n\n\nC) Ejecutar systemctl list-Units -t service | grep ufw (o systemctl list-Units -t service | grep firewalld ) de nuevo.\n\u00bfPor qu\u00e9 todav\u00eda aparece la palabra \"active\"? Confirma esto ejecutando \nsystemctl status ufw\n / \nsystemctl status firewalld\n\n\nD) Si ahora ejecutas \nsystemctl stop ufw\n (o \nsystemctl stop firewalld\n ) , \u00bfqu\u00e9 muestra \nsystemctl list-Units -t service | grep ufw (o systemctl list-Units -t service | grep firewalld\n )? \u00bfPor qu\u00e9? \u00bfQu\u00e9 deber\u00edas hacer para que vieras algo? Pista: usa el par\u00e1metro --all\n\n\nE) Ejecutar el comando systemd-delta . \u00bfQu\u00e9 significa la relaci\u00f3n indicada entre los dos archivos que aparecen en la l\u00ednea [Masked]? \u00bfY entre los dos archivos que aparecen en las l\u00edneas [EXTENDED]?\n\n\n\n\nNOTA\n\n\nTambi\u00e9n podr\u00eda haber alguna pareja de archivo en l\u00edneas [overrides] o incluso [EQUIVALENTE]\n\n\n\n\nF) Intenta iniciar el Unit ufw (o firewalld) todav\u00eda Enmascarado. Puedes? Desenmascara y vuelve a intentarlo. puedes ahora?\n\n\nG) Ejecutar el comando \nsystemctl edit ufw\n (o \nsystemctl edit firewalld\n ) y, en el editor de texto que aparece, escribe la l\u00ednea Description = Hola amigo y guarda. A continuaci\u00f3n, ejecuta systemctl cat ufw (o systemctl cat firewalld ) . \u00bfQu\u00e9 ves? Y si vuelves a ejecutar systemd-delta ?\n\n\n\n\n\n\nA) Crear un archivo llamado \n/etc/systemd/system/pepe.service\n con el siguiente contenido ...:\n\n\n\n\n\n\n[Unit]\nDescription = Pepe se colega\n[Service]\nType = oneshot\nExecStart = / bin / ls -l\nExecStop = / bin / df -h\n[Install]\nWantedBy = multi-user.target\n\n\n\n\n... y a continuaci\u00f3n (despu\u00e9s de \nsystemctl daemon-reload\n) ejecuta \nsystemctl start pepe\n Qu\u00e9 ves? Y si haces \njournalctl -e\n, \u00bfqu\u00e9 ves? \u00bfPor qu\u00e9?\n\n\nB)  \u00bfQu\u00e9 deber\u00edas modificar del archivo anterior para que el comando \n/bin/df -h\n no se ejecutara justo despu\u00e9s de \n/bin/ls -l\n sino s\u00f3lo cuando se escriba \nsystemctl stop pepe\n ? Pista: consulta la explicaci\u00f3n del tipo \"oneshot\" en la teor\u00eda. Pru\u00e9balo utilizando los comandos \nsystemctl -full edit pepe\n, \nsystemctl daemon-reload\n y, de nuevo, \njournalctl -e\n\n\nC) Para qu\u00e9 sirve la l\u00ednea \nWantedBy = ...\n ? O dicho de otro modo: \u00bfqu\u00e9 relaci\u00f3n tiene esta l\u00ednea con el comando \nsystemctl enable\n ? Pista: observa el contenido de la carpeta \n/etc/systemd/system/multi-user.target.wants\n\n\nD) \u00bfQu\u00e9 deber\u00edas modificar del archivo anterior para que la salida de los comandos ejecutadas por la Unit (ya sea \u200b\u200ba ExectStart = o a ExecStop =) no vaya a parar al Journal sino que se visualice el terminal / dev / tty4? Pru\u00e9balo.\n\n\n3.-a) Crear un script llamado \n/opt/yeah\n con el siguiente contenido (y dale permisos de ejecuci\u00f3n):\n\n\n#!/bin/bash\nwhile [[true]]\ndo\ncurl -s ipinfo.io/ip\n/ Bin / sleep 3```\nd\u00e9\n\n\n\n\nb) Crear un archivo llamado \"/etc/systemd/system/pepa.service\" con el siguiente contenido ...:\n\n\n[Unit]\nDescription = Pepa se colega\n[Service]\nType = simple\nExecStartPre = / usr / bin / systemd-cat -t PEPA -p grito echo \"Empieza\"\nExecStart = / opt / yeah\nExecStop = / usr / bin / systemd-cat -t PEPA -p grito echo \"Termino\"\n# StandardOutput = null\n[Install]\nWantedBy = multi-user.target\n\n\n\n\n... y a continuaci\u00f3n (despu\u00e9s de \nsystemctl daemon-reload\n) ejecuta \nsystemctl start pepa\n. Si haces \njournalctl -f\n, que ves? \u00bfPor qu\u00e9? Y si ejecutas \nsystemctl stop pepa\n , que ves entonces en el Journal? \u00bfPor qu\u00e9? Y si Descomentas la l\u00ednea que aparece comentada y vuelves a probar?\n\n\n4.-a) Crear un archivo llamado \"fiufiu.service\" dentro de \"/ etc/systemd / system\" con el siguiente contenido ...:\n\n\n[Unido]\nDescription = All we are saying is give peace a chance\n[Service]\nType = simple\nExecStart = /usr/bin/nc -l -p 5555\nRestart = on-success\n\n\n\n\n... y seguidamente ponerlo en marcha con el comando \nsudo systemctl start fiufiu\n . Comprueba con \nsystemctl status fiufiu\n (o tambi\u00e9n con \nss -tnl\n ) que se haya iniciado correctamente\n\n\nb) Ejecutar el comando \njournalctl -ef\n y seguidamente, abre otro terminal para ejecutar en ellos el comando \nnc 127.0.0.1 5555\n . Escribe algo la conexi\u00f3n abierta para este cliente Netcat y observa a la vez lo que aparece en tiempo real en el Journal. \u00bfQu\u00e9 pasa? \u00bfPor qu\u00e9?\n\n\nc) Cerrar el cliente y vuelve a ejecutar. \u00bfEl servicio sigue funcionando? Ahora comenta la l\u00ednea Restart = ... que aparece en el archivo fiufiu.service, reinicia el servicio y vuelve a ejecutar el cliente un par de veces. la primera\nvez deber\u00e1 conectarse sin problemas como siempre pero la segunda ya no. \u00bfPor qu\u00e9?\n\n\n5.-a) Instal.la el paquete \"apache2\" y observa, ejecutando el comando \nsystemctl cat apache2\n , el valor que tiene la directiva Restart =. Ejecuta entonces \nsystemctl --signal = 9 kill apache2\n y comprueba con systemctl status\napache2 si el servicio reinicia solo o no. \u00bfPor qu\u00e9 pasa lo que pasa?\n\n\nb) Cambiar ahora el valor de la directiva Restart = del Unit del Apache2 mediante \nsystemctl edit --full apache2\n para que valga \"no\" (recuerda que escribir como primera l\u00ednea el t\u00edtulo de la secci\u00f3n a la que pertenece la directiva que quieres sobreescribir -es decir, [Service] -). Despu\u00e9s de hacer \nsystemctl daemon-reload\n (y de comprobar que la modificaci\u00f3n es efectiva con \nsystemd-delta\n o tambi\u00e9n \nsystemctl cat apache2\n) , inicia el servicio de nuevo y comprueba que efectivamente est\u00e9 iniciado. Vuelve a matar de nuevo con \nsystemctl -signal = 9 kill apache2\n y vuelve a comprobar de nuevo si el servicio ha reiniciado autom\u00e1ticamente o no. \u00bfQu\u00e9 pasa ahora?\n\n\nc) Agregar mediante \nsystemctl edit apache2\n la l\u00ednea necesaria para llamar a una Unit que se encargue ejecutarse en el modo \"oneshot\" el comando \nplay /ruta/un/fitxer.mp3\n cada vez que el Apache finalice debido a alguna situaci\u00f3n inesperada (como por ejemplo ser\u00eda una se\u00f1al kill 9)\n\n\n\n\nNOTA\n\n\nEl comando play encarga de reproducir el archivo de sonido indicado y admite muchos formatos posibles, no s\u00f3lo mp3. Forma parte del paquete \"sox\"\n\n\n\n\n6.a) Ejecuta \nsystemctl disable ufw\n (o \nsystemctl disable firewalld\n ) y seguidamente \nsystemctl show --property \"Wants\" multi-user.target | grep -E \"(ufw | firewalld)\n\" \u00bfQu\u00e9 ves? \u00bfPor qu\u00e9? Pista: observa el mensaje que\naparece en pantalla al deshabilitar el servicio ufw\n\n\nb) Y si ahora ejecutas \nsystemctl enable ufw\n (o \nsystemctl enable firewalld\n ) y vuelves a ejecutar el mismo comando? \u00bfQu\u00e9 ves ahora? \u00bfPor qu\u00e9? Pista: observa el contenido de la carpeta /etc/systemd/system/multi-user.target.wants\n\n\nc) Deduce y di por qu\u00e9 la l\u00ednea After = de la Unit ufw.service (o firewalld.service) tiene el valor que tiene.\n\n\nd) systemd puede no ser el proceso INIT de nuestro sistema Linux: aunque sea el m\u00e1s extendido con diferencia, te puedes encontrar distribuciones que utilicen sistemas INIT alternativos. Dime, de los siguientes comandos,\ncu\u00e1les sirven para comprobar si el proceso INIT de tu sistema es systemd (o no):\n\n\n\n\nfile /sbin/init\n\n\nman init\n\n\npgrep ^systemd $\n\n\n\n\nSystemd (II)\n\uf0c1\n\n\ntargets\n\uf0c1\n\n\nPodemos definir un \"target\" como un \"estado\" del sistema definido por un determinado conjunto de servicios puestos en marcha (y otros que no). La idea es que, al arrancar el sistema, se llegue a un determinado \"target\" (Y, opcionalmente, a partir de all\u00ed, poder pasar a otro si fuera necesario). A continuaci\u00f3n se listan los \"targets\" m\u00e1s importantes (todos ellos ubicados dentro de \n/usr/lib/systemd/system\n):\n\n\n\n\npoweroff.target\n (o \"runlevel0.target\") Si se llega a este \"target\", se apaga el sistema\n\n\nreboot.target\n (o \"runlevel6.target\"): Si se llega a este \"target\", se reinicia el sistema\n\n\nrescue.target\n (o \"runlevel1.target\"): Si se llega a este \"target\", se inicia el sistema en modo texto,sin red y s\u00f3lo por el usuario root. Ser\u00eda similar a otro target llamado \" emergency.target \", pero el \"emergency\" es m\u00e1s \"radical\" que el \"rescate\" porque gracias a montar la partici\u00f3n ra\u00edz en modo s\u00f3lo lectura permite arrancar sistemas que el \"rescate\" quiz\u00e1s no puede.\n\n\nmulti-user.target\n (o \"runlevel3.target\"): En este caso se inicia el sistema en modo texto pero con red y multiusuario (el target predeterminado en servidores)\n\n\ngraphical.target\n (o \"runlevel5.target\"): En este caso, se inicia el sistema en modo gr\u00e1fico con red y multiusuario (el target por defecto en sistemas de escritorio) Implica haber pasado por el target \"multi-user\" previamente.\n\n\n\n\nOtros targets predefinidos que se instalan con systemd y que hay que conocer son:\n\n\n\n\n\n\nctrl-alt-del.target\n Target activado cuando es pulsado CTRL + ALT + SUPR. Por defecto es un enlace a \"reboot.target\"\n\n\n\n\n\n\nsysinit.target\n Target que ejecuta los primeros scripts de arranque\n\n\n\n\n\n\nsockets.target\n Target que activa, al arrancar, todas las Units de tipo \"socket\". Se recomienda, por tanto, que todos los archivos de configuraci\u00f3n de una Unit \"socket\" tengan a su l\u00ednea Wants = este target indicado (o bien WantedBy =)\n\n\n\n\n\n\ntimers.target\n Target que activa, al arrancar, todas las Units de tipo \"timer\". Se recomienda, por tanto, que todos los archivos de configuraci\u00f3n de una Unit \"timer\" tengan a su l\u00ednea Wants = este target indicado (o bien WantedBy =)\n\n\n\n\n\n\npaths.target\n Target que activa, al arrancar, todas las Units de tipo \"path\". Se recomienda, por tanto, que todos los archivos de configuraci\u00f3n de una Unit \"path\" tengan a su l\u00ednea Wants = este target indicado (o bien WantedBy =)\n\n\n\n\n\n\nswap.target\n Target que habilita la memoria swap\n\n\n\n\n\n\nbasic.target\n Target que pone en marcha todos los target relacionados con puntos de montaje, memorias swaps,paths, timers, sockets y otras unidades b\u00e1sicas necesarias para el funcionamiento del sistema.\n\n\n\n\n\n\ninitrd-fs.target\n El generador systemd-fstab-generator a\u00f1ade autom\u00e1ticamente las Units indicadas en la directiva Before = de esta Unit a la Unit especial \"sysroot-usr.mount\" (adem\u00e1s de todos los puntos de montaje existentes en \n/etc/fstab\n que tengan establecidas las opciones \"auto\" y \"X-initrd.mount\"). Ver m\u00e1s adelante una explicaci\u00f3n de las Units de tipo mount.\n\n\n\n\n\n\ninitrd-root-fs.target\n El generador systemd-fstab-generator a\u00f1ade autom\u00e1ticamente las Units indicadas en la directiva Before = de esta Unit a la Unit especial \"sysroot-usr.mount\", la cual es generada a partir de los par\u00e1metros del kernel. Lo estudiaremos m\u00e1s adelante\n\n\n\n\n\n\nlocal-fs.target\n El generador systemd-fstab-generator a\u00f1ade autom\u00e1ticamente las Units indicadas en la directiva Before = de esta Unit a todas las Units de tipo \"mount\" que se refieren a puntos de montaje locales. Tambi\u00e9n a\u00f1ade a este target las dependencias de tipo Wants = correspondientes a los puntos de montaje existentes en /etc/fstab que tienen la opci\u00f3n \"auto\" establecida. Ver m\u00e1s adelante una explicaci\u00f3n de las Units de tipo mount.\n\n\n\n\n\n\nnetwork-online.target\n Target que se activa autom\u00e1ticamente en cuanto el subsistema de red es funcional.Cualquier servicio que tenga que trabajar en red se deber\u00e1 iniciar al menos en este target\n\n\n\n\nNOTA\n\n\nExiste otro tarjet relacionado con la red llamado \"pre-network.target\" que est\u00e1 pensado para iniciar servicios antes de que cualquier tarjeta de red se configure. Su prop\u00f3sito principal es hacerlo servir con servicios de tipo cortafuegos, para establecer las reglas antes de que la configuraci\u00f3n de red funcione. Estos servicios deber\u00e1n tener una l\u00ednea Before = network-pre.target y tambi\u00e9n una l\u00ednea Wants = network-pre.target en su archivo de configuraci\u00f3n \n\n\n\n\n\n\nNOTA\n\n\nExiste otro tarjet relacionado con la red llamado simplemente \"network.target\" que s\u00f3lo indica que el stack software de red ya se ha cargado en memoria pero esto no implica que las interfaces se hayan configurado todav\u00eda. este target est\u00e1 m\u00e1s pensado para el proceso de apagado de la m\u00e1quina para realizar este proceso de forma ordenada: pues la orden de apagado es al rev\u00e9s que el de arranque, cualquier Unit que tenga una l\u00ednea After = network.target apagar\u00e1 antes que la red se descargue y esto har\u00e1 que esta Unit apague sin interrumpir ninguna conexi\u00f3n que est\u00e9 pendiente\n\n\n\n\n\n\n\n\nprinter.target\n Target que se activa autom\u00e1ticamente tan pronto como una impresora es enchufada o aparece disponible durante el arranque. Aqu\u00ed donde se suele iniciar, por ejemplo, el servicio Cups.\n\n\n\n\n\n\nsound.target\n Target que se activa autom\u00e1ticamente tan pronto como una tarjeta de audio es enchufada o aparece disponible durante el arranque.\n\n\n\n\n\n\nbluetooth.target\n Target que se activa autom\u00e1ticamente tan pronto como un controlador Bluetooth es enchufado o aparece disponible durante el arranque.\n\n\n\n\n\n\nsmartcard.target\n Target que se activa autom\u00e1ticamente tan pronto como un controlador Smartcard es enchufado o aparece disponible durante el arranque.\n\n\n\n\n\n\nsystem-update.target\n Target especial utilizada para actualizaciones del sistema. El generador systemd-System- update-generator redireccionar\u00e1 el proceso de arranque autom\u00e1ticamente a este target si la carpeta /system-update existe\n\n\n\n\n\n\numount.target\n Target que desmonta todos los puntos \"mount\" y \"automount\" durante el apagado del sistema \n\n\n\n\n\n\nfinal.target\n Target utilizado durante el apagado del sistema que puede utilizarse para apagar los \u00faltimos servicios despu\u00e9s de que los servicios \"normales\" ya se han detenido y los puntos de montaje se han desmontado.\n\n\n\n\n\n\nPara saber el target donde nos encontramos en este momento podemos hacer: \nsystemctl get-default\n\n\nHay que tener en cuenta que m\u00faltiples targets pueden estar activados a la vez. Un target activado indica que systemd ha intentado iniciar todas las Units asociadas a este target. Esto significa que el comando anterior s\u00f3lo nos dice cu\u00e1l es el target \"final\" donde hemos llegado, pero a lo largo del camino desde el arranque de la m\u00e1quina hasta llegar a este target \"final\" se han ido activando diferentes targets a modo de \"escalones\" intermedios. para\nver todos los targets activados, hay que hacer \nsystemctl list-Units -type = target\n\n\nSe puede cambiar el target actual a otro simplemente ejecutando: \nsystemctl Isolate nomTargetDesti.target\n \n\n\nPara cambiar el target por defecto donde ir\u00e1 a parar autom\u00e1ticamente a cada arranque del sistema se puede hacer: \nsystemctl set-default nomTargetDefecte.target\n\n\n\n\nNota\n\n\nEl comando anterior, en realidad lo \u00fanico que hace es revincular el link \"/etc/systemd/system/default.target\" en el archivo * .Target adecuado.\n\n\n\n\n\n\nNota\n\n\nOtra manera de entrar al final del arranque del sistema en un determinado target predeterminado es a\u00f1adir la l\u00ednea systemd.unit = nomTargetDestino.target a la lista de par\u00e1metros del kernel indicada en la configuraci\u00f3n del gestor de arranque. Hay una serie de comandos espec\u00edficos para pasar a determinados estados (poweroff, reboot, etc) que se pueden usar en vez del comando systemctl Isolate gen\u00e9rica. Por ejemplo:\n    \nsudo systemctl rescue\n : Similar a \nsystemctl Isolate rescue.target\n\n    \nsudo systemctl poweroff\n (o \nsudo poweroff\n a secas): Similar a -  \nsystemctl Isolate poweroff.target\n\n    sudo systemctl reboot (o sudo reboot a secas): Similar a systemctl Isolate reboot.target\n\n\n\n\nSi se quiere detener (-P) o reiniciar (-r) la m\u00e1quina en un momento futuro determinado (hh: mm), entonces habr\u00e1 que ejecutar el comando: \nsudo shutdown {-P | -r} hh: mm\n\n\nSi se quiere detener (-P) o reiniciar (-r) la m\u00e1quina dentro de una cierta cantidad de minutos, entonces habr\u00e1 que ejecutar el comando: \nsudo shutdown {-P | -r} + m\n\n\n\n\nNota\n\n\nDentro de la carpeta \n/usr/lib/systemd/system-shutdown\n pueden haber archivos * .shutdown, que son scripts ejecutables que se ejecutar\u00e1n justo antes del apagado / reinicio del sistema (es decir, justo al poner en marcha los servicios \"poweroff.service\" o \"Reboot.service\"). Quien ejecutar\u00e1 estos scripts es el binario /usr/lib/systemd/systemd-shutdown, el cual es invocado siempre por estos servicios, que lo colocan como PID 1 y es el responsable de desmontar los sistemas de ficheros, deshabilitar la swap, matar los procesos que queden pendientes, etc. En los scripts ejecutados por /usr/lib/systemd/systemd-shutdown podemos utilizar un par\u00e1metro ($1) que puede valer \"poweroff\" o \"reboot\" dependiendo de la acci\u00f3n que realizar\u00e1 y que nos podr\u00eda servir para distinguir qu\u00e9 queremos que haga este script seg\u00fan la acci\u00f3n indicada. Todos los scripts se ejecutan en paralelo. Hay que tener en cuenta, finalmente, que el sistema de ficheros en ese momento permanece montado pero en modo s\u00f3lo lectura.\n\n\n\n\n\n\nNota\n\n\nEn el comando systemctl reboot le podemos a\u00f1adir varios par\u00e1metros interesantes, los cuales s\u00f3lo funcionan, sin embargo, en sistemas UEFI que han arrancado mediante el gestor de arranque systemd-boot:\n\n\n\n\n--firmware-setup : INDICATE to the system s firmware to reboot into the firmware setup interface (aka the \"UEFI control panel\")\n\n\n--boot-loader-menu = n\u00basegons : INDICATE to the system s boot loader to show the boot loader menu on the following boot the number of seconds specified as value. Pass 0 value in order to disable the menu timeout.\n\n\n-boot-loader-entry = entryID : INDICATE to the system s boot loader to boot into a specific boot loader entry on the following boot.\n\n\n\n\n\n\nLo que hacen los par\u00e1metros anteriores es modificar determinados valores de variables EFI concretas (tal como se podr\u00eda haber hecho tambi\u00e9n con el comando efibootmgr ) para as\u00ed modificar el comportamiento de la UEFI el pr\u00f3ximo arranque\n\n\nPor otra parte, con el comando sudo systemctl suspend podemos suspender el sistema (o dicho de otro manera, nos permiten llegar al target suspend.target\") y con el comando sudo systemctl hibernate la\npodemos poner a hibernar (o dicho de otro modo, permiten llegar al target \"hibernate.target\").\n\n\n\"Suspender\" significa que se guarda todo el estado del sistema en la RAM y se apaga la mayor\u00eda de dispositivos de la m\u00e1quina; cuando se pone en marcha de nuevo, el sistema restaura su estado previo de la RAM sin tener que reiniciarse\nde nuevo: este proceso es muy r\u00e1pido pero tiene el inconveniente de que obliga a mantener con alimentaci\u00f3n el\u00e9ctrica la m\u00e1quina todo el tiempo. \n\n\n\"Hibernar\" significa que se guarda todo el estado del sistema en el disco duro (si tiene espacio libre) y se apaga por completo la m\u00e1quina: cuando se pone en marcha de nuevo, el sistema restaura su estado previo desde el disco duro sin tener que reiniciar de nuevo: este proceso es bastante lento pero tiene la ventaja de no tener que mantener con alimentaci\u00f3n el\u00e9ctrica la m\u00e1quina.\n\n\n\n\nNota\n\n\nDentro de la carpeta \"/ usr / lib / systemd / system-sleep\" pueden haber archivos * .sleep, que son scripts ejecutables que se ejecutar\u00e1n justo antes de la hibernaci\u00f3n o suspensi\u00f3n del sistema (es decir, justo en poner en marcha internamente los servicios \"systemd-hibernate.service \"o\" systemd-suspend.service \", los cuales, por cierto, nunca deben ser invocados directamente con systemctl start ... sino utilizando los comandos explicadas en el p\u00e1rrafo anterior: systemctl hibernate o systemctl suspend ). Quien ejecutar\u00e1 estos scripts es el binario / usr / lib / systemd / systemd-sleep, el cual es invocado siempre por estos servicios y admite dos par\u00e1metros que podemos utilizar en estos scripts como $ 1 y $ 2 respectivamente. El primer par\u00e1metro puede valer \"pre\" o \"post\" dependiendo de si la m\u00e1quina est\u00e1 yendo a la suspensi\u00f3n / hibernaci\u00f3n o est\u00e1 volviendo, respectivamente. El segundo par\u00e1metro puede valer \"suspend\" o \"hibernate\" dependiendo de la acci\u00f3n que realizar\u00e1 y que nos podr\u00eda server para distinguir qu\u00e9 queremos que haga este script seg\u00fan la acci\u00f3n indicada. Todos los scripts ejecutan en paralelo.\n\n\n\n\nSi se quiere realizar una tarea larga y asegurarse de que la m\u00e1quina no se suspender\u00e1 o apagar\u00e1 mientras tanto,\nse puede invocar el comando correspondiente a esta tarea as\u00ed: systemd-inhibido comanda_llarga El comando\nsystemd-inhibido --list muestra las tareas que tienen este truco en marcha. Si se quiere especificar una acci\u00f3n\nconcreta a inhibir se puede indicar con el par\u00e1metro - what = acci\u00f3n , donde \"acci\u00f3n\" puede ser por ejemplo la palabra\n\"Shutdown\" o \"sleep\" (equivalente a hibernaci\u00f3n o suspensi\u00f3n), entre otros. Encontrar\u00e1 m\u00e1s informaci\u00f3n en los\nprimeros p\u00e1rrafos de https://www.freedesktop.org/wiki/Software/systemd/inhibit/\nPara que el inicio con systemctl start de un determinado servicio (o target) se produzca dentro de un target\ndeterminado -llamado-el \"a.target\" - desde el propio archivo de configuraci\u00f3n del servicio en cuesti\u00f3n hay que escribir\nlas directivas Wants = a.target, Requires = a.target y / o After = a.target (estas directivas se aseguran de llegar\nprimero al target \"a.target\" para iniciar entonces el servicio en cuesti\u00f3n). Por otra parte, tambi\u00e9n existe la directiva\nConflicts = a.target , la que se asegura de no estar en el target \"a.target\" para poder iniciar el servicio en cuesti\u00f3n.\nEn el caso de querer iniciar siempre un servicio determinado autom\u00e1ticamente en el target \"a.target\", entonces\nhabr\u00e1 que escribir adem\u00e1s las directivas WantedBy = a.target o RequiredBy = a.target del archivo de configuraci\u00f3n del\nservicio (en este \u00faltimo caso, al hacer systemctl enable nomServei se crea un enlace a su archivo de configuraci\u00f3n\ndentro de \"/lib/systemd/system/a.target.wants\").\nLos archivos de configuraci\u00f3n de los targets s\u00f3lo tienen secciones [Unido] (y muy pocas la secci\u00f3n\n[Install]). En este sentido, es interesante consultar los archivos correspondientes, por ejemplo, a multi-user.target\no graphical.target: s\u00f3lo encontramos las directivas Description, Documentation, Wants, Requires, After,\nConflicts y AllowIsolate (ya partir de ellas podemos deducir las dependencias que hay entre targets ... aunque\npor eso hay comandos espec\u00edficos que enseguida veremos).\n\n\nEJERCICIOS:\n\uf0c1\n\n\n\n\n\n\nCrear un target nuevo llamado \"manolo.target\" donde el sistema deber\u00e1 entrar justo despu\u00e9s de activar graphical.target (es decir, debe ser el \u00faltimo target al activarse). La idea ser\u00e1 asegurarte de que entras en este target para ejecutar un determinado servicio (lo llamaremos \"manolo.service\") el \u00faltimo de todos. para hacer esto, tienes que hacer lo siguiente:\n\n\nA) Crear un nuevo fichero llamado \"/etc/systemd/system/manolo.target\" con el siguiente contenido:\n\n\n[Unit]\nDescription = Manolo is kind\nDocumentation = http: //www.lecturas.com\nRequires = graphical.target\nAfter = graphical.target\nConflicts = rescue.service rescue.target\nAllowIsolate = yes\n\n\n\nB) Crear un nuevo fichero llamado \"/etc/systemd/system/manolo.service\" con el siguiente contenido:\n\n\n[Unit]\nDescription = Manolo is soberbio\nDocumentation = http: //www.hola.com\nRequires = manolo.target\nAfter = manolo.target\n[Service]\nExecStart = / usr / bin / printf \"MANOLO \\ n\"\nRemainAfterExit = yes\n[Install]\nWantedBy = manolo.target\n\n\n\nC) Ejecutar systemctl enable manolo.service y reinicia la m\u00e1quina. \u00bfCrees que el servicio \"manolo\" estar\u00e1 funcionando autom\u00e1ticamente o no? \u00bfPor qu\u00e9 lo crees? Compru\u00e9balo ejecutando el comando \nsystemctl status manolo.service\n (o tambi\u00e9n observando si aparece la palabra \"MANOLO\" en el Journal). PISTA: La respuesta de porque el servicio \"manolo\" estar\u00e1 funcionando (o no) se encuentra en lo que muestra el comando \nsystemctl list-Units -t target | grep \"manolo\"\n y en entender el significado de la l\u00ednea WantedBy =\n\n\nD) A continuaci\u00f3n ejecuta systemctl start manolo.service . Despu\u00e9s de observar que el servicio se haya puesto en marcha\ncorrectamente (en la salida del comando systemctl status manolo.service o tambi\u00e9n observando si aparece la\npalabra \"MANOLO\" en el Journal), \u00bfcrees que el comando systemctl list-Units -t target | grep \"manolo\"\nmostrar\u00e1 algo diferente respecto del apartado anterior? \u00bfPor qu\u00e9 lo crees? PISTA: La respuesta se encuentra en\nentender el significado de las l\u00edneas Requires = y After = del archivo \"manolo.service\"\n\n\ne) Ejecutar systemctl set-default manolo.target y vuelve a reiniciar la m\u00e1quina. \u00bfCrees que el servicio \"manolo\" ahora estar\u00e1 funcionando autom\u00e1ticamente o no? \u00bfPor qu\u00e9 lo crees? Compru\u00e9balo ejecutando el comando systemctl status manolo.service (o tambi\u00e9n observando si aparece la palabra \"MANOLO\" en el Journal). PISTA: La respuesta se encuentra en entender el significado de las l\u00edneas Requires = y After = del archivo \"manolo.target\"\n\n\n\n\n\n\nA) Entra en el target de rescate. \u00bfQu\u00e9 pasa?\n\n\nB) Entra en el target de suspensi\u00f3n. \u00bfQu\u00e9 pasa?\n\n\nC) Entra en el target multi-user. \u00bfQu\u00e9 pasa?\n\n\nD) Crear un script ejecutable dentro de la carpeta \"/usr/lib/systemd/system-sleep\" con el siguiente contenido ...:\n\n\n#! / Bin / bash\nif [[ \"$ 1\" == \"pre\"]]\nthen\necho \"we are suspending oro hibernating at $ (date) ...\"> / tmp / systemd_suspend_test\nElif [[ \"$ 1\" == \"post\"]]\nthen\necho \"... and we are back from $ (date)\" >> / tmp / systemd_suspend_test\nfin\n\n\n\n... y prueba a suspender el sistema y volver a \"despertar\". \u00bfQu\u00e9 pasar\u00e1?\n\n\n\n\n\n\ne) \u00bfPara qu\u00e9 sirve este programa: https://github.com/ryran/reboot-guard ?\n\n\nboot chain\n\uf0c1\n\n\nPara saber la jerarqu\u00eda de dependencias de targets para llegar a iniciar un target (o service!) Determinado se puede utilizar el comando: \nsystemctl list-dependencies nomTarget.target\n (o nomUnit.service )\n\n\n\n\nNota\n\n\nUna forma alternativa de obtener una informaci\u00f3n similar ser\u00eda ejecutando \nsystemctl show -p \"Wants\" nomTarget.target && systemctl show -p \"Requires\" nomTarget.target\n . Tambi\u00e9n se puede ejecutar \nsystemctl status\n Las dependencias mostradas se corresponden a Units que han sido \"required\" o \"wanted\" por las Units superiores. Las dependencias recursivas s\u00f3lo se muestran los targets intermedios; si se quieren ver tambi\u00e9n por los service, mounts paths, socket, etc intermedios hay que incluir el par\u00e1metro --all al comando anterior.\n\n\n\n\nTambi\u00e9n se pueden mostrar cu\u00e1les Units dependen para funcionar del correcto inicio de un target (o service!) determinado con el comando: \nsystemctl list-dependencias --reverse nomTarget.target\n (o nomUnit.service )\n\n\n\n\nNota\n\n\nUna forma alternativa de obtener una informaci\u00f3n similar ser\u00eda ejecutando \nsystemctl show -p \"WantedBy\" nomTarget.target && systemctl show -p \"RequiredBy\" nomTarget.target\n\n\n\n\nOtros par\u00e1metros interesantes de este comando son --before y - after , los cuales sirven para mostrar Units que dependen para funcionar del correcto inicio anterior o posterior de un target, respectivamente.\n\n\nPor otra parte, respecto al arranque del sistema podemos obtener una informaci\u00f3n m\u00e1s detallada sobre los tiempos que tarda cada Unit en cargarse y el orden en que lo hace gracias al comando systemd-analyze, tiene varias posibilidades\n\n\n\n\n\n\nsystemd-analyze\n : Muestra el tiempo total empleado en el arranque del sistema y qu\u00e9 parte de este tiempo ha sido\nempleado en tareas del kernel, qu\u00e9 parte en uso de initrd y qu\u00e9 parte en tareas de usuario\n\n\n\n\n\n\nsystemd-analyze blame\n : Muestra los tiempos disgregados por servicio. Hay que indicar que estos tiempos son \"en paralelo \", as\u00ed que la suma total que sale ser\u00e1 siempre muy superior al tiempo real empleado en el arranque.\n\n\n\n\n\n\nsystemd-analyze dot [nomTarget.target] | dot -T {png | svg} -o foto. {png | svg}\n : Genera una salida que si se pasa a la aplicaci\u00f3n \"dot\" (perteneciente al paquete \"GraphViz\") generar\u00e1 finalmente un gr\u00e1fico (En formato png o svg) donde se pueden visualizar todas las dependencias del target (o servicio!) indicado (o, si no se indica, del \"default.target\"; tambi\u00e9n se pueden indicar comodines en el nombre del target / servicio).\n\n\n\n\n\n\nsystemd-analyze plot [nomTarget.target]> something.svg\n : Genera un gr\u00e1fico donde se muestra los tiempos de ejecuci\u00f3n y de bloqueo de cada Unit durante el arranque hasta llegar al target (o servicio!) indicado (o, si no se indica, del \"default.target\")\n\n\n\n\n\n\nsystemd-analyze critical-chain [nomTarget.target]\n : Muestra el \u00e1rbol de dependencias bloqueantes por target (o servicio!) indicado. El tiempo mostrado despu\u00e9s de \"@\" indica el tiempo que hace que la Unit est\u00e1 activa; el tiempo\nmostrado despu\u00e9s de \"+\" indica el tiempo que la Unit ha tardado en activarse.\nOtras opciones del comando \nsystemd-analyze\n son syscall-filter, verify, dump, log-level, security, time ...Se puede ver si, una vez iniciado el sistema, a\u00fan quedan tareas pertenecientes al arranque para completar ejecutando el comando \nsystemctl list-jobs\n\n\n\n\n\n\nEJERCICIOS:\n\uf0c1\n\n\n1.- a) \u00bfQu\u00e9 targets deben haberse iniciado para que el servicio gdm se pueda poner en marcha? (esto lo puedes saber con el comando systemctl list-dependencies ... )\n\n\nb) Ejecutar el comando systemctl \nlist-dependencies --reverse gdm.service\n Qu\u00e9 ves?\n\n\nc) \u00bfQu\u00e9 hace el comando tree / etc / systemd / system y para qu\u00e9 podr\u00eda servirte?\n\n\n2.-a) Ejecutar systemd-analyze plot ... y observa qu\u00e9 Unit bloquea m\u00e1s tiempo el arranque de tu sistema. prueba de desactivarla (esperemos no romper nada!) y reinicia. Ejecuta ahora systemd-analyze blame para comprobar si el\ntiempo total de arranque ha disminuido efectivamente.\n\n\nb) Instal.la el paquete \"GraphViz\" y genera un gr\u00e1fico Png con las dependencias del target multi-user. Haz una lista de las dependencias all\u00ed mostradas y adjunta la captura del gr\u00e1fico plantillas Una plantilla es un archivo de configuraci\u00f3n de tipo \"service\" que tiene la particularidad de permitir poner en marcha variantes de un mismo servicio sin tener que escribir un archivo \"service\" diferente para cada variante.\nB\u00e1sicamente, para utilizar una plantilla hay que hacer los siguientes pasos:\n1.- El archivo \"service\" que har\u00e1 de plantilla debe llamarse \"nomServei @ .service\". Es decir, hay que indicar\nel s\u00edmbolo arroba antes del punto\n2.- El contenido de este archivo plantilla puede ser exactamente igual que el de un archivo \"service\" est\u00e1ndar\n3.- A la hora de iniciar, parar, activar, desactivar, ver el estado, etc de una plantilla, se deber\u00e1 indicar\nel identificador concreto de la variante con la que queremos trabajar. Este identificador se establece la\nprimera vez que arranca la variante y simplemente consiste en una cadena entre la arroba y el punto,\nas\u00ed: systemctl start nomServei @ identificador. service A partir de aqu\u00ed, este identificador se har\u00e1\nservir de la misma manera por el resto de tareas relacionadas con la gesti\u00f3n de esta variante\nNOTA: An instance file is usually created as a symbolic link to the template file, with the link name including the instance\nidentifier. In this way, multiple links with unique Identifiers can point back to a single template file. When managing a\u00f1o\ninstance Unit, systemd will look for a file with the exact instance name you Specify on the command line to use but if it\ncan not find one, it will look for an associated template file.\n4.- La gracia de las plantillas es que el valor del identificador indicado en el punto anterior se puede utilizar\ndin\u00e1micamente dentro del contenido del archivo plantilla (concretamente mediante el s\u00edmbolo \" % y \"), de\nlo que seg\u00fan el valor que haya adquirido% y por esa variante se podr\u00eda poner en marcha el\nservicio escuchando en un puerto diferente (si% y representa un n\u00famero de puerto), o bien utilizando un archivo de\nconfiguraci\u00f3n diferente (si% y representa un nombre de archivo), o lo que nos convenga.\nNOTA: Otros s\u00edmbolos especiales que se pueden indicar en un archivo de configuraci\u00f3n de una plantilla pueden ser\n% p : representa the Unit name prefijo (this is the Portion of the Unit name that comes before the @ symbol)\n% n : representa the full resulting Unit name (% p plus% e)\n% u : The name of the user configured to run the Unit.\n% U : The same as above, but as a numeric UID instead of name.\n% H : The host name of the system that is running the Unit.\n%% : This is used to insert a literal percentage sign.\nPage 20\nPongamos un ejemplo. Imaginemos que tenemos un determinado servidor web que queremos ejecutar con dos\nconfiguraciones diferentes a la vez. La soluci\u00f3n ser\u00eda crear un archivo plantilla llamado por ejemplo\n\"Servidorweb @ .service\" con un contenido similar al siguiente:\n[Unido]\nDescription = My HTTP server\n[Service]\nType = simple\nExecStart = / usr / sbin / WebServer --config-file /etc/%i.conf\n[Install]\nWantedBy = multi-user.target\nCon este archivo, se podr\u00eda iniciar entonces el servidor dos veces, cada una indicando el nombre del archivo de\nconfiguraci\u00f3n deseado, as\u00ed:\nsudo systemctl start servidorweb@config1.service\nsudo systemctl start servidorweb@config2.service\nLos comandos anteriores lo que har\u00e1n ser\u00e1 ejecutar, respectivamente, los comandos: / usr / sbin / WebServer -\nconfig-file /etc/config1.conf y / usr / sbin / WebServer -config-file /etc/config2.conf\nEJERCICIOS:\n1.-a) Crear un archivo plantilla que permita poner en marcha diferentes servidores Ncat de forma permanente\n(Recuerda el par\u00e1metro -k) escuchando cada uno de ellos en un puerto diferente.\nNOTA: Deber\u00e1s instalar el paquete \"nmap\" para disponer del comando ncat\nb) Iniciar un servidor Ncat a partir de la plantilla anterior escuchando en el puerto 2.222 y otro escuchando en el puerto\n3333. Comprueba que, efectivamente, estos dos puertos est\u00e9n abiertos observando la salida del comando ss\n-tnl\nc) Conecta con el cliente Ncat a uno de los servidores anteriores y env\u00edale alg\u00fan mensaje. Cerrar el cliente (con\nCTRL + C) y ahora vuelve a ejecutarlo para conectar al otro servidor; vuelve a enviarle alg\u00fan otro mensaje y\nci\u00e9rralo de nuevo. Observa las \u00faltimas l\u00edneas del Journal: \u00bfqu\u00e9 ves?\n2.- Lee el siguiente p\u00e1rrafo y seguidamente contesta:\nWhen the user switches consolas using Ctrl + Alt + F2, Ctrl + Alt + F3, and so on, a new terminal then is spawned. in this\ncase systemd callos a service named getty @ .service providing the appropriate argumento such as tty2 oro tty3 to the Unit\nfile. The% y identifier provides this argumento value to the agetty binary sonido the terminal starts on that new console (as it\ncan seen in ExecStart = line from template file).\na) Para qu\u00e9 sirve el comando agetty? Busca en su p\u00e1gina del manual que hace su par\u00e1metro -ay\na\u00f1\u00e1delo a la invocaci\u00f3n del comando escrita a la l\u00ednea ExecStart de dentro del archivo getty @ .service (recuerda\nde ejecutar sudo systemctl daemon-reload justo despu\u00e9s). \u00bfQu\u00e9 pasa ahora cuando pulses Ctrl + Alt + F2, etc?\nb) enmascarado la instancia tty5 de la plantilla getty @ .service. \u00bfQu\u00e9 pasa ahora si haces Ctrl + Alt + F5?\nNOTA: Es posible que tambi\u00e9n hayas de enmascarar la plantilla autovt @ .service para que funcione el ejercicio\nNOTA: Hay otras maneras m\u00e1s sofisticadas de desactivar terminales virtuales pero las veremos m\u00e1s adelante\nc) \u00bfQu\u00e9 te muestra el comando systemctl status getty @ * ?\nPage 21\n3.- Supone que tienes un archivo llamado \"/etc/systemd/system/pepe@.service\" con el siguiente contenido:\n[Unido]\nDescription = lerele\n[Service]\nType = oneshot\nExecStart = / usr / local / bin / systemd-email% y admin@elpuig.xeill.net\nUser = nobody\nGroup = systemd-journal\ndonde \"systemd-email\" es un bash shell script escrito por nosotros dise\u00f1ado para enviar correos (suponiendo que\ntenemos un servidor Postfix o similar configurado en la m\u00e1quina) que tiene el siguiente c\u00f3digo:\n\n\n! / Bin / bash\n\uf0c1\n\n\nsystemctl status -full \"$ 1\" | mail -s \"$ 1\" $ 2\ny supone que has a\u00f1adido la l\u00ednea OnFailure=pepe@%i.service en la secci\u00f3n [Unido] del archivo \".service\"\ncorrespondiente al / los servicio / s que quiere monitorear.\na) \u00bfCu\u00e1l comando deber\u00edas ejecutar para poner en marcha una instancia del servicio-plantilla pepe @ que\nse encargan de enviar mails en el momento que el servicio Cups falle?\nsockets\nUn aspecto muy interesante de systemd es que permite que un servidor no est\u00e9 permanentemente\nencendido sino que s\u00f3lo arranque \"bajo demanda\" (es decir, cuando detecte una conexi\u00f3n, normalmente externa).\nDe este modo, este servidor no consume m\u00e1s recursos que los m\u00ednimos imprescindibles, en el momento\njusto. Para lograr esto, lo que pasa es que s\u00ed hay un componente \"escuchando\" todo el rato posibles\nintentos de conexiones, pero este componente no es la Unit \"service\" en s\u00ed sino un \"perro guardi\u00e1n\" que\ns\u00f3lo despertar\u00e1 Unit \"service\" cuando sea necesario. Este \"perro guardi\u00e1n\" es la Unit de tipo \"socket\".\nCada archivo de configuraci\u00f3n de una Unit \"socket\" debe tener exactamente el mismo nombre que el archivo de\nconfiguraci\u00f3n de la Unit \"service\" que quiere despertar (es decir, si tenemos el servicio \"a.service\", el socket\ncorrespondiente deber\u00e1 llamarse \"a.socket\"). La idea es tener la Unit \"socket\" siempre encendido ( systemctl\nenable a.socket ) pero la Unit \"service\" no ( systemctl disable a.service ); cuando se detecte una conexi\u00f3n, el\n\"socket\" autom\u00e1ticamente encender\u00e1 la Unit \"service\" (esto se puede ver haciendo systemctl status a.service mientras\nexiste la conexi\u00f3n) y la apagar\u00e1 de nuevo pasado un determinado tiempo sin actividad (por defecto 5 minutos).\nObviamente, si par\u00e1ramos el \"socket\" ( systemctl stop a.socket ) o el deshabilit\u00e9ssim el pr\u00f3ximo reinicio ( systemctl\ndisable a.socket ) ya no habr\u00eda \"perro guardi\u00e1n\" atento y, por tanto, el servicio ya no se pondr\u00eda en marcha\nautom\u00e1ticamente.\nPara cambiar el puerto donde escucha un \"socket\" (entre otras cosas) hay que modificar la configuraci\u00f3n del\n\"Socket\" propiamente dicho y eso no depende de la configuraci\u00f3n del servidor en cuesti\u00f3n. Los archivos de configuraci\u00f3n\nde cada \"socket\" se pueden encontrar, como cualquier otra Unit, o bien dentro de la carpeta \"/ usr / lib / systemd / system\"\no bien dentro de \"/ etc / systemd / system\" y se puede utilizar igualmente el comando systemctl edit a.socket para\ngenerar archivos \"override\". La secci\u00f3n que nos interesa en estos tipos de ficheros es la secci\u00f3n [Socket] , lo\npuede contener alguna de las siguientes directivas m\u00e1s importantes:\nListenStream = [IP:] n\u00baport\nIndica el n\u00famero de puerto TCP por donde escuchar\u00e1 el socket. Opcionalmente, se puede indicar una IP\nconcreta para especificar que s\u00f3lo escuchar\u00e1 en el puerto ofrecido por aquella IP y ninguna m\u00e1s.\nNOTA: Se pueden indicar varias l\u00edneas ListemStream para hacer que el socket escuche en varios puertos a la vez. Por otra parte,\ncomo que esta l\u00ednea puede estar escrita en diferentes archivos, si se quiere asegurar que s\u00f3lo se escuche en un puerto concreto sin\ntener en cuenta otras l\u00edneas que pueda haber le\u00eddo systemd previamente, se puede a\u00f1adir primero una l\u00ednea ListemStream vac\u00eda\n(as\u00ed: ListemStream = ) y luego la l\u00ednea ListenStream asociada al puerto deseado; lo que hace la l\u00ednea ListemStream vac\u00eda es\n\"resetear\" todas las l\u00edneas ListemStream anteriores\nPage 22\nListenDatagram = [IP:] n\u00baport\nIndica el n\u00famero de puerto UDP por donde escuchar\u00e1 el socket. Opcionalmente, se puede indicar una IP\nconcreta para especificar que s\u00f3lo escuchar\u00e1 en el puerto ofrecido por aquella IP y ninguna m\u00e1s.\nListenSequentialPacket = / ruta / arxiu.socket\nIndica el socket de tipo UNIX por donde se escuchar\u00e1. S\u00f3lo sirve para comunicaciones entre\nprocesos de la misma m\u00e1quina\nService = unNomAlternatiu\nSi el nombre del archivo \"service\" no es igual que el nombre del archivo \"socket\", aqu\u00ed se puede indicar\nentonces el nombre que tiene el archivo \"service\" para que el socket el sepa encontrar.\nAccept = yes\nSi se indica, hace que se genere una instancia del servicio diferente para cada conexi\u00f3n. \u00datil cuando se\nutilizan plantillas. Si su valor es no (por defecto) s\u00f3lo una instancia del servicio\ngestionar\u00e1 todas las conexiones.\nEl comando systemctl status * .socket nos permite saber cu\u00e1ntos y cu\u00e1les sockets est\u00e1n escuchando ahora\nmismo; el valor \"Accepted\" muestra cu\u00e1ntas conexiones se han realizado en total desde que el socket ha sido\niniciado y el valor \"Connected\" muestra cu\u00e1ntas conexiones est\u00e1n actualmente activas\nComo cualquier otra Unit, se pueden ver la lista de sockets con el comando s ystemctl list-Units -t\nsocket pero adem\u00e1s disponemos del comando espec\u00edfica systemctl list-sockets , la cual informa de qu\u00e9 servicio\ncorrespondiente activan y en qu\u00e9 puerto / socket UNIX escuchan.\nEJERCICIOS:\n1.-a) Crea el fichero \"/etc/systemd/system/dateserver.socket\" con el siguiente contenido:\n[Unido]\nDescription = Servicio de fecha en el puerto 55555\n[Socket]\nListenStream = 55555\nAccept = true\n[Install]\nWantedBy = sockets.target\nb) Crear el fichero \"/etc/systemd/system/dateserver@.service\" con el siguiente contenido:\n[Unido]\nDescription = Servicio de fecha\n[Service]\nType = simple\nExecStart = / opt / dateserver.sh\nStandardOutput = socket\nStandardError = journal\nc) Crear el fichero \"/opt/dateserver.sh\" con el siguiente contenido (y dale permisos de ejecuci\u00f3n!):\n\n\n! / Bin / bash\n\uf0c1\n\n\nwhile [[true]]\ndo\nPage 23\n\n\nAtenci\u00f3n: comprueba que date se encuentre dentro de / usr / bin; dependiendo de la distribuci\u00f3n eso cambia\n\uf0c1\n\n\n/ Usr / bin / date\nsleep 1\nd\u00e9\nd) Abre un terminal y ejecuta el comando nc ipServidor 55555 . \u00bfQu\u00e9 ves? Abre otro terminal diferente y\nejecuta el mismo comando. \u00bfQu\u00e9 ves? \u00bfQu\u00e9 te muestra el comando systemctl status dateserver.socket ? \u00bfY la\ncomando systemctl status dateserver @ * ? \u00bfY el comando systemctl list-Units dateserver @ * ?\n2.- Haz que el servidor SSH que tengas instal.lat a la m\u00e1quina (si no lo tienes, instal.la'l) inicie s\u00f3lo a trav\u00e9s\nde un socket. concretamente:\na) Crear el fichero \"/etc/systemd/system/sshMitjo.socket\" con el siguiente contenido:\n[Unido]\nDescription = Mi SSH Socket\n[Socket]\nListenStream = 22\nAccept = yes\n[Install]\nWantedBy = sockets.target\nb) Crear el fichero \"/etc/systemd/system/sshMitjo@.service\" con el siguiente contenido:\n[Unido]\nDescription = Mi SSH Server\n[Service]\nType = simple\nExecStart = - / usr / sbin / sshd -y\nStandardInput = socket\nStandardOutput = socket\nNOTA: Aqu\u00ed la clave est\u00e1 en la combinaci\u00f3n del par\u00e1metro -y del binario sshd (el cual hace que habilitar la posibilidad de que pueda recibir\npeticiones a trav\u00e9s de sockets), y la directiva StandardInput (lo realiza de forma efectiva este tipo de comunicaci\u00f3n entre el\nsocket y el servidor SSH)\nNOTA: Importante is the \"-\" in front of the binary name. This ENSUR that the exit status of the para-connection sshd process is\nforgotten by systemd. Normally, systemd will store the exit status of a all service instances that die abnormally. SSH will sometimes\ndie abnormally with an exit code of 1 oro similar, and we want to make sure that this does not cause systemd to keep around\ninformation for numerous previous connections that died this way (until this information is forgotten with systemctl reset-failed).\nc) Ejecutar el comando systemctl enable sshMitjo.socket y systemctl disable ssh.service (si fuera necesario) y reinicia\nla m\u00e1quina. Una vez hecho, comprueba que el socket sshMitjo est\u00e9 funcionando pero no el servicio sshMitjo.\nEjecuta ssh usuario @ ipServidor para entrar en el servidor SSH (deber\u00edas de conseguir sin problemas) y\ncomprueba seguidamente que ahora s\u00ed est\u00e1 funcionando una instancia del servicio sshMitjo\nd) \u00bfQu\u00e9 har\u00eda un comando como systemctl killsshd@172.31.0.52 : 22-172.31.0.4: 47779.service?\nPage 24\n3.-a) En el ejercicio anterior hemos tenido la suerte de que el servidor SSH ofrece un par\u00e1metro (-y) que le permite\ndelegar la apertura de los sockets (puertos) a un \"agente externo\" como es systemd. Pero no siempre tendremos un\nservidor que ofrezca esta posibilidad. En este sentido, lee los siguientes p\u00e1rrafos y resumen con las\ntus propias palabras que explica:\nOne of the limitations of socket activaci\u00f3n is that it requires the activated application to be aware that it may be socket-activated; the\nprocess of accepting an existing socket is different from creating a listening socket from scratch. Consequently a lot of widely used\napplications do not support it. The systemd developers have known that it may take some time to get activaci\u00f3n apoyo everywhere, sonido\nthey Introduced \"systemd-socket-proxyd\", a small TCP and Unix domain socket proxy server. This does understand activaci\u00f3n, and\nwill sit between the network and our server, transparently forwarding packets between the two. The steps to use this tool are:\nStep 1: We create a socket that Listener on the puerto that will eventually be served by the proxy / server combination.\nStep 2: On the first connection to the socket systemd activados the proxy service and hands it the socket.\nStep 3: When the proxy is started the corresponding server is first Broughten up (thanks to the Requires / After dependency)\nThe proxy then shuttles all traffic between the server and the network. The only trick here is that we need to bind the server to a puerto\nother than the real-target puerto (8080 instead of 80 if we are running a webserver, for instance). This is because that puerto will be\nowned by the socket / proxy, and you can not bind two processes to the same socket and interface.\nStep 1: \"myserver-proxy.socket\" file\n[Socket]\nListenStream = 0.0.0.0: 80\n[Install]\nWantedBy = sockets.target\nStep 2: \"myserver-proxy.service\" file\n[Unido]\nRequires = myserver.service\nAfter = myserver.service\n[Service]\nExecStart = / usr / lib / systemd / systemd-socket-proxyd 127.0.0.1:8080\nStep 3: \"myserver.service\" file\n[Unido]\nDescription = Server example (replace ExecStart value with something more realistic)\n[Service]\n\n\nWe listening server s listening puerto only to loopback interface because it 's there where input packages comas from proxy\n\uf0c1\n\n\nExecStart = / usr / bin / ncat -k -l 127.0.0.1 8080",
            "title": "Systemd"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#systemd-i",
            "text": "",
            "title": "Systemd (I)"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#introduccion",
            "text": "Systemd es varias cosas:   El proceso Init (PID 1) del sistema  El gestor de demonios  Un intermediario entre aplicaciones de usuario y ciertas partes de la API del kernel de Linux   La configuraci\u00f3n general de systemd se encuentra en el archivo  /etc/systemd/system.conf ; muchos valores por defecto est\u00e1n all\u00ed establecidos.  Para saber la versi\u00f3n actual de systemd que hay funcionando el sistema, hacer  systemctl --version",
            "title": "Introducci\u00f3n"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#units-tipos-y-ubicacion",
            "text": "Todo lo que es gestionado por systemd se llama \"unit\" y cada \"unit\" es descrita por un archivo de configuraci\u00f3n propio, el cual tendr\u00e1 una extensi\u00f3n diferente seg\u00fan el tipo de de unidad que se trate:   .service : Describe la configuraci\u00f3n de un demonio  .socket : Describe la configuraci\u00f3n de un socket (de tipo UNIX o TCP / IP) asociado a un .service  .device : Describe un dispositivo hardware reconocido por el kernel (v\u00eda udev o sysfs) gestionado por systemd  .mount : Describe un punto de montaje gestionado por systemd  .automount : Describe un punto de automontaje asociado a un .mount  .swap : Describe una partici\u00f3n o archivo de intercambio gestionado por systemd  .target : Define un grupo de Units (se utiliza a modo de \"metapaquete\" de Units)  .path : Describe una carpeta o archivo monitorizado por la API Inotify del kernel  .timer : Describe la temporizaci\u00f3n / activaci\u00f3n de una tarea programada (usando el programador systemd)  .slice : Define un grupo de Units asociadas a procesos para administrar y limitar los recursos comunes (CPU, memoria, discos, red). Usa internamente los llamados \"cgroups\" del kernel   Los archivos de configuraci\u00f3n de las Units (sean del tipo que sean) pueden estar repartidos en tres carpetas distintas:   /usr/lib/systemd/system : Para Units proporcionadas por los paquetes instalados en el sistema  /run/systemd/system : Para Units generadas en tiempo real durante la ejecuci\u00f3n del sistema. no persistentes  /etc/systemd/system : Para Units proporcionadas por el administrador del sistema   Los archivos en  /etc/...   sobreescriben  los archivos  hom\u00f3nimos  que est\u00e9n en  /run/...  los cuales sobreescriben los que est\u00e9n en  /usr/lib/...  (o en algunas distribuciones,  /lib/... ). Si no tienen el mismo nombre, todos los archivos de las tres carpetas se mezclan ordenados por su nombre de forma numericoalfab\u00e8tica y se van leyendo en este orden hasta el final.  Por otra parte, si dentro de  /usr/lib/... ,  /run/...  o  /etc/...  hay una carpeta llamada como una unit seguido del sufijo \".d\", cualquier archivo con extensi\u00f3n * .conf que haya en su interior ser\u00e1 le\u00eddo justo despu\u00e9s de los ficheros de configuraci\u00f3n de la unit pertinente. Esto sirve para poder a\u00f1adir (o sobreescribir) opciones de configuraci\u00f3n concretas (las presentes en estos archivos) sin tener que tocar las configuraciones \"gen\u00e9ricas\" de la unit. por\nejemplo: el archivo  /usr/lib/systemd/system/beep.service.d/foo.conf  puede ser \u00fatil para modificar la configuraci\u00f3n definida en  /usr/lib/systemd/systemd/beep.service  (y de este modo, hacer posible que un paquete pueda cambiar la configuraci\u00f3n establecida por otro) y el archivo  /etc/systemd/system/beep.service.d/foo.conf  puede ser \u00fatil para modificar la configuraci\u00f3n definida en  /usr/lib/systemd/system/beep.service  (y de este modo, hacer\nposible que un administrador pueda cambiar ciertas partes de la configuraci\u00f3n de la unit preempaquetada al sistema sin tener que reemplazar completamente). Estos archivos \"override\" (concretamente con el nombre  /etc/systemd/system/nomUnit.d/override.conf ) se pueden generar de una manera muy c\u00f3moda y r\u00e1pida con la orden  systemctl edit nomUnit  Algunas \"units\" contienen un s\u00edmbolo @ en su nombre (por ejemplo, nom@cadena.service); esto significa que son instancias de una unit-plantilla, el archivo de configuraci\u00f3n de la cual es el que no contiene la parte\n\"Cadena\" en su nombre (as\u00ed: nombre @.service). La parte \"cadena\" es el identificador de la instancia (de hecho, dentro del archivo de configuraci\u00f3n de la unit-plantilla el valor \"cadena\" sustituye todas las ocurrencias del especificador especial %i).",
            "title": "\"Units\": tipos y ubicaci\u00f3n"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#comandos-para-gestionar-units-principalmente-de-tipo-service",
            "text": "A continuaci\u00f3n mostramos algunos de los comandos m\u00e1s importantes para gestionar Units principalmente (No exclusivamente) de tipo \"service\":  systemctl [list-Units] [-t {service | socket | ...}] [--all | --failed | --state = inactive]  Muestra el estado de las Units que est\u00e1n \"activas\" (del tipo indicado, si no se indica, aparecen todas).   Si se escribe --state = inactive se muestra el estado de las Units que est\u00e1n \"inactivas\"  Como valor del par\u00e1metro  --state  tambi\u00e9n se puede poner cualquier valor v\u00e1lido de la columna SUB  Si se escribe  --failed  se muestra el estado de todas las Units con errores   Si se escribe --all se muestra el estado de todas las Units ( \"activas\", \"inactivas\", con errores y otros)\n-La diferencia entre las columnas LOAD, ACTIVE y SUB la dice la salida de la propia comando:    LOAD  = Indica si la Unit ha sido cargada en RAM. Posibles valores: \"loaded\", \"error\", \"Masked\"    ACTIVE  = Estado gen\u00e9rico de la unit. Posibles valores: \"active\", \"inactive\", \"failed\", \"(des) activating\"    SUB  = Estado m\u00e1s concreto de la unit, depende del tipo de unit, posibles valores \"plugged\", \"mounted\", \"running\", \"exited\", \"waiting\", \"listening\", etc      systemctl [-t {service | socket | ...}] list-unit-files  El comando  list-units  s\u00f3lo muestra las units que systemd ha intentado leer y cargar en memoria. Ya que systemd s\u00f3lo lee las units que \u00e9l piensa que necesita, as\u00ed no incluye necesariamente todas las units disponibles en el  sistema. Para ver todas las units, incluyendo aquellas que systemd no ha intentando ni siquiera cargar, hay que utilizar  list-unit-files . Este subcomando muestra el \"estado de carga\" de cada unit y sus posibles valores son:    \"enabled\"  o  \"enabled-runtime\"  : La unit se activar\u00e1 en el siguiente reinicio -y subsiguientes-.   NOTA  Esto se consigue gracias a la existencia de un enlace al archivo de configuraci\u00f3n de la unit en cuesti\u00f3n dentro de la carpeta  /etc/systemd/system/nomTarget.target.wants , creado en alg\u00fan momento previo con el comando systemctl enable (ver m\u00e1s abajo) o de forma manual con ln -s     \"static\" : La unit no tiene secci\u00f3n \"[Install]\" en su archivo de configuraci\u00f3n. Esto hace que los comandos  systemctl enable  (y sobre todo  systemctl disable ) no funcionen. Por tanto, el hecho de que la unit est\u00e9\nactivada o no en un determinado \"target\" depender\u00e1 de la existencia \"est\u00e1tica\" de su enlace correspondiente dentro de la carpeta  /etc/systemd/system/nomTarget.target.wants . Este tipo de units suelen estar asociadas a las que realizan una acci\u00f3n \"oneshot\" o bien a las que son usadas s\u00f3lo como\ndependencia de alguna otra unit (y por tanto no deben ejecutarse por s\u00ed mismas)    \"generated\" : La unit se activar\u00e1 mediante un mecanismo autom\u00e1tico especial llamado \"generator\", ejecutado al arrancar el sistema. Cada unit en este estado tiene su propio \"generator\".    \"transient\"  : La unit es temporal y no sobrevivir\u00e1 al siguiente reinicio    \"disabled\" : La unit est\u00e1 desactivada y, por tanto, no se pondr\u00e1 en marcha en los siguientes reinicios (gracias a la inexistencia del enlace correspondiente dentro de  /etc/systemd/system/nomTarget.target.wants ).\nTampoco podr\u00e1 ser iniciada autom\u00e1ticamente mediante otros sistemas (como v\u00eda socket, v\u00eda D-Bus o bien v\u00eda conexi\u00f3n de hardware. No obstante, podr\u00e1 ser puesta en marcha en cualquier momento \"manualmente\" ejecutando  systemctl start ( ver m\u00e1s abajo)    \"Masked\"  o  \"Masked-runtime\" : La unit est\u00e1 Enmascarada (es decir, est\u00e1 desactivada y, por tanto, no se pondr\u00e1 en marcha en los siguientes reinicios ni autom\u00e1ticamente, pero adem\u00e1s, tampoco podr\u00e1 ser puesta nunca\nen marcha manualmente con systemctl start ni siquiera si es una dependencia de otro servicio)    systemctl {start | stop | restart} nomUnit[.service]  Activa / Desactiva / Reiniciar la unit indicada inmediatamente siguiendo las indicaciones escritas en su archivo de configuraci\u00f3n correspondiente.   NOTA  Si la unit no fuera de tipo \".service\", entonces habr\u00e1 que indicar su tipo expl\u00edcitamente \u00faltima su nombre (por ejemplo,  systemctl start nomUnit.socket ). Esta norma es extensiva para el resto de comandos    systemctl {enable | disable} nomUnit[.service]  Activar\u00e1 / desactivar\u00e1 autom\u00e1ticamente la unit indicada a partir del siguiente reinicio (y siguientes)   NOTA  En realidad lo que hace enable / disable es crear / eliminar un enlace dentro de la carpeta  /etc/systemd/systemd/nomTarget.target.wants  al archivo de configuraci\u00f3n de la unit en cuesti\u00f3n (donde \"nomTarget\" viene definido en la directiva WantedBy de la secci\u00f3n \"[Install]\" de dicho archivo).   systemctl {mask | unmask} nomUnit [.service]  Enmascara / desenmascarar la unit indicada.   NOTA  Esto lo consigue vinculando el archivo de configuraci\u00f3n ubicado en  /etc/...  de la unit en cuesti\u00f3n a /dev/null   systemctl is-enabled nomUnit[.service]  Devuelve  $? = 0  si la unit indicada est\u00e1 configurada para activarse en los siguientes reinicios (es decir, si est\u00e1 en los estados listados para  systemctl list-unit-files  : \"enabled\", \"enabled-runtime\", \"static\", \"Generated\" o \"transient\") y adem\u00e1s, muestra en pantalla este estado.  systemctl is-active nomUnit [.service]  Devuelve $? = 0 si la unit indicada est\u00e1 activa y, adem\u00e1s, muestra en pantalla este estado (valor listado en la columna ACTIVE de systemctl list-units)  systemctl is-failed nomUnit[.service]  Devuelve $? = 0 si la unit indicada fall\u00f3 al intentar activarse y, adem\u00e1s, muestra en pantalla este estado. Si no queremos que se muestren los estados en pantalla (esto tambi\u00e9n por is-enabled y is-active ), se puede a\u00f1adir el par\u00e1metro -q   NOTA  Una unit puede estar en estado \"failed\" por m\u00faltiples razones: porque el proceso ha terminado con un c\u00f3digo de error diferente de 0, porque ha finalizado de forma anormal, porque se ha superado un timeout determinado, etc.   systemctl status {nomUnit [.service] | PID}  Muestra el estado e informaci\u00f3n variada sobre la Unit o proceso indicado. Si se indica una unit se puede ver ...:      Loaded: loaded (/usr/lib/systemd/system/cups.service; enabled; vendor preset: disabled)\n    Active: active (running) since Sat 2017-11-18 20:48:06 CET; 4h 2min agosto\n    Docs: man: cupsd (8)\n    Main PID : 745 (cupsd)\n    Status: \"Scheduler is running ...\"\n    Tasks: 1 (l\u00edmite: 4915)\n    CGroup: /system.slice/cups.service\n    \u2514\u2500745 / usr / sbin / cupsd -l\n\n    \u00daltimas l\u00edneas de journald -u (se puede usar los par\u00e1metros hom\u00f3nimos -n n\u00ba y -o xxx)  Los valores para la l\u00ednea \"Loaded:\" son los mismos que aparecen en la columna LOAD de list-units  Seguidamente se indican los valores del estado actual y el predefinido por paquete, que ser\u00e1n uno de los detallados anteriormente al hablar de list-unit-files  Los valores para la l\u00ednea \"Active:\" son los mismos que aparecen en la columna ACTIVE de list-Units  El punto ( \"\u25cf\") es blanco si la unit est\u00e1 \"inactive\"; rojo si \"failed\" o verde si \"active\"  Si se indica un PID en vez de una unit, se puede ver la misma informaci\u00f3n, pero esta manera puede ser \u00fatil para conocer la unit a la que est\u00e1 asociado un determinado proceso, por ejemplo (aunque para conocer esta informaci\u00f3n tambi\u00e9n se podr\u00edan observar los valores de la columna \"unit\" mostrada para el comando  ps -o  si as\u00ed se indica con el par\u00e1metro -o ):  cups.service - CUPS Scheduler\nLoaded: loaded ( /usr/lib/systemd/system/cups.service ; enabled; vendor preset:\nActive: active (running) since Sat 2017-11-18 20:48:06 CET; 4h 2min agosto\nDocs: man: cupsd (8)\nMain PID: 745 (cupsd)\nStatus: \"Scheduler is running ...\"\nTasks: 1 (l\u00edmite: 4915)\nCGroup: /system.slice/cups.service\n\u2514\u2500745 / usr / sbin / cupsd -l\n\u00daltimas l\u00edneas de journald _PID = (se puede usar los par\u00e1metros hom\u00f3nimos -n n\u00ba y -o xxx)  systemctl show {nomUnit [.service] | PID}  Muestra la configuraci\u00f3n actual de la Unit (obtenida a partir del archivo general system.conf y del archivo de configuraci\u00f3n propio de la unit) indicada en un formato adecuado para ser procesado por m\u00e1quinas. con el par\u00e1metro  -p \"nomClave, OtroNombre,...  se pueden obtener s\u00f3lo las parejas clave <-> valor deseadas.  systemctl daemon-reload  Actualizar todos los archivos de configuraci\u00f3n de Units nuevas o modificadas desde la \u00faltima vez que se puso en marcha systemd (incluyendo los generators).  systemctl help nomUnit [.service]  Abre la p\u00e1gina man asociada a la Unit indicada (en su fichero de configuraci\u00f3n debe venir indicada)  systemctl edit nomUnit [.service]  Crea (con el editor de texto predeterminado del sistema) un fichero de configuraci\u00f3n (inicialmente vac\u00edo) para la Unit indicada llamado  /etc/systemd/system/nomUnit.tipusUnit.d/override.conf  para sobrescribir (o ampliar) la configuraci\u00f3n ya existente por ella. Una vez guardados los cambios, recarga la Unit autom\u00e1ticamente con esta nueva configuraci\u00f3n. Si se quisiera editar directamente el archivo  /etc/systemd/system/nomUnit.tipoUnit , hay que a\u00f1adir entonces el par\u00e1metro  --full  systemctl cat nomUnit [.service]  Muestra la configuraci\u00f3n final actual resultante de haber le\u00eddo los diferentes ficheros de configuraci\u00f3n\nposibles de la Unit indicada  systemd-delta  Muestra qu\u00e9 archivos de configuraci\u00f3n de Units est\u00e1n sobreescritos o ampliados (de /usr /lib a /etc y / o con\narchivos \"overrides\"), enmascarados, redireccionados (con la l\u00ednea Alias \u200b\u200b= de la secci\u00f3n [Install]), etc y por cu\u00e1les  systemctl kill [--signal = n\u00ba] nomUnit [.service]  Env\u00eda una se\u00f1al concreta (indicada con el par\u00e1metro --signal ; por defecto es la n\u00ba15, SIGTERM) a\ntodos los procesos asociados a la Unit indicada.   NOTA  kill  goes directly and sends a signal to every process in the group, however  stop  goes through the  official configured way to shut down a service, i.e. invokes the stop command configured with ExecStop= in the service file. Usually stop should be sufficient. kill is the tougher version, for cases where you either don't want the official shutdown command of a service to run, or when the service is hosed and hung in other ways.",
            "title": "Comandos para gestionar Units (principalmente de tipo \"service\")"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#servicios-systemd-por-usuario",
            "text": "Systemd tambi\u00e9n permite definir servicios para que no est\u00e9n asociados al sistema global sino que \u00fanicamente formen parte de la sesi\u00f3n de un usuario est\u00e1ndar, gener\u00e1ndose una instancia particular del servicio para cada usuario\nactivo en la m\u00e1quina. De este modo, cada instancia se iniciar\u00e1 autom\u00e1ticamente despu\u00e9s de iniciar la sesi\u00f3n de un usuario y se parar\u00e1 al salir.   NOTA  Esto es posible gracias a que justo despu\u00e9s del primer inicio de sesi\u00f3n que se realice al sistema se pone en marcha (gracias al m\u00f3dulo PAM \"pam_systemd\") el comando  systemd -user   ( que es quien permitir\u00e1 este funcionamiento individual para todas las sesiones de usuarios que se inicien a partir de entonces), adem\u00e1s del proceso con PID 1 propiamente dicho, que es  systemd -system  . El proceso  systemd -user  finalizar\u00e1 autom\u00e1ticamente justo despu\u00e9s de haberse cerrado el \u00faltimo inicio de sesi\u00f3n existente al sistema.   Los ficheros de configuraci\u00f3n de las Units \"de tipo usuario\" se encuentran en otras carpetas separadas de las de las Units \"de sistema\". Concretamente (se muestran en orden de precedencia ascendente):   \"/Usr/lib/systemd/user\": Para Units proporcionados por los paquetes instalados en el sistema  \"~ / .Local / share / systemd / user\": Para Units de paquetes que han sido instaladas en la carpeta personal  \"/ Etc / systemd / user\": Para Units proporcionados por administrador del sistema  \"~ / .Config / systemd / user\": Para Units construidas por el propio usuario    NOTA  La variable especial  %h  se puede utilizar dentro de los archivos de configuraci\u00f3n de las Units \"de usuario\" para indicar la ruta de la carpeta personal del usuario en cuesti\u00f3n.   Otra caracter\u00edstica de las Units \"de usuario\" es que pueden ser gestionadas por parte de este usuario sin que deba ser administrador del sistema; esto lo puede hacer con las mismas \u00f3rdenes  systemctl...   ya conocidas s\u00f3lo que a\u00f1adiendo el par\u00e1metro --user As\u00ed, por ejemplo, para arrancar un servicio autom\u00e1ticamente cada vez que se inicie nuestra sesi\u00f3n habr\u00e1 que ejecutar  systemctl --user enable nomUnit  ; para ver el estado de\ntodas nuestras Units \"de usuario\" habr\u00e1 que hacer  systemctl --user list-units  ; para recargar las Units modificadas habr\u00e1 que hacer  systemctl --user daemon-reload  , etc",
            "title": "Servicios Systemd por Usuario"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#secciones-y-directivas-comunes-en-los-ficheros-de-configuracion-de-las-units",
            "text": "La estructura interna de los archivos de configuraci\u00f3n de las Units est\u00e1 organizada en secciones, distinguidas cada una por un encabezamiento sensible a may\u00fasculas y min\u00fasculas rodeado de corchetes ( [Encabezamiento] ). Dentro de las secciones se definen diferentes directivas (tambi\u00e9n may\u00fasculas y min\u00fasculas) en la forma de parejas NomDirectiva = valor , donde el valor puede ser una palabra, una frase, una ruta, un n\u00famero, true/yes, false/no, una\nfecha, etc, dependiendo de su significado.   NOTA  NOTA: Tambi\u00e9n pueden existir directivas donde no se escriba ning\u00fan valor (es decir, as\u00ed: NomDirectiva = ). En este caso, se estar\u00e1 \"Reseteando\" (es decir, anulando) el valor que previamente se hubiera dado en otro sitio   La primera secci\u00f3n (aunque el orden no importa) siempre suele ser la llamada [Unit] y se utiliza para definir datos sobre la propia Unit en s\u00ed como Unit que es y la relaci\u00f3n que tiene \u00e9sta con otros Units. algunas de sus directivas m\u00e1s habituales son:    Description  = Una breve descripci\u00f3n de la Unit  Su valor es devuelto por diferente herramientas systemd    Documentation  = man: sshd (8) https: //ruta/pag.html  Proporciona una lista de URIS que apuntan a documentaci\u00f3n de la Unit.  El comando  systemctl status  las muestra    Wants  = unservei.service unaltre.service untarget.target ...  Lista las Units que deber\u00edan estar iniciadas para que el Unit en cuesti\u00f3n pueda funcionar correctamente. Si no lo est\u00e1n ya, systemd las iniciar\u00e1 en paralelo junto con el Unit en cuesti\u00f3n; si se quiere indicar un cierto orden en vez de iniciar todas en paralelo, se puede utilizar las directivas After = o Before =. Si alguna de las Units listadas falla al iniciarse, el Unit en cuesti\u00f3n se iniciar\u00e1 igualmente    Requires  = unservei.service unaltre.service untarget.target ...  Lista las Units que imprescindiblemente deben estar iniciadas para que el Unit en cuesti\u00f3n pueda funcionar correctamente. Si no lo est\u00e1n ya, systemd las iniciar\u00e1 en paralelo junto con el Unit en cuesti\u00f3n; si se quiere indicar un cierto orden en vez de iniciar todas en paralelo, se puede utilizar las directivas After = o Before =. Si alguna de las Units listadas falla al iniciarse, el Unit en cuesti\u00f3n tambi\u00e9n fallar\u00e1 autom\u00e1ticamente    BindsTo  = unservei.service unaltre.service untarget.target ...\n    Similar a Requires = pero, adem\u00e1s, hace que el Unit en cuesti\u00f3n se detenga autom\u00e1ticamente si alguna de las Units asociadas finaliza.    Before  = unservei.service unaltre.service untarget.target ...\n    Indica, de las Units listadas en las directivas Wants = o Requires =, qu\u00e9 no se iniciar\u00e1n en paralelo sino tras la Unit en cuesti\u00f3n. Si aqu\u00ed se indicara alguna Unit que no se encontrara listada en Wants = o Requires =, esta directiva no se tendr\u00e1 en cuenta.    After  = unservei.service unaltre.service untarget.target ...\n    Indica, de las Units listadas en las directivas Wants = o Requires =, qu\u00e9 no se iniciar\u00e1n en paralelo sino antes de la Unit en cuesti\u00f3n. Si aqu\u00ed se indicara alguna Unit que no se encontrara listada en Wants = o Requires =, esta directiva no se tendr\u00e1 en cuenta.     NOTA  Lo m\u00e1s t\u00edpico es tener una Unit A que necesita que la Unit B est\u00e9 funcionando previamente para poderse poner en marcha. En este caso, simplemente habr\u00eda que a\u00f1adir las l\u00edneas Requires = B y After = B en la secci\u00f3n [Unido] del Unit A. Si la dependencia es opcional, se puede sustituir Requires = B para Wants = B     Conflicts  = unservei.service unaltre.service ...\n    Lista las Units que no pueden estar funcionando a la vez que el Unit en cuesti\u00f3n. iniciar una Unit con esta directiva causar\u00e1 que las aqu\u00ed listadas se detengan autom\u00e1ticamente.    ConditionXXXX  = ...\n    Hay un conjunto de directivas que empiezan por \"Condition\" que permiten al administrador comprobar ciertas condiciones antes de iniciar el Unit. Si la condici\u00f3n no se cumple, la Unit es ignorada. Algunos ejemplos son:  ConditionKernelCommandLine = param [= valor]\nConditionACPower = {yes | no}\nConditionPathExists = [!] / Ruta / archivo / o / carpeta\nConditionPathExistsGlob = [!] / Ruta / archivos / o / carpetas\nConditionPathIsDirectory = [!] / Ruta / carpeta\nConditionPathIsSymbolicLink = [!] / Ruta / enlace\nConditionPathIsMountPoint = [!] / Ruta / carpeta\nConditionPathIsReadWrite = [!] / Ruta / archivo / o / carpeta\nConditionDirectoryNotEmpty = [!] / Ruta / carpeta\nConditionFileNotEmpty = [!] / Ruta / archivo\nConditionFileIsExecutable = [!] / Ruta / archivo\nAssertXXXX = ...    Al igual que con \"ConditionXXX\", hay un conjunto de directivas que empiezan por \"Assert\" que permiten al administrador comprobar ciertas condiciones antes de iniciar el Unit. la diferencia es que aqu\u00ed, si la condici\u00f3n no se cumple, se emite un error.    .OnFailure  = unaunit.service otro.service ...\n    Indica las Units que se activar\u00e1n cuando la Unit en cuesti\u00f3n entre en estado \"failed\". esta directiva puede utilizarse, por ejemplo, para ejecutar una Unit que env\u00ede un correo electr\u00f3nico cuando la Unit en cuesti\u00f3n, que podr\u00e1 ser un servicio, falle.    AllowIsolate  = yes\n    Esta directiva s\u00f3lo tiene sentido para Units de tipo target. Si su valor es \"yes\" (por defecto es \"no\") indica que el target en cuesti\u00f3n admitir\u00e1 que se le aplique el comando systemctl Isolate (ver m\u00e1s abajo)    Por otra parte, la \u00faltima secci\u00f3n (aunque el orden no importa) de un archivo de configuraci\u00f3n de una Unit siempre suele ser la llamada [ Install ] , la cual, atenci\u00f3n, es opcional. Se utiliza para definir c\u00f3mo y cuando la Unit puede\nser activada o desactivada. Algunas de sus directivas m\u00e1s habituales son:    WantedBy  = untarget.target unaltre.target ...  Indica los targets donde el Unit en cuesti\u00f3n se activar\u00e1 al ejecutar el comando  systemctl enable  Cuando se ejecuta este comando, lo que pasa es que por cada target indicado aqu\u00ed aparecer\u00e1,dentro de cada carpeta  /etc/systemd/system/nomTarget.wants  respectiva, un enlace simb\u00f3lico apuntando al propio archivo de configuraci\u00f3n del Unit en cuesti\u00f3n. La existencia de este enlace es el que realmente activa de forma efectiva un servicio autom\u00e1ticamente. Eliminar los links de todas las carpetas \"nomTarget.wants\" pertinentes implica desactivar la Unit (que es lo que hace, de hecho,el comando  systemctl disable  a partir de la lista de targets que encuentra en la l\u00ednea WantedBy = ).  Por ejemplo, si el archivo de configuraci\u00f3n de la Unit en cuesti\u00f3n (que llamaremos pepito.service) tiene una l\u00ednea como WantedBy = multi-user.target, al ejecutar  systemctl enable pepito.service  aparecer\u00e1 dentro de la carpeta  /etc/systemd/system/multi-user.wants  un link apuntando a este archivo de configuraci\u00f3n    RequiredBy  = untarget.target unaltre.target ...  Similar a WantedBy = pero donde el fallo del Unit en cuesti\u00f3n en ejecutar systemctl enable har\u00e1 que los targets indicados aqu\u00ed no puedan llegar a alcanzar. La carpeta donde se encuentra el link de el Unit en este caso se denomina  /etc/systemd/system/nomTarget.requires    Alias  \u200b\u200b= unaltrenom.tipusUnit  Permite al Unit en cuesti\u00f3n ser activada con  systemctl enable  utilizando otro nombre diferente    Also  = unservei.service unaltre.service ...  Permite activar o desactivar diferentes Units como conjunto. La lista debe consistir en todas las Units que tambi\u00e9n se quieren tener habilitadas cuando la Unit en cuesti\u00f3n est\u00e9 habilitada    Secci\u00f3n [Service] (por Units de tipo .service): \uf0c1  Dependiendo del tipo de Unit que tengamos nos podremos encontrar con diferentes secciones espec\u00edficas dentro de su fichero de configuraci\u00f3n, normalmente escritas entre la secci\u00f3n [Unit] el principio y la secci\u00f3n [Install] del final (si existe). En el caso de las Units de tipo \"service\", por ejemplo, nos encontramos con la secci\u00f3n espec\u00edfica llamada [Service] , la cual puede incluir diferentes directivas como las siguientes:   NOTA  Las Units de tipo device, snapshot y target no tienen secciones espec\u00edficas     Type  = maneraDarrancar   Existen diferentes m\u00e9todos para iniciar un servicio, y el m\u00e9todo elegido, el cual depender\u00e1 del tipo de ejecutable a poner en marcha, se indicar\u00e1 en esta directiva. Las posibilidades m\u00e1s comunes son:    simple : El servicio nativamente se queda en primer plano de forma indefinida y es systemd quien lo pone en segundo plano (le crea un fichero PID, lo para cuando sea necesario, etc). Systemd interpreta que el servicio est\u00e1 listo luego que el ejecutable asociado se pone en marcha (aunque esto sea demasiado pronto para que no est\u00e9 listo todav\u00eda para recibir peticiones)    forking : El servicio nativamente ya se pone en segundo plano. Systemd interpreta que el servicio est\u00e1 listo cuando pasa efectivamente a segundo plano. En este caso conviene indicar tambi\u00e9n la directiva PidFile=/ruta/fitxer.pid para que systemd tenga un control sobre qu\u00e9 proceso es el que est\u00e1 en segundo plano y lo pueda identificar    oneshot : \u00datil para scripts, que se ejecutan (haciendo  systemctl start  igualmente) una vez y finalizan.Systemd esperar\u00e1 hasta que el proceso finalice e interpreta que est\u00e1 listo cuando haya finalizado.\nSe puede considerar el uso de la directiva RemainAfterExit = yes para \"enga\u00f1ar\" a systemd dici\u00e9ndole que el servicio contin\u00faa activo aunque el proceso haya finalizado; en este caso, la directiva ExecStop = no se llegar\u00e1 a hacer efectiva nunca.     Tambi\u00e9n est\u00e1n las posibilidades \"dbus\" (similar a \"simple\" pero systemd interpreta que est\u00e1 listo cuando el nombre indicado en BusName = ha sido adquirido), \"idle\" (similar a \"simple\" pero con la ejecuci\u00f3n retrasada hasta que no se ejecute nada m\u00e1s; se puede utilizar este m\u00e9todo, por ejemplo, para emitir un sonido justo despu\u00e9s de la finalizaci\u00f3n del arranque del sistema.) y \"notify\" (El sistema m\u00e1s completo, donde se establece un canal de comunicaci\u00f3n interno entre el servicio y Systemd para notificarse estados y eventos v\u00eda la API propia de systemd sd_notify () y donde Systemd interpreta que est\u00e1 listo cuando recibe el estado correspondiente a trav\u00e9s de este canal; si queremos que scripts utilicen este m\u00e9todo hay que usar el comando systemd-notify )    ExecStart  = /ruta/ejecutable param1 param2 ...\n    Indica el comando (y par\u00e1metros) a ejecutar cuando se realiza un  systemctl start  Si la ruta de el ejecutable comienza con un gui\u00f3n ( \"-\"), valores de retorno del comando diferentes de 0 (que normalmente se considerar\u00edan se\u00f1al de error) se considerar\u00e1n como v\u00e1lidos.   Nota  Podemos utilizar incluso la directiva SuccessExitStatus = para indicar qu\u00e9 valor consideramos como salida exitosa del programa    Nota  No habr\u00eda que escribir la ruta absoluta del ejecutable si \u00e9sta se encuentra en la lista de rutas que muestra el comando  systemd-path  , pero en general se recomienda escribirla para evitar sorpresas    Nota  No se permiten escribir redireccionador ( \">\", \">>\", \"<\". \"|\") Ni el s\u00edmbolo \"&\" para pasar a segundo plano     ExecStartPre  = /ruta/ejecutable param1 param2 ...\n    Indica el comando (y par\u00e1metros) a ejecutar antes de lo indicado en ExecStart. pueden haber m\u00e1s de una l\u00ednea ExecStartPre en el mismo archivo, ejecut\u00e1ndose entonces cada una por orden. la ruta del ejecutable tambi\u00e9n puede ir precedida de un gui\u00f3n ( \"-\"), con el mismo significado    ExecStartPost  = / ruta / ejecutable param1 param2 ...\n    Indica el comando (y par\u00e1metros) a ejecutar despu\u00e9s de la indicada en ExecStart. pueden haber m\u00e1s de una l\u00ednea ExecStartPost en el mismo archivo, ejecut\u00e1ndose entonces cada por orden. un ejemplo de posible uso: \n    el env\u00edo de un correo justo despu\u00e9s de haberse puesto en marcha el servicio correspondiente.La ruta del ejecutable tambi\u00e9n puede ir precedida de un gui\u00f3n ( \"-\"), con el mismo significado    ExecStop  = /ruta/ejecutable param1 param2 ...\n    Indica el comando (y par\u00e1metros) a ejecutar cuando se realiza un  systemctl stop  Hay que tener en cuenta que en el caso de un servicio de tipo \"oneshot\", si no se especifica la directiva RemainAfterExit = yes , el comando indicada en ExecStop se ejecutar\u00e1 autom\u00e1ticamente justo tras ExecStart.    ExecStopPost  = / ruta / ejecutable param1 param2 ...\n    Indica el comando (y par\u00e1metros) a ejecutar despu\u00e9s de lo indicado en ExecStop. pueden haber m\u00e1s de una l\u00ednea ExecStartPost al mismo archivo, ejecut\u00e1ndose entonces cada por orden.    Restart  = {always | no | on-success | on-failure | ...}\n    Indica las circunstancias bajo las que systemd intentar\u00e1 reiniciar autom\u00e1ticamente un servicio que haya finalizado. En concreto, el valor \"always\" indica que en cualquier tipo de finalizaci\u00f3n se volver\u00e1 a intentar reiniciar; el valor \"no\" indica que en ning\u00fan finalizaci\u00f3n intentar\u00e1 reiniciar, el valor \"on-success\" indica que s\u00f3lo se intentar\u00e1 reiniciar si la finalizaci\u00f3n ha sido correcta y \"on-failure\" si la finalizaci\u00f3n no lo ha sido debido a cualquier tipo de fallo (ya sea que se ha sobrepasado el tiempo de espera del arranque o el apagado, que se ha devuelto un valor diferente de 0, etc)   Nota  Se podr\u00eda dar el caso de que un servicio estuviera reinici\u00e1ndose todo el rato. Con StartLimitBurts = se puede configurar el n\u00famero m\u00e1ximo de veces que se quiere que se reinicie y con StartLimitIntervalSec = se puede configurar el tiempo durante el cual se contar\u00e1 este n\u00famero m\u00e1ximo de veces. Si se llega a este n\u00famero dentro de este tiempo, el servicio no se volver\u00e1 a reiniciar autom\u00e1ticamente y tampoco se podr\u00e1 iniciar manualmente hasta pasado el tiempo indicado (momento en el que se vuelve a contar). Tambi\u00e9n existe la directiva StartLimitAction = , que sirve para indicar la acci\u00f3n a realizar cuando se alcanza el n\u00famero m\u00e1ximo de reinicios; su valor por defecto es \"None\" pero puede valer tambi\u00e9n \"reboot\" (reinicio limpio), \"reboot-force\" (reinicio abrupto) y \"reboot-immediate\" (reinicio muy abrupto)     RestartSec  = n\u00bas\n    Indica el n\u00famero de segundos que systemd esperar\u00e1 al reiniciar el servicio despu\u00e9s de que haya detenido (si as\u00ed lo marca la directiva Restart =).    TimeoutSec  = n\u00ba\n    Indica el n\u00famero de segundos que systemd esperar\u00e1 a que el servicio en cuesti\u00f3n inicie o detenga antes de marcarlo como \"failed\" (y reiniciarlo si fuera el caso debido a la configuraci\u00f3n de la directiva Restart =). Se puede indicar espec\u00edficamente un tiempo de espera s\u00f3lo para el inicio con la directiva TimeoutStartSec = y otro tiempo de espera diferente por el apag\u00f3n con la directiva TimeoutStopSec = . Si no se especifica nada, se toma el valor por defecto (5 min) que est\u00e1 indicado en /etc/systemd/system.conf    RemainAfterExit  = yes\n    Tal como ya lo hemos comentado, esta directiva se utiliza en servicios de tipo \"oneshot\" para que la directiva ExecStop = no se ejecute al terminar la ejecuci\u00f3n del comando sino al hacer systemctl stop    PidFile  = /ruta/fitxer.pid\n    Tal como ya lo hemos comentado, esta directiva se utiliza en servicios de tipo \"forking\" para se\u00f1alar a systemd cu\u00e1l ser\u00e1 el archivo PID utilizado por el servicio de manera que pueda controlar m\u00e1s f\u00e1cilmente.    User  = unusuari    Group  = ungrup\n    Set the user or group that the processes are executed as, respectively. They can take a single user/group name, or a numeric ID as argument. For system services (services run by the system service manager, i.e. managed by PID 1) the default is \"root\". For user services of any other user, switching user identity is not permitted, hence the only valid setting is the same user the user's service manager is running as. If no group is set, the default group of the user is used.    WorkingDirectory  = / ruta / carpeta\n    Indica el directorio de trabajo del servicio en cuesti\u00f3n. Si no se especifica esta directiva, el valor por defecto es \"/\" (en el caso de servicios de sistema) o $ HOME (en el caso de servicios de usuario, es decir, iniciados con --user -). Si la ruta se precede con un s\u00edmbolo \"-\", el hecho de que la carpeta correspondiente no exista no se interpretar\u00e1 como un error. Si se ha indicado la directiva User =, se puede escribir \"~\" como valor de esta directiva, equivalente as\u00ed a la ruta de la carpeta personal del usuario indicado en User =.    StandardOutput  = {null | tty | journal | socket}\n    Indica donde se imprimir\u00e1 la salida est\u00e1ndar de los programas indicados en las directivas ExecStart =, y ExecStop =. El valor \"null\" representa el destino / dev / null. El valor \"tty\" representa un terminal (ya sea de tipo virtual - / dev / ttyX- o pseudo - / dev / pts / X-), el cual deber\u00e1 ser especificado mediante la directiva TTYPath = . El valor \"journal\" es el valor por defecto (es decir, que si el programa en cuesti\u00f3n imprimiera algo en la pantalla del terminal al ejecutarse en primer plano, esta salida se redireccionar\u00e1 el Journal en ejecutarse v\u00eda un archivo .service). El valor \"socket\" sirve para indicar que la salida debe enviarse al socket asociado al servidor con el fin de viajar al otro extremo de la comunicaci\u00f3n (ver m\u00e1s adelante).   NOTA  NOTA: El hecho de que por defecto la salida est\u00e1ndar vaya a parar en el Journal se puede cambiar de forma general para todas las Units en la directiva DefaultStandardOutput del archivo  /etc/systemd/system.conf    NOTA  Tambi\u00e9n existe la directiva StandardError = {null | tty | journal | socket} , similar a StandardOutput = pero para la salida de error",
            "title": "Secciones y directivas comunes en los ficheros de configuraci\u00f3n de las Units"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#ejercicios",
            "text": "Todos los ejercicios se har\u00e1n en una m\u00e1quina virtual donde el usuario pueda tener permisos de administrador:    A) Ejecutar  systemctl list-Units -t service | grep ufw  (si est\u00e1s en Ubuntu) o  systemctl list-Units -t service | grep firewalld  (si est\u00e1 en Fedora). \u00bfQu\u00e9 significa la palabra \"loaded\"? Y \"active\"? Confirma esto ejecutando  systemctl status ufw / systemctl status firewalld  B) Ahora enmascara la Unit ufw / firewalld. \u00bfQu\u00e9 pasa realmente cuando s'enmascara una Unit? Pista: consulte donde apunta el reci\u00e9n creado archivo  /etc/systemd/system/ufw.service  (o  /etc/systemd/system/firewalld.service )  C) Ejecutar systemctl list-Units -t service | grep ufw (o systemctl list-Units -t service | grep firewalld ) de nuevo.\n\u00bfPor qu\u00e9 todav\u00eda aparece la palabra \"active\"? Confirma esto ejecutando  systemctl status ufw  /  systemctl status firewalld  D) Si ahora ejecutas  systemctl stop ufw  (o  systemctl stop firewalld  ) , \u00bfqu\u00e9 muestra  systemctl list-Units -t service | grep ufw (o systemctl list-Units -t service | grep firewalld  )? \u00bfPor qu\u00e9? \u00bfQu\u00e9 deber\u00edas hacer para que vieras algo? Pista: usa el par\u00e1metro --all  E) Ejecutar el comando systemd-delta . \u00bfQu\u00e9 significa la relaci\u00f3n indicada entre los dos archivos que aparecen en la l\u00ednea [Masked]? \u00bfY entre los dos archivos que aparecen en las l\u00edneas [EXTENDED]?   NOTA  Tambi\u00e9n podr\u00eda haber alguna pareja de archivo en l\u00edneas [overrides] o incluso [EQUIVALENTE]   F) Intenta iniciar el Unit ufw (o firewalld) todav\u00eda Enmascarado. Puedes? Desenmascara y vuelve a intentarlo. puedes ahora?  G) Ejecutar el comando  systemctl edit ufw  (o  systemctl edit firewalld  ) y, en el editor de texto que aparece, escribe la l\u00ednea Description = Hola amigo y guarda. A continuaci\u00f3n, ejecuta systemctl cat ufw (o systemctl cat firewalld ) . \u00bfQu\u00e9 ves? Y si vuelves a ejecutar systemd-delta ?    A) Crear un archivo llamado  /etc/systemd/system/pepe.service  con el siguiente contenido ...:    [Unit]\nDescription = Pepe se colega\n[Service]\nType = oneshot\nExecStart = / bin / ls -l\nExecStop = / bin / df -h\n[Install]\nWantedBy = multi-user.target  ... y a continuaci\u00f3n (despu\u00e9s de  systemctl daemon-reload ) ejecuta  systemctl start pepe  Qu\u00e9 ves? Y si haces  journalctl -e , \u00bfqu\u00e9 ves? \u00bfPor qu\u00e9?  B)  \u00bfQu\u00e9 deber\u00edas modificar del archivo anterior para que el comando  /bin/df -h  no se ejecutara justo despu\u00e9s de  /bin/ls -l  sino s\u00f3lo cuando se escriba  systemctl stop pepe  ? Pista: consulta la explicaci\u00f3n del tipo \"oneshot\" en la teor\u00eda. Pru\u00e9balo utilizando los comandos  systemctl -full edit pepe ,  systemctl daemon-reload  y, de nuevo,  journalctl -e  C) Para qu\u00e9 sirve la l\u00ednea  WantedBy = ...  ? O dicho de otro modo: \u00bfqu\u00e9 relaci\u00f3n tiene esta l\u00ednea con el comando  systemctl enable  ? Pista: observa el contenido de la carpeta  /etc/systemd/system/multi-user.target.wants  D) \u00bfQu\u00e9 deber\u00edas modificar del archivo anterior para que la salida de los comandos ejecutadas por la Unit (ya sea \u200b\u200ba ExectStart = o a ExecStop =) no vaya a parar al Journal sino que se visualice el terminal / dev / tty4? Pru\u00e9balo.  3.-a) Crear un script llamado  /opt/yeah  con el siguiente contenido (y dale permisos de ejecuci\u00f3n):  #!/bin/bash\nwhile [[true]]\ndo\ncurl -s ipinfo.io/ip\n/ Bin / sleep 3```\nd\u00e9  b) Crear un archivo llamado \"/etc/systemd/system/pepa.service\" con el siguiente contenido ...:  [Unit]\nDescription = Pepa se colega\n[Service]\nType = simple\nExecStartPre = / usr / bin / systemd-cat -t PEPA -p grito echo \"Empieza\"\nExecStart = / opt / yeah\nExecStop = / usr / bin / systemd-cat -t PEPA -p grito echo \"Termino\"\n# StandardOutput = null\n[Install]\nWantedBy = multi-user.target  ... y a continuaci\u00f3n (despu\u00e9s de  systemctl daemon-reload ) ejecuta  systemctl start pepa . Si haces  journalctl -f , que ves? \u00bfPor qu\u00e9? Y si ejecutas  systemctl stop pepa  , que ves entonces en el Journal? \u00bfPor qu\u00e9? Y si Descomentas la l\u00ednea que aparece comentada y vuelves a probar?  4.-a) Crear un archivo llamado \"fiufiu.service\" dentro de \"/ etc/systemd / system\" con el siguiente contenido ...:  [Unido]\nDescription = All we are saying is give peace a chance\n[Service]\nType = simple\nExecStart = /usr/bin/nc -l -p 5555\nRestart = on-success  ... y seguidamente ponerlo en marcha con el comando  sudo systemctl start fiufiu  . Comprueba con  systemctl status fiufiu  (o tambi\u00e9n con  ss -tnl  ) que se haya iniciado correctamente  b) Ejecutar el comando  journalctl -ef  y seguidamente, abre otro terminal para ejecutar en ellos el comando  nc 127.0.0.1 5555  . Escribe algo la conexi\u00f3n abierta para este cliente Netcat y observa a la vez lo que aparece en tiempo real en el Journal. \u00bfQu\u00e9 pasa? \u00bfPor qu\u00e9?  c) Cerrar el cliente y vuelve a ejecutar. \u00bfEl servicio sigue funcionando? Ahora comenta la l\u00ednea Restart = ... que aparece en el archivo fiufiu.service, reinicia el servicio y vuelve a ejecutar el cliente un par de veces. la primera\nvez deber\u00e1 conectarse sin problemas como siempre pero la segunda ya no. \u00bfPor qu\u00e9?  5.-a) Instal.la el paquete \"apache2\" y observa, ejecutando el comando  systemctl cat apache2  , el valor que tiene la directiva Restart =. Ejecuta entonces  systemctl --signal = 9 kill apache2  y comprueba con systemctl status\napache2 si el servicio reinicia solo o no. \u00bfPor qu\u00e9 pasa lo que pasa?  b) Cambiar ahora el valor de la directiva Restart = del Unit del Apache2 mediante  systemctl edit --full apache2  para que valga \"no\" (recuerda que escribir como primera l\u00ednea el t\u00edtulo de la secci\u00f3n a la que pertenece la directiva que quieres sobreescribir -es decir, [Service] -). Despu\u00e9s de hacer  systemctl daemon-reload  (y de comprobar que la modificaci\u00f3n es efectiva con  systemd-delta  o tambi\u00e9n  systemctl cat apache2 ) , inicia el servicio de nuevo y comprueba que efectivamente est\u00e9 iniciado. Vuelve a matar de nuevo con  systemctl -signal = 9 kill apache2  y vuelve a comprobar de nuevo si el servicio ha reiniciado autom\u00e1ticamente o no. \u00bfQu\u00e9 pasa ahora?  c) Agregar mediante  systemctl edit apache2  la l\u00ednea necesaria para llamar a una Unit que se encargue ejecutarse en el modo \"oneshot\" el comando  play /ruta/un/fitxer.mp3  cada vez que el Apache finalice debido a alguna situaci\u00f3n inesperada (como por ejemplo ser\u00eda una se\u00f1al kill 9)   NOTA  El comando play encarga de reproducir el archivo de sonido indicado y admite muchos formatos posibles, no s\u00f3lo mp3. Forma parte del paquete \"sox\"   6.a) Ejecuta  systemctl disable ufw  (o  systemctl disable firewalld  ) y seguidamente  systemctl show --property \"Wants\" multi-user.target | grep -E \"(ufw | firewalld) \" \u00bfQu\u00e9 ves? \u00bfPor qu\u00e9? Pista: observa el mensaje que\naparece en pantalla al deshabilitar el servicio ufw  b) Y si ahora ejecutas  systemctl enable ufw  (o  systemctl enable firewalld  ) y vuelves a ejecutar el mismo comando? \u00bfQu\u00e9 ves ahora? \u00bfPor qu\u00e9? Pista: observa el contenido de la carpeta /etc/systemd/system/multi-user.target.wants  c) Deduce y di por qu\u00e9 la l\u00ednea After = de la Unit ufw.service (o firewalld.service) tiene el valor que tiene.  d) systemd puede no ser el proceso INIT de nuestro sistema Linux: aunque sea el m\u00e1s extendido con diferencia, te puedes encontrar distribuciones que utilicen sistemas INIT alternativos. Dime, de los siguientes comandos,\ncu\u00e1les sirven para comprobar si el proceso INIT de tu sistema es systemd (o no):   file /sbin/init  man init  pgrep ^systemd $",
            "title": "EJERCICIOS"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#systemd-ii",
            "text": "",
            "title": "Systemd (II)"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#targets",
            "text": "Podemos definir un \"target\" como un \"estado\" del sistema definido por un determinado conjunto de servicios puestos en marcha (y otros que no). La idea es que, al arrancar el sistema, se llegue a un determinado \"target\" (Y, opcionalmente, a partir de all\u00ed, poder pasar a otro si fuera necesario). A continuaci\u00f3n se listan los \"targets\" m\u00e1s importantes (todos ellos ubicados dentro de  /usr/lib/systemd/system ):   poweroff.target  (o \"runlevel0.target\") Si se llega a este \"target\", se apaga el sistema  reboot.target  (o \"runlevel6.target\"): Si se llega a este \"target\", se reinicia el sistema  rescue.target  (o \"runlevel1.target\"): Si se llega a este \"target\", se inicia el sistema en modo texto,sin red y s\u00f3lo por el usuario root. Ser\u00eda similar a otro target llamado \" emergency.target \", pero el \"emergency\" es m\u00e1s \"radical\" que el \"rescate\" porque gracias a montar la partici\u00f3n ra\u00edz en modo s\u00f3lo lectura permite arrancar sistemas que el \"rescate\" quiz\u00e1s no puede.  multi-user.target  (o \"runlevel3.target\"): En este caso se inicia el sistema en modo texto pero con red y multiusuario (el target predeterminado en servidores)  graphical.target  (o \"runlevel5.target\"): En este caso, se inicia el sistema en modo gr\u00e1fico con red y multiusuario (el target por defecto en sistemas de escritorio) Implica haber pasado por el target \"multi-user\" previamente.   Otros targets predefinidos que se instalan con systemd y que hay que conocer son:    ctrl-alt-del.target  Target activado cuando es pulsado CTRL + ALT + SUPR. Por defecto es un enlace a \"reboot.target\"    sysinit.target  Target que ejecuta los primeros scripts de arranque    sockets.target  Target que activa, al arrancar, todas las Units de tipo \"socket\". Se recomienda, por tanto, que todos los archivos de configuraci\u00f3n de una Unit \"socket\" tengan a su l\u00ednea Wants = este target indicado (o bien WantedBy =)    timers.target  Target que activa, al arrancar, todas las Units de tipo \"timer\". Se recomienda, por tanto, que todos los archivos de configuraci\u00f3n de una Unit \"timer\" tengan a su l\u00ednea Wants = este target indicado (o bien WantedBy =)    paths.target  Target que activa, al arrancar, todas las Units de tipo \"path\". Se recomienda, por tanto, que todos los archivos de configuraci\u00f3n de una Unit \"path\" tengan a su l\u00ednea Wants = este target indicado (o bien WantedBy =)    swap.target  Target que habilita la memoria swap    basic.target  Target que pone en marcha todos los target relacionados con puntos de montaje, memorias swaps,paths, timers, sockets y otras unidades b\u00e1sicas necesarias para el funcionamiento del sistema.    initrd-fs.target  El generador systemd-fstab-generator a\u00f1ade autom\u00e1ticamente las Units indicadas en la directiva Before = de esta Unit a la Unit especial \"sysroot-usr.mount\" (adem\u00e1s de todos los puntos de montaje existentes en  /etc/fstab  que tengan establecidas las opciones \"auto\" y \"X-initrd.mount\"). Ver m\u00e1s adelante una explicaci\u00f3n de las Units de tipo mount.    initrd-root-fs.target  El generador systemd-fstab-generator a\u00f1ade autom\u00e1ticamente las Units indicadas en la directiva Before = de esta Unit a la Unit especial \"sysroot-usr.mount\", la cual es generada a partir de los par\u00e1metros del kernel. Lo estudiaremos m\u00e1s adelante    local-fs.target  El generador systemd-fstab-generator a\u00f1ade autom\u00e1ticamente las Units indicadas en la directiva Before = de esta Unit a todas las Units de tipo \"mount\" que se refieren a puntos de montaje locales. Tambi\u00e9n a\u00f1ade a este target las dependencias de tipo Wants = correspondientes a los puntos de montaje existentes en /etc/fstab que tienen la opci\u00f3n \"auto\" establecida. Ver m\u00e1s adelante una explicaci\u00f3n de las Units de tipo mount.    network-online.target  Target que se activa autom\u00e1ticamente en cuanto el subsistema de red es funcional.Cualquier servicio que tenga que trabajar en red se deber\u00e1 iniciar al menos en este target   NOTA  Existe otro tarjet relacionado con la red llamado \"pre-network.target\" que est\u00e1 pensado para iniciar servicios antes de que cualquier tarjeta de red se configure. Su prop\u00f3sito principal es hacerlo servir con servicios de tipo cortafuegos, para establecer las reglas antes de que la configuraci\u00f3n de red funcione. Estos servicios deber\u00e1n tener una l\u00ednea Before = network-pre.target y tambi\u00e9n una l\u00ednea Wants = network-pre.target en su archivo de configuraci\u00f3n     NOTA  Existe otro tarjet relacionado con la red llamado simplemente \"network.target\" que s\u00f3lo indica que el stack software de red ya se ha cargado en memoria pero esto no implica que las interfaces se hayan configurado todav\u00eda. este target est\u00e1 m\u00e1s pensado para el proceso de apagado de la m\u00e1quina para realizar este proceso de forma ordenada: pues la orden de apagado es al rev\u00e9s que el de arranque, cualquier Unit que tenga una l\u00ednea After = network.target apagar\u00e1 antes que la red se descargue y esto har\u00e1 que esta Unit apague sin interrumpir ninguna conexi\u00f3n que est\u00e9 pendiente     printer.target  Target que se activa autom\u00e1ticamente tan pronto como una impresora es enchufada o aparece disponible durante el arranque. Aqu\u00ed donde se suele iniciar, por ejemplo, el servicio Cups.    sound.target  Target que se activa autom\u00e1ticamente tan pronto como una tarjeta de audio es enchufada o aparece disponible durante el arranque.    bluetooth.target  Target que se activa autom\u00e1ticamente tan pronto como un controlador Bluetooth es enchufado o aparece disponible durante el arranque.    smartcard.target  Target que se activa autom\u00e1ticamente tan pronto como un controlador Smartcard es enchufado o aparece disponible durante el arranque.    system-update.target  Target especial utilizada para actualizaciones del sistema. El generador systemd-System- update-generator redireccionar\u00e1 el proceso de arranque autom\u00e1ticamente a este target si la carpeta /system-update existe    umount.target  Target que desmonta todos los puntos \"mount\" y \"automount\" durante el apagado del sistema     final.target  Target utilizado durante el apagado del sistema que puede utilizarse para apagar los \u00faltimos servicios despu\u00e9s de que los servicios \"normales\" ya se han detenido y los puntos de montaje se han desmontado.    Para saber el target donde nos encontramos en este momento podemos hacer:  systemctl get-default  Hay que tener en cuenta que m\u00faltiples targets pueden estar activados a la vez. Un target activado indica que systemd ha intentado iniciar todas las Units asociadas a este target. Esto significa que el comando anterior s\u00f3lo nos dice cu\u00e1l es el target \"final\" donde hemos llegado, pero a lo largo del camino desde el arranque de la m\u00e1quina hasta llegar a este target \"final\" se han ido activando diferentes targets a modo de \"escalones\" intermedios. para\nver todos los targets activados, hay que hacer  systemctl list-Units -type = target  Se puede cambiar el target actual a otro simplemente ejecutando:  systemctl Isolate nomTargetDesti.target    Para cambiar el target por defecto donde ir\u00e1 a parar autom\u00e1ticamente a cada arranque del sistema se puede hacer:  systemctl set-default nomTargetDefecte.target   Nota  El comando anterior, en realidad lo \u00fanico que hace es revincular el link \"/etc/systemd/system/default.target\" en el archivo * .Target adecuado.    Nota  Otra manera de entrar al final del arranque del sistema en un determinado target predeterminado es a\u00f1adir la l\u00ednea systemd.unit = nomTargetDestino.target a la lista de par\u00e1metros del kernel indicada en la configuraci\u00f3n del gestor de arranque. Hay una serie de comandos espec\u00edficos para pasar a determinados estados (poweroff, reboot, etc) que se pueden usar en vez del comando systemctl Isolate gen\u00e9rica. Por ejemplo:\n     sudo systemctl rescue  : Similar a  systemctl Isolate rescue.target \n     sudo systemctl poweroff  (o  sudo poweroff  a secas): Similar a -   systemctl Isolate poweroff.target \n    sudo systemctl reboot (o sudo reboot a secas): Similar a systemctl Isolate reboot.target   Si se quiere detener (-P) o reiniciar (-r) la m\u00e1quina en un momento futuro determinado (hh: mm), entonces habr\u00e1 que ejecutar el comando:  sudo shutdown {-P | -r} hh: mm  Si se quiere detener (-P) o reiniciar (-r) la m\u00e1quina dentro de una cierta cantidad de minutos, entonces habr\u00e1 que ejecutar el comando:  sudo shutdown {-P | -r} + m   Nota  Dentro de la carpeta  /usr/lib/systemd/system-shutdown  pueden haber archivos * .shutdown, que son scripts ejecutables que se ejecutar\u00e1n justo antes del apagado / reinicio del sistema (es decir, justo al poner en marcha los servicios \"poweroff.service\" o \"Reboot.service\"). Quien ejecutar\u00e1 estos scripts es el binario /usr/lib/systemd/systemd-shutdown, el cual es invocado siempre por estos servicios, que lo colocan como PID 1 y es el responsable de desmontar los sistemas de ficheros, deshabilitar la swap, matar los procesos que queden pendientes, etc. En los scripts ejecutados por /usr/lib/systemd/systemd-shutdown podemos utilizar un par\u00e1metro ($1) que puede valer \"poweroff\" o \"reboot\" dependiendo de la acci\u00f3n que realizar\u00e1 y que nos podr\u00eda servir para distinguir qu\u00e9 queremos que haga este script seg\u00fan la acci\u00f3n indicada. Todos los scripts se ejecutan en paralelo. Hay que tener en cuenta, finalmente, que el sistema de ficheros en ese momento permanece montado pero en modo s\u00f3lo lectura.    Nota  En el comando systemctl reboot le podemos a\u00f1adir varios par\u00e1metros interesantes, los cuales s\u00f3lo funcionan, sin embargo, en sistemas UEFI que han arrancado mediante el gestor de arranque systemd-boot:   --firmware-setup : INDICATE to the system s firmware to reboot into the firmware setup interface (aka the \"UEFI control panel\")  --boot-loader-menu = n\u00basegons : INDICATE to the system s boot loader to show the boot loader menu on the following boot the number of seconds specified as value. Pass 0 value in order to disable the menu timeout.  -boot-loader-entry = entryID : INDICATE to the system s boot loader to boot into a specific boot loader entry on the following boot.    Lo que hacen los par\u00e1metros anteriores es modificar determinados valores de variables EFI concretas (tal como se podr\u00eda haber hecho tambi\u00e9n con el comando efibootmgr ) para as\u00ed modificar el comportamiento de la UEFI el pr\u00f3ximo arranque  Por otra parte, con el comando sudo systemctl suspend podemos suspender el sistema (o dicho de otro manera, nos permiten llegar al target suspend.target\") y con el comando sudo systemctl hibernate la\npodemos poner a hibernar (o dicho de otro modo, permiten llegar al target \"hibernate.target\").  \"Suspender\" significa que se guarda todo el estado del sistema en la RAM y se apaga la mayor\u00eda de dispositivos de la m\u00e1quina; cuando se pone en marcha de nuevo, el sistema restaura su estado previo de la RAM sin tener que reiniciarse\nde nuevo: este proceso es muy r\u00e1pido pero tiene el inconveniente de que obliga a mantener con alimentaci\u00f3n el\u00e9ctrica la m\u00e1quina todo el tiempo.   \"Hibernar\" significa que se guarda todo el estado del sistema en el disco duro (si tiene espacio libre) y se apaga por completo la m\u00e1quina: cuando se pone en marcha de nuevo, el sistema restaura su estado previo desde el disco duro sin tener que reiniciar de nuevo: este proceso es bastante lento pero tiene la ventaja de no tener que mantener con alimentaci\u00f3n el\u00e9ctrica la m\u00e1quina.   Nota  Dentro de la carpeta \"/ usr / lib / systemd / system-sleep\" pueden haber archivos * .sleep, que son scripts ejecutables que se ejecutar\u00e1n justo antes de la hibernaci\u00f3n o suspensi\u00f3n del sistema (es decir, justo en poner en marcha internamente los servicios \"systemd-hibernate.service \"o\" systemd-suspend.service \", los cuales, por cierto, nunca deben ser invocados directamente con systemctl start ... sino utilizando los comandos explicadas en el p\u00e1rrafo anterior: systemctl hibernate o systemctl suspend ). Quien ejecutar\u00e1 estos scripts es el binario / usr / lib / systemd / systemd-sleep, el cual es invocado siempre por estos servicios y admite dos par\u00e1metros que podemos utilizar en estos scripts como $ 1 y $ 2 respectivamente. El primer par\u00e1metro puede valer \"pre\" o \"post\" dependiendo de si la m\u00e1quina est\u00e1 yendo a la suspensi\u00f3n / hibernaci\u00f3n o est\u00e1 volviendo, respectivamente. El segundo par\u00e1metro puede valer \"suspend\" o \"hibernate\" dependiendo de la acci\u00f3n que realizar\u00e1 y que nos podr\u00eda server para distinguir qu\u00e9 queremos que haga este script seg\u00fan la acci\u00f3n indicada. Todos los scripts ejecutan en paralelo.   Si se quiere realizar una tarea larga y asegurarse de que la m\u00e1quina no se suspender\u00e1 o apagar\u00e1 mientras tanto,\nse puede invocar el comando correspondiente a esta tarea as\u00ed: systemd-inhibido comanda_llarga El comando\nsystemd-inhibido --list muestra las tareas que tienen este truco en marcha. Si se quiere especificar una acci\u00f3n\nconcreta a inhibir se puede indicar con el par\u00e1metro - what = acci\u00f3n , donde \"acci\u00f3n\" puede ser por ejemplo la palabra\n\"Shutdown\" o \"sleep\" (equivalente a hibernaci\u00f3n o suspensi\u00f3n), entre otros. Encontrar\u00e1 m\u00e1s informaci\u00f3n en los\nprimeros p\u00e1rrafos de https://www.freedesktop.org/wiki/Software/systemd/inhibit/\nPara que el inicio con systemctl start de un determinado servicio (o target) se produzca dentro de un target\ndeterminado -llamado-el \"a.target\" - desde el propio archivo de configuraci\u00f3n del servicio en cuesti\u00f3n hay que escribir\nlas directivas Wants = a.target, Requires = a.target y / o After = a.target (estas directivas se aseguran de llegar\nprimero al target \"a.target\" para iniciar entonces el servicio en cuesti\u00f3n). Por otra parte, tambi\u00e9n existe la directiva\nConflicts = a.target , la que se asegura de no estar en el target \"a.target\" para poder iniciar el servicio en cuesti\u00f3n.\nEn el caso de querer iniciar siempre un servicio determinado autom\u00e1ticamente en el target \"a.target\", entonces\nhabr\u00e1 que escribir adem\u00e1s las directivas WantedBy = a.target o RequiredBy = a.target del archivo de configuraci\u00f3n del\nservicio (en este \u00faltimo caso, al hacer systemctl enable nomServei se crea un enlace a su archivo de configuraci\u00f3n\ndentro de \"/lib/systemd/system/a.target.wants\").\nLos archivos de configuraci\u00f3n de los targets s\u00f3lo tienen secciones [Unido] (y muy pocas la secci\u00f3n\n[Install]). En este sentido, es interesante consultar los archivos correspondientes, por ejemplo, a multi-user.target\no graphical.target: s\u00f3lo encontramos las directivas Description, Documentation, Wants, Requires, After,\nConflicts y AllowIsolate (ya partir de ellas podemos deducir las dependencias que hay entre targets ... aunque\npor eso hay comandos espec\u00edficos que enseguida veremos).",
            "title": "targets"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#ejercicios_1",
            "text": "Crear un target nuevo llamado \"manolo.target\" donde el sistema deber\u00e1 entrar justo despu\u00e9s de activar graphical.target (es decir, debe ser el \u00faltimo target al activarse). La idea ser\u00e1 asegurarte de que entras en este target para ejecutar un determinado servicio (lo llamaremos \"manolo.service\") el \u00faltimo de todos. para hacer esto, tienes que hacer lo siguiente:  A) Crear un nuevo fichero llamado \"/etc/systemd/system/manolo.target\" con el siguiente contenido:  [Unit]\nDescription = Manolo is kind\nDocumentation = http: //www.lecturas.com\nRequires = graphical.target\nAfter = graphical.target\nConflicts = rescue.service rescue.target\nAllowIsolate = yes  B) Crear un nuevo fichero llamado \"/etc/systemd/system/manolo.service\" con el siguiente contenido:  [Unit]\nDescription = Manolo is soberbio\nDocumentation = http: //www.hola.com\nRequires = manolo.target\nAfter = manolo.target\n[Service]\nExecStart = / usr / bin / printf \"MANOLO \\ n\"\nRemainAfterExit = yes\n[Install]\nWantedBy = manolo.target  C) Ejecutar systemctl enable manolo.service y reinicia la m\u00e1quina. \u00bfCrees que el servicio \"manolo\" estar\u00e1 funcionando autom\u00e1ticamente o no? \u00bfPor qu\u00e9 lo crees? Compru\u00e9balo ejecutando el comando  systemctl status manolo.service  (o tambi\u00e9n observando si aparece la palabra \"MANOLO\" en el Journal). PISTA: La respuesta de porque el servicio \"manolo\" estar\u00e1 funcionando (o no) se encuentra en lo que muestra el comando  systemctl list-Units -t target | grep \"manolo\"  y en entender el significado de la l\u00ednea WantedBy =  D) A continuaci\u00f3n ejecuta systemctl start manolo.service . Despu\u00e9s de observar que el servicio se haya puesto en marcha\ncorrectamente (en la salida del comando systemctl status manolo.service o tambi\u00e9n observando si aparece la\npalabra \"MANOLO\" en el Journal), \u00bfcrees que el comando systemctl list-Units -t target | grep \"manolo\"\nmostrar\u00e1 algo diferente respecto del apartado anterior? \u00bfPor qu\u00e9 lo crees? PISTA: La respuesta se encuentra en\nentender el significado de las l\u00edneas Requires = y After = del archivo \"manolo.service\"  e) Ejecutar systemctl set-default manolo.target y vuelve a reiniciar la m\u00e1quina. \u00bfCrees que el servicio \"manolo\" ahora estar\u00e1 funcionando autom\u00e1ticamente o no? \u00bfPor qu\u00e9 lo crees? Compru\u00e9balo ejecutando el comando systemctl status manolo.service (o tambi\u00e9n observando si aparece la palabra \"MANOLO\" en el Journal). PISTA: La respuesta se encuentra en entender el significado de las l\u00edneas Requires = y After = del archivo \"manolo.target\"    A) Entra en el target de rescate. \u00bfQu\u00e9 pasa?  B) Entra en el target de suspensi\u00f3n. \u00bfQu\u00e9 pasa?  C) Entra en el target multi-user. \u00bfQu\u00e9 pasa?  D) Crear un script ejecutable dentro de la carpeta \"/usr/lib/systemd/system-sleep\" con el siguiente contenido ...:  #! / Bin / bash\nif [[ \"$ 1\" == \"pre\"]]\nthen\necho \"we are suspending oro hibernating at $ (date) ...\"> / tmp / systemd_suspend_test\nElif [[ \"$ 1\" == \"post\"]]\nthen\necho \"... and we are back from $ (date)\" >> / tmp / systemd_suspend_test\nfin  ... y prueba a suspender el sistema y volver a \"despertar\". \u00bfQu\u00e9 pasar\u00e1?    e) \u00bfPara qu\u00e9 sirve este programa: https://github.com/ryran/reboot-guard ?  boot chain \uf0c1  Para saber la jerarqu\u00eda de dependencias de targets para llegar a iniciar un target (o service!) Determinado se puede utilizar el comando:  systemctl list-dependencies nomTarget.target  (o nomUnit.service )   Nota  Una forma alternativa de obtener una informaci\u00f3n similar ser\u00eda ejecutando  systemctl show -p \"Wants\" nomTarget.target && systemctl show -p \"Requires\" nomTarget.target  . Tambi\u00e9n se puede ejecutar  systemctl status  Las dependencias mostradas se corresponden a Units que han sido \"required\" o \"wanted\" por las Units superiores. Las dependencias recursivas s\u00f3lo se muestran los targets intermedios; si se quieren ver tambi\u00e9n por los service, mounts paths, socket, etc intermedios hay que incluir el par\u00e1metro --all al comando anterior.   Tambi\u00e9n se pueden mostrar cu\u00e1les Units dependen para funcionar del correcto inicio de un target (o service!) determinado con el comando:  systemctl list-dependencias --reverse nomTarget.target  (o nomUnit.service )   Nota  Una forma alternativa de obtener una informaci\u00f3n similar ser\u00eda ejecutando  systemctl show -p \"WantedBy\" nomTarget.target && systemctl show -p \"RequiredBy\" nomTarget.target   Otros par\u00e1metros interesantes de este comando son --before y - after , los cuales sirven para mostrar Units que dependen para funcionar del correcto inicio anterior o posterior de un target, respectivamente.  Por otra parte, respecto al arranque del sistema podemos obtener una informaci\u00f3n m\u00e1s detallada sobre los tiempos que tarda cada Unit en cargarse y el orden en que lo hace gracias al comando systemd-analyze, tiene varias posibilidades    systemd-analyze  : Muestra el tiempo total empleado en el arranque del sistema y qu\u00e9 parte de este tiempo ha sido\nempleado en tareas del kernel, qu\u00e9 parte en uso de initrd y qu\u00e9 parte en tareas de usuario    systemd-analyze blame  : Muestra los tiempos disgregados por servicio. Hay que indicar que estos tiempos son \"en paralelo \", as\u00ed que la suma total que sale ser\u00e1 siempre muy superior al tiempo real empleado en el arranque.    systemd-analyze dot [nomTarget.target] | dot -T {png | svg} -o foto. {png | svg}  : Genera una salida que si se pasa a la aplicaci\u00f3n \"dot\" (perteneciente al paquete \"GraphViz\") generar\u00e1 finalmente un gr\u00e1fico (En formato png o svg) donde se pueden visualizar todas las dependencias del target (o servicio!) indicado (o, si no se indica, del \"default.target\"; tambi\u00e9n se pueden indicar comodines en el nombre del target / servicio).    systemd-analyze plot [nomTarget.target]> something.svg  : Genera un gr\u00e1fico donde se muestra los tiempos de ejecuci\u00f3n y de bloqueo de cada Unit durante el arranque hasta llegar al target (o servicio!) indicado (o, si no se indica, del \"default.target\")    systemd-analyze critical-chain [nomTarget.target]  : Muestra el \u00e1rbol de dependencias bloqueantes por target (o servicio!) indicado. El tiempo mostrado despu\u00e9s de \"@\" indica el tiempo que hace que la Unit est\u00e1 activa; el tiempo\nmostrado despu\u00e9s de \"+\" indica el tiempo que la Unit ha tardado en activarse.\nOtras opciones del comando  systemd-analyze  son syscall-filter, verify, dump, log-level, security, time ...Se puede ver si, una vez iniciado el sistema, a\u00fan quedan tareas pertenecientes al arranque para completar ejecutando el comando  systemctl list-jobs    EJERCICIOS: \uf0c1  1.- a) \u00bfQu\u00e9 targets deben haberse iniciado para que el servicio gdm se pueda poner en marcha? (esto lo puedes saber con el comando systemctl list-dependencies ... )  b) Ejecutar el comando systemctl  list-dependencies --reverse gdm.service  Qu\u00e9 ves?  c) \u00bfQu\u00e9 hace el comando tree / etc / systemd / system y para qu\u00e9 podr\u00eda servirte?  2.-a) Ejecutar systemd-analyze plot ... y observa qu\u00e9 Unit bloquea m\u00e1s tiempo el arranque de tu sistema. prueba de desactivarla (esperemos no romper nada!) y reinicia. Ejecuta ahora systemd-analyze blame para comprobar si el\ntiempo total de arranque ha disminuido efectivamente.  b) Instal.la el paquete \"GraphViz\" y genera un gr\u00e1fico Png con las dependencias del target multi-user. Haz una lista de las dependencias all\u00ed mostradas y adjunta la captura del gr\u00e1fico plantillas Una plantilla es un archivo de configuraci\u00f3n de tipo \"service\" que tiene la particularidad de permitir poner en marcha variantes de un mismo servicio sin tener que escribir un archivo \"service\" diferente para cada variante.\nB\u00e1sicamente, para utilizar una plantilla hay que hacer los siguientes pasos:\n1.- El archivo \"service\" que har\u00e1 de plantilla debe llamarse \"nomServei @ .service\". Es decir, hay que indicar\nel s\u00edmbolo arroba antes del punto\n2.- El contenido de este archivo plantilla puede ser exactamente igual que el de un archivo \"service\" est\u00e1ndar\n3.- A la hora de iniciar, parar, activar, desactivar, ver el estado, etc de una plantilla, se deber\u00e1 indicar\nel identificador concreto de la variante con la que queremos trabajar. Este identificador se establece la\nprimera vez que arranca la variante y simplemente consiste en una cadena entre la arroba y el punto,\nas\u00ed: systemctl start nomServei @ identificador. service A partir de aqu\u00ed, este identificador se har\u00e1\nservir de la misma manera por el resto de tareas relacionadas con la gesti\u00f3n de esta variante\nNOTA: An instance file is usually created as a symbolic link to the template file, with the link name including the instance\nidentifier. In this way, multiple links with unique Identifiers can point back to a single template file. When managing a\u00f1o\ninstance Unit, systemd will look for a file with the exact instance name you Specify on the command line to use but if it\ncan not find one, it will look for an associated template file.\n4.- La gracia de las plantillas es que el valor del identificador indicado en el punto anterior se puede utilizar\ndin\u00e1micamente dentro del contenido del archivo plantilla (concretamente mediante el s\u00edmbolo \" % y \"), de\nlo que seg\u00fan el valor que haya adquirido% y por esa variante se podr\u00eda poner en marcha el\nservicio escuchando en un puerto diferente (si% y representa un n\u00famero de puerto), o bien utilizando un archivo de\nconfiguraci\u00f3n diferente (si% y representa un nombre de archivo), o lo que nos convenga.\nNOTA: Otros s\u00edmbolos especiales que se pueden indicar en un archivo de configuraci\u00f3n de una plantilla pueden ser\n% p : representa the Unit name prefijo (this is the Portion of the Unit name that comes before the @ symbol)\n% n : representa the full resulting Unit name (% p plus% e)\n% u : The name of the user configured to run the Unit.\n% U : The same as above, but as a numeric UID instead of name.\n% H : The host name of the system that is running the Unit.\n%% : This is used to insert a literal percentage sign.\nPage 20\nPongamos un ejemplo. Imaginemos que tenemos un determinado servidor web que queremos ejecutar con dos\nconfiguraciones diferentes a la vez. La soluci\u00f3n ser\u00eda crear un archivo plantilla llamado por ejemplo\n\"Servidorweb @ .service\" con un contenido similar al siguiente:\n[Unido]\nDescription = My HTTP server\n[Service]\nType = simple\nExecStart = / usr / sbin / WebServer --config-file /etc/%i.conf\n[Install]\nWantedBy = multi-user.target\nCon este archivo, se podr\u00eda iniciar entonces el servidor dos veces, cada una indicando el nombre del archivo de\nconfiguraci\u00f3n deseado, as\u00ed:\nsudo systemctl start servidorweb@config1.service\nsudo systemctl start servidorweb@config2.service\nLos comandos anteriores lo que har\u00e1n ser\u00e1 ejecutar, respectivamente, los comandos: / usr / sbin / WebServer -\nconfig-file /etc/config1.conf y / usr / sbin / WebServer -config-file /etc/config2.conf\nEJERCICIOS:\n1.-a) Crear un archivo plantilla que permita poner en marcha diferentes servidores Ncat de forma permanente\n(Recuerda el par\u00e1metro -k) escuchando cada uno de ellos en un puerto diferente.\nNOTA: Deber\u00e1s instalar el paquete \"nmap\" para disponer del comando ncat\nb) Iniciar un servidor Ncat a partir de la plantilla anterior escuchando en el puerto 2.222 y otro escuchando en el puerto\n3333. Comprueba que, efectivamente, estos dos puertos est\u00e9n abiertos observando la salida del comando ss\n-tnl\nc) Conecta con el cliente Ncat a uno de los servidores anteriores y env\u00edale alg\u00fan mensaje. Cerrar el cliente (con\nCTRL + C) y ahora vuelve a ejecutarlo para conectar al otro servidor; vuelve a enviarle alg\u00fan otro mensaje y\nci\u00e9rralo de nuevo. Observa las \u00faltimas l\u00edneas del Journal: \u00bfqu\u00e9 ves?\n2.- Lee el siguiente p\u00e1rrafo y seguidamente contesta:\nWhen the user switches consolas using Ctrl + Alt + F2, Ctrl + Alt + F3, and so on, a new terminal then is spawned. in this\ncase systemd callos a service named getty @ .service providing the appropriate argumento such as tty2 oro tty3 to the Unit\nfile. The% y identifier provides this argumento value to the agetty binary sonido the terminal starts on that new console (as it\ncan seen in ExecStart = line from template file).\na) Para qu\u00e9 sirve el comando agetty? Busca en su p\u00e1gina del manual que hace su par\u00e1metro -ay\na\u00f1\u00e1delo a la invocaci\u00f3n del comando escrita a la l\u00ednea ExecStart de dentro del archivo getty @ .service (recuerda\nde ejecutar sudo systemctl daemon-reload justo despu\u00e9s). \u00bfQu\u00e9 pasa ahora cuando pulses Ctrl + Alt + F2, etc?\nb) enmascarado la instancia tty5 de la plantilla getty @ .service. \u00bfQu\u00e9 pasa ahora si haces Ctrl + Alt + F5?\nNOTA: Es posible que tambi\u00e9n hayas de enmascarar la plantilla autovt @ .service para que funcione el ejercicio\nNOTA: Hay otras maneras m\u00e1s sofisticadas de desactivar terminales virtuales pero las veremos m\u00e1s adelante\nc) \u00bfQu\u00e9 te muestra el comando systemctl status getty @ * ?\nPage 21\n3.- Supone que tienes un archivo llamado \"/etc/systemd/system/pepe@.service\" con el siguiente contenido:\n[Unido]\nDescription = lerele\n[Service]\nType = oneshot\nExecStart = / usr / local / bin / systemd-email% y admin@elpuig.xeill.net\nUser = nobody\nGroup = systemd-journal\ndonde \"systemd-email\" es un bash shell script escrito por nosotros dise\u00f1ado para enviar correos (suponiendo que\ntenemos un servidor Postfix o similar configurado en la m\u00e1quina) que tiene el siguiente c\u00f3digo:",
            "title": "EJERCICIOS:"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#bin-bash",
            "text": "systemctl status -full \"$ 1\" | mail -s \"$ 1\" $ 2\ny supone que has a\u00f1adido la l\u00ednea OnFailure=pepe@%i.service en la secci\u00f3n [Unido] del archivo \".service\"\ncorrespondiente al / los servicio / s que quiere monitorear.\na) \u00bfCu\u00e1l comando deber\u00edas ejecutar para poner en marcha una instancia del servicio-plantilla pepe @ que\nse encargan de enviar mails en el momento que el servicio Cups falle?\nsockets\nUn aspecto muy interesante de systemd es que permite que un servidor no est\u00e9 permanentemente\nencendido sino que s\u00f3lo arranque \"bajo demanda\" (es decir, cuando detecte una conexi\u00f3n, normalmente externa).\nDe este modo, este servidor no consume m\u00e1s recursos que los m\u00ednimos imprescindibles, en el momento\njusto. Para lograr esto, lo que pasa es que s\u00ed hay un componente \"escuchando\" todo el rato posibles\nintentos de conexiones, pero este componente no es la Unit \"service\" en s\u00ed sino un \"perro guardi\u00e1n\" que\ns\u00f3lo despertar\u00e1 Unit \"service\" cuando sea necesario. Este \"perro guardi\u00e1n\" es la Unit de tipo \"socket\".\nCada archivo de configuraci\u00f3n de una Unit \"socket\" debe tener exactamente el mismo nombre que el archivo de\nconfiguraci\u00f3n de la Unit \"service\" que quiere despertar (es decir, si tenemos el servicio \"a.service\", el socket\ncorrespondiente deber\u00e1 llamarse \"a.socket\"). La idea es tener la Unit \"socket\" siempre encendido ( systemctl\nenable a.socket ) pero la Unit \"service\" no ( systemctl disable a.service ); cuando se detecte una conexi\u00f3n, el\n\"socket\" autom\u00e1ticamente encender\u00e1 la Unit \"service\" (esto se puede ver haciendo systemctl status a.service mientras\nexiste la conexi\u00f3n) y la apagar\u00e1 de nuevo pasado un determinado tiempo sin actividad (por defecto 5 minutos).\nObviamente, si par\u00e1ramos el \"socket\" ( systemctl stop a.socket ) o el deshabilit\u00e9ssim el pr\u00f3ximo reinicio ( systemctl\ndisable a.socket ) ya no habr\u00eda \"perro guardi\u00e1n\" atento y, por tanto, el servicio ya no se pondr\u00eda en marcha\nautom\u00e1ticamente.\nPara cambiar el puerto donde escucha un \"socket\" (entre otras cosas) hay que modificar la configuraci\u00f3n del\n\"Socket\" propiamente dicho y eso no depende de la configuraci\u00f3n del servidor en cuesti\u00f3n. Los archivos de configuraci\u00f3n\nde cada \"socket\" se pueden encontrar, como cualquier otra Unit, o bien dentro de la carpeta \"/ usr / lib / systemd / system\"\no bien dentro de \"/ etc / systemd / system\" y se puede utilizar igualmente el comando systemctl edit a.socket para\ngenerar archivos \"override\". La secci\u00f3n que nos interesa en estos tipos de ficheros es la secci\u00f3n [Socket] , lo\npuede contener alguna de las siguientes directivas m\u00e1s importantes:\nListenStream = [IP:] n\u00baport\nIndica el n\u00famero de puerto TCP por donde escuchar\u00e1 el socket. Opcionalmente, se puede indicar una IP\nconcreta para especificar que s\u00f3lo escuchar\u00e1 en el puerto ofrecido por aquella IP y ninguna m\u00e1s.\nNOTA: Se pueden indicar varias l\u00edneas ListemStream para hacer que el socket escuche en varios puertos a la vez. Por otra parte,\ncomo que esta l\u00ednea puede estar escrita en diferentes archivos, si se quiere asegurar que s\u00f3lo se escuche en un puerto concreto sin\ntener en cuenta otras l\u00edneas que pueda haber le\u00eddo systemd previamente, se puede a\u00f1adir primero una l\u00ednea ListemStream vac\u00eda\n(as\u00ed: ListemStream = ) y luego la l\u00ednea ListenStream asociada al puerto deseado; lo que hace la l\u00ednea ListemStream vac\u00eda es\n\"resetear\" todas las l\u00edneas ListemStream anteriores\nPage 22\nListenDatagram = [IP:] n\u00baport\nIndica el n\u00famero de puerto UDP por donde escuchar\u00e1 el socket. Opcionalmente, se puede indicar una IP\nconcreta para especificar que s\u00f3lo escuchar\u00e1 en el puerto ofrecido por aquella IP y ninguna m\u00e1s.\nListenSequentialPacket = / ruta / arxiu.socket\nIndica el socket de tipo UNIX por donde se escuchar\u00e1. S\u00f3lo sirve para comunicaciones entre\nprocesos de la misma m\u00e1quina\nService = unNomAlternatiu\nSi el nombre del archivo \"service\" no es igual que el nombre del archivo \"socket\", aqu\u00ed se puede indicar\nentonces el nombre que tiene el archivo \"service\" para que el socket el sepa encontrar.\nAccept = yes\nSi se indica, hace que se genere una instancia del servicio diferente para cada conexi\u00f3n. \u00datil cuando se\nutilizan plantillas. Si su valor es no (por defecto) s\u00f3lo una instancia del servicio\ngestionar\u00e1 todas las conexiones.\nEl comando systemctl status * .socket nos permite saber cu\u00e1ntos y cu\u00e1les sockets est\u00e1n escuchando ahora\nmismo; el valor \"Accepted\" muestra cu\u00e1ntas conexiones se han realizado en total desde que el socket ha sido\niniciado y el valor \"Connected\" muestra cu\u00e1ntas conexiones est\u00e1n actualmente activas\nComo cualquier otra Unit, se pueden ver la lista de sockets con el comando s ystemctl list-Units -t\nsocket pero adem\u00e1s disponemos del comando espec\u00edfica systemctl list-sockets , la cual informa de qu\u00e9 servicio\ncorrespondiente activan y en qu\u00e9 puerto / socket UNIX escuchan.\nEJERCICIOS:\n1.-a) Crea el fichero \"/etc/systemd/system/dateserver.socket\" con el siguiente contenido:\n[Unido]\nDescription = Servicio de fecha en el puerto 55555\n[Socket]\nListenStream = 55555\nAccept = true\n[Install]\nWantedBy = sockets.target\nb) Crear el fichero \"/etc/systemd/system/dateserver@.service\" con el siguiente contenido:\n[Unido]\nDescription = Servicio de fecha\n[Service]\nType = simple\nExecStart = / opt / dateserver.sh\nStandardOutput = socket\nStandardError = journal\nc) Crear el fichero \"/opt/dateserver.sh\" con el siguiente contenido (y dale permisos de ejecuci\u00f3n!):",
            "title": "! / Bin / bash"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#bin-bash_1",
            "text": "while [[true]]\ndo\nPage 23",
            "title": "! / Bin / bash"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#atencion-comprueba-que-date-se-encuentre-dentro-de-usr-bin-dependiendo-de-la-distribucion-eso-cambia",
            "text": "/ Usr / bin / date\nsleep 1\nd\u00e9\nd) Abre un terminal y ejecuta el comando nc ipServidor 55555 . \u00bfQu\u00e9 ves? Abre otro terminal diferente y\nejecuta el mismo comando. \u00bfQu\u00e9 ves? \u00bfQu\u00e9 te muestra el comando systemctl status dateserver.socket ? \u00bfY la\ncomando systemctl status dateserver @ * ? \u00bfY el comando systemctl list-Units dateserver @ * ?\n2.- Haz que el servidor SSH que tengas instal.lat a la m\u00e1quina (si no lo tienes, instal.la'l) inicie s\u00f3lo a trav\u00e9s\nde un socket. concretamente:\na) Crear el fichero \"/etc/systemd/system/sshMitjo.socket\" con el siguiente contenido:\n[Unido]\nDescription = Mi SSH Socket\n[Socket]\nListenStream = 22\nAccept = yes\n[Install]\nWantedBy = sockets.target\nb) Crear el fichero \"/etc/systemd/system/sshMitjo@.service\" con el siguiente contenido:\n[Unido]\nDescription = Mi SSH Server\n[Service]\nType = simple\nExecStart = - / usr / sbin / sshd -y\nStandardInput = socket\nStandardOutput = socket\nNOTA: Aqu\u00ed la clave est\u00e1 en la combinaci\u00f3n del par\u00e1metro -y del binario sshd (el cual hace que habilitar la posibilidad de que pueda recibir\npeticiones a trav\u00e9s de sockets), y la directiva StandardInput (lo realiza de forma efectiva este tipo de comunicaci\u00f3n entre el\nsocket y el servidor SSH)\nNOTA: Importante is the \"-\" in front of the binary name. This ENSUR that the exit status of the para-connection sshd process is\nforgotten by systemd. Normally, systemd will store the exit status of a all service instances that die abnormally. SSH will sometimes\ndie abnormally with an exit code of 1 oro similar, and we want to make sure that this does not cause systemd to keep around\ninformation for numerous previous connections that died this way (until this information is forgotten with systemctl reset-failed).\nc) Ejecutar el comando systemctl enable sshMitjo.socket y systemctl disable ssh.service (si fuera necesario) y reinicia\nla m\u00e1quina. Una vez hecho, comprueba que el socket sshMitjo est\u00e9 funcionando pero no el servicio sshMitjo.\nEjecuta ssh usuario @ ipServidor para entrar en el servidor SSH (deber\u00edas de conseguir sin problemas) y\ncomprueba seguidamente que ahora s\u00ed est\u00e1 funcionando una instancia del servicio sshMitjo\nd) \u00bfQu\u00e9 har\u00eda un comando como systemctl killsshd@172.31.0.52 : 22-172.31.0.4: 47779.service?\nPage 24\n3.-a) En el ejercicio anterior hemos tenido la suerte de que el servidor SSH ofrece un par\u00e1metro (-y) que le permite\ndelegar la apertura de los sockets (puertos) a un \"agente externo\" como es systemd. Pero no siempre tendremos un\nservidor que ofrezca esta posibilidad. En este sentido, lee los siguientes p\u00e1rrafos y resumen con las\ntus propias palabras que explica:\nOne of the limitations of socket activaci\u00f3n is that it requires the activated application to be aware that it may be socket-activated; the\nprocess of accepting an existing socket is different from creating a listening socket from scratch. Consequently a lot of widely used\napplications do not support it. The systemd developers have known that it may take some time to get activaci\u00f3n apoyo everywhere, sonido\nthey Introduced \"systemd-socket-proxyd\", a small TCP and Unix domain socket proxy server. This does understand activaci\u00f3n, and\nwill sit between the network and our server, transparently forwarding packets between the two. The steps to use this tool are:\nStep 1: We create a socket that Listener on the puerto that will eventually be served by the proxy / server combination.\nStep 2: On the first connection to the socket systemd activados the proxy service and hands it the socket.\nStep 3: When the proxy is started the corresponding server is first Broughten up (thanks to the Requires / After dependency)\nThe proxy then shuttles all traffic between the server and the network. The only trick here is that we need to bind the server to a puerto\nother than the real-target puerto (8080 instead of 80 if we are running a webserver, for instance). This is because that puerto will be\nowned by the socket / proxy, and you can not bind two processes to the same socket and interface.\nStep 1: \"myserver-proxy.socket\" file\n[Socket]\nListenStream = 0.0.0.0: 80\n[Install]\nWantedBy = sockets.target\nStep 2: \"myserver-proxy.service\" file\n[Unido]\nRequires = myserver.service\nAfter = myserver.service\n[Service]\nExecStart = / usr / lib / systemd / systemd-socket-proxyd 127.0.0.1:8080\nStep 3: \"myserver.service\" file\n[Unido]\nDescription = Server example (replace ExecStart value with something more realistic)\n[Service]",
            "title": "Atenci\u00f3n: comprueba que date se encuentre dentro de / usr / bin; dependiendo de la distribuci\u00f3n eso cambia"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#we-listening-server-s-listening-puerto-only-to-loopback-interface-because-it-s-there-where-input-packages-comas-from-proxy",
            "text": "ExecStart = / usr / bin / ncat -k -l 127.0.0.1 8080",
            "title": "We listening server s listening puerto only to loopback interface because it 's there where input packages comas from proxy"
        }
    ]
}