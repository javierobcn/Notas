{
    "docs": [
        {
            "location": "/",
            "text": "Notas y Apuntes\n\uf0c1\n\n\n\n\n\n\nLPIC 1\n\uf0c1\n\n\n\n\n\n\nLPIC 2\n\uf0c1\n\n\n\n\n\n\nLPIC 3\n\uf0c1\n\n\n\n\n\n\nMarkdown\n\uf0c1",
            "title": "Home"
        },
        {
            "location": "/LPIC3/",
            "text": "Material curs LPIC 3-303\n\uf0c1\n\n\nEnlaces sobre los ex\u00e1menes:\n\uf0c1\n\n\n\n\nResumen de las certificaciones\n\n\nResumen de la certificaci\u00f3n LPIC-3 (303)\n\n\nLo que hace falta saber para superar el examen 303\n\n\n\n\nRecursos para descargar:\n\uf0c1\n\n\n\n\nM\u00e0quina servidora LDAP+Kerberos+NFS4 ja funcional\n\n\nM\u00e0quina client SSSD ja funcional\n\n\nArxiu ldif amb usuaris de mostra\n\n\n\n\nDocumentos del curso\n\uf0c1\n\n\n1.Previos\n\uf0c1\n\n\n\n\nComandos b\u00e1sicos de red en Linux\n\n\nTeoria b\u00e1sica sobre LDAP (i NSS)\n\n\nTeoria b\u00e1sica sobre NFS\n\n\nGesti\u00f3 b\u00e1sica de m\u00f2duls del kernel\n\n\nJournald i journalctl\n\n\nSystemd\n\n\nBreu descripci\u00f3 de /proc i de /sys\n\n\nComanda Jq (per l'eve.json de Suricata, Beats de l'ELK, etc)\n\n\nD-Bus (IPC per Firewalld, Systemd,...)\n\n\nServidor Apache (HTTP)\n\n\n\n\nAutenticaci\u00f3-Autoritzaci\u00f3:\n\uf0c1\n\n\n\n\nIntroducci\u00f3n\n\n\nAutenticaci\u00f3n vs Autorizaci\u00f3n\n\n\nHashes i endevinaci\u00f3 de contrasenyes. Keyloggers\n\n\n\n\nM\u00f3dulos PAM\n\uf0c1\n\n\n\n\nPAM i m\u00f2duls interessants (pam_limit, pam_pwquality, etc) (Pes 3)\n\n\nClient Kerberos+LDAP i FreeIPA (NSS+PAM+SSSD)\n\n\nInstal.laci\u00f3 servidor 389DS\n\n\nAdministraci\u00f3 b\u00e1sica d'un directori 389DS\n\n\nAutenticaci\u00f3 i identificaci\u00f3 contra servidor 389DS fent servir SSSD(Pes 5)\n\n\nInstal.laci\u00f3 i configuraci\u00f3 d'un servidor MIT Kerberos i cooperaci\u00f3 amb servidors LDAP i NFS(Pes 5)PENDENT NFS\n\n\nFreeIPA (client, servidor i r\u00e8plica)(Pes 4)PENDENT\n\n\n\n\nFrameworks d'autoritzaci\u00f3\n\uf0c1\n\n\n\n\nSu i sudo\n\n\nPolkit\n\n\n\n\nACLs, Capabilities y atributos extendidos\n\uf0c1\n\n\n\n\nBits suid,sgid,sticky\n\n\nCapabilities i atributs extesos(Pes 3)\n\n\nACLs(Pes 3)\n\n\n\n\nSELinux\n\uf0c1\n\n\n\n\nSELinux(Pes 4)\n\n\n\n\nRADIUS\nRADIUS(Pes 4)\n\n\nChroot i altres \"bitxos\": namespaces, cgroups, OS/App containers\nIntro contenidors(Pes 3)PENDENT\nExemple pr\u00e0ctic: contenidors mkosi/machinectl(Pes 3)\n\n\nMonitoritzaci\u00f3 local:\nCaptura de crides al sistema (i altres events)\nStrace, Ltrace i llibreries\nSysdig i Falco\nAudit(Pes 4)\nAltres FIMs\nELK (amb Falco i Audit)\n\n\nDetectors de rootkits i malware\nLynis, OpenSCAP, Rkhunter, Maldet, Aide (Pes 4)\nAnsible (com a m\u00e8tode per aplicar de forma autom\u00e0tica els canvis de configuraci\u00f3 suggerits pels programes anteriors)\nHoneypots (com a m\u00e8tode de captura i estudi de malware)\nMetasploit (eina per crear \"malware\" ad-hoc i introduir-lo a v\u00edctimes fent servir algun exploit)\nYara (eina per crear definicions pr\u00f2pies de detecci\u00f3 de malware) PENDENT\n\n\nHardering local:\nEncriptaci\u00f3 de disc amb LUKS i de sistemes de fitxers amb Ecryptfs (Pes 3)\nEncriptaci\u00f3 de fitxers amb GPG\nContrasenyes arranc al gestor Grub (Pes 3)\nSysctl (Pes 3)\nUdev \"i bad usbs\"\n\n\nMonitoritzaci\u00f3 de xarxa:\nInspecci\u00f3 en brut del tr\u00e0fic de xarxa i generaci\u00f3 d'alertes\nBreu descripci\u00f3 del protocol TCP\nWireshark(Pes 4)\nNIDS Snort/Suricata (Pes 4)\nConstructor de paquets Scapy\n\n\nRecol.lectors d'informaci\u00f3 estad\u00edstica sobre el tr\u00e0fic de xarxa\nEines TSBD\nNetflow i IPFIX\nMonitoritzaci\u00f3 d'ample de banda amb Cacti (Pes 4) PENDENT\n\n\nHardering de xarxa i servidors:\nTallafocs\nTallafocs Netfilter (NFTables) (Pes 5)\nTallafocs Firewalld\n\n\nVulnerabilitats\nIntroducci\u00f3 a les vulnerabilitats (web)\nDetector de vulnerabilitats OpenVAS (Pes 4)PENDENT\nDetector de vulnerabilitat Nmap (Pes 4)\nDetector de vulnerabilitats ZAP\n\n\nCriptografia pr\u00e0ctica amb OpenSSL\nConceptes de criptografia (Pes 5)\nXuleta comandes OpenSSL(Pes 5)PENDENT\n\n\nSecuritzaci\u00f3 d'un servidor Apache\nImplementaci\u00f3 servidor Apache segur (HTTPS)(Pes 4)\nDNSSEC\nNFS i CIFS segurs\nVPNs amb OpenVPN i IPSec\n\n\nLlibres:\nLlibre PacktPub",
            "title": "Home"
        },
        {
            "location": "/LPIC3/#material-curs-lpic-3-303",
            "text": "",
            "title": "Material curs LPIC 3-303"
        },
        {
            "location": "/LPIC3/#enlaces-sobre-los-examenes",
            "text": "Resumen de las certificaciones  Resumen de la certificaci\u00f3n LPIC-3 (303)  Lo que hace falta saber para superar el examen 303",
            "title": "Enlaces sobre los ex\u00e1menes:"
        },
        {
            "location": "/LPIC3/#recursos-para-descargar",
            "text": "M\u00e0quina servidora LDAP+Kerberos+NFS4 ja funcional  M\u00e0quina client SSSD ja funcional  Arxiu ldif amb usuaris de mostra",
            "title": "Recursos para descargar:"
        },
        {
            "location": "/LPIC3/#documentos-del-curso",
            "text": "1.Previos \uf0c1   Comandos b\u00e1sicos de red en Linux  Teoria b\u00e1sica sobre LDAP (i NSS)  Teoria b\u00e1sica sobre NFS  Gesti\u00f3 b\u00e1sica de m\u00f2duls del kernel  Journald i journalctl  Systemd  Breu descripci\u00f3 de /proc i de /sys  Comanda Jq (per l'eve.json de Suricata, Beats de l'ELK, etc)  D-Bus (IPC per Firewalld, Systemd,...)  Servidor Apache (HTTP)   Autenticaci\u00f3-Autoritzaci\u00f3: \uf0c1   Introducci\u00f3n  Autenticaci\u00f3n vs Autorizaci\u00f3n  Hashes i endevinaci\u00f3 de contrasenyes. Keyloggers   M\u00f3dulos PAM \uf0c1   PAM i m\u00f2duls interessants (pam_limit, pam_pwquality, etc) (Pes 3)  Client Kerberos+LDAP i FreeIPA (NSS+PAM+SSSD)  Instal.laci\u00f3 servidor 389DS  Administraci\u00f3 b\u00e1sica d'un directori 389DS  Autenticaci\u00f3 i identificaci\u00f3 contra servidor 389DS fent servir SSSD(Pes 5)  Instal.laci\u00f3 i configuraci\u00f3 d'un servidor MIT Kerberos i cooperaci\u00f3 amb servidors LDAP i NFS(Pes 5)PENDENT NFS  FreeIPA (client, servidor i r\u00e8plica)(Pes 4)PENDENT   Frameworks d'autoritzaci\u00f3 \uf0c1   Su i sudo  Polkit   ACLs, Capabilities y atributos extendidos \uf0c1   Bits suid,sgid,sticky  Capabilities i atributs extesos(Pes 3)  ACLs(Pes 3)   SELinux \uf0c1   SELinux(Pes 4)   RADIUS\nRADIUS(Pes 4)  Chroot i altres \"bitxos\": namespaces, cgroups, OS/App containers\nIntro contenidors(Pes 3)PENDENT\nExemple pr\u00e0ctic: contenidors mkosi/machinectl(Pes 3)  Monitoritzaci\u00f3 local:\nCaptura de crides al sistema (i altres events)\nStrace, Ltrace i llibreries\nSysdig i Falco\nAudit(Pes 4)\nAltres FIMs\nELK (amb Falco i Audit)  Detectors de rootkits i malware\nLynis, OpenSCAP, Rkhunter, Maldet, Aide (Pes 4)\nAnsible (com a m\u00e8tode per aplicar de forma autom\u00e0tica els canvis de configuraci\u00f3 suggerits pels programes anteriors)\nHoneypots (com a m\u00e8tode de captura i estudi de malware)\nMetasploit (eina per crear \"malware\" ad-hoc i introduir-lo a v\u00edctimes fent servir algun exploit)\nYara (eina per crear definicions pr\u00f2pies de detecci\u00f3 de malware) PENDENT  Hardering local:\nEncriptaci\u00f3 de disc amb LUKS i de sistemes de fitxers amb Ecryptfs (Pes 3)\nEncriptaci\u00f3 de fitxers amb GPG\nContrasenyes arranc al gestor Grub (Pes 3)\nSysctl (Pes 3)\nUdev \"i bad usbs\"  Monitoritzaci\u00f3 de xarxa:\nInspecci\u00f3 en brut del tr\u00e0fic de xarxa i generaci\u00f3 d'alertes\nBreu descripci\u00f3 del protocol TCP\nWireshark(Pes 4)\nNIDS Snort/Suricata (Pes 4)\nConstructor de paquets Scapy  Recol.lectors d'informaci\u00f3 estad\u00edstica sobre el tr\u00e0fic de xarxa\nEines TSBD\nNetflow i IPFIX\nMonitoritzaci\u00f3 d'ample de banda amb Cacti (Pes 4) PENDENT  Hardering de xarxa i servidors:\nTallafocs\nTallafocs Netfilter (NFTables) (Pes 5)\nTallafocs Firewalld  Vulnerabilitats\nIntroducci\u00f3 a les vulnerabilitats (web)\nDetector de vulnerabilitats OpenVAS (Pes 4)PENDENT\nDetector de vulnerabilitat Nmap (Pes 4)\nDetector de vulnerabilitats ZAP  Criptografia pr\u00e0ctica amb OpenSSL\nConceptes de criptografia (Pes 5)\nXuleta comandes OpenSSL(Pes 5)PENDENT  Securitzaci\u00f3 d'un servidor Apache\nImplementaci\u00f3 servidor Apache segur (HTTPS)(Pes 4)\nDNSSEC\nNFS i CIFS segurs\nVPNs amb OpenVPN i IPSec  Llibres:\nLlibre PacktPub",
            "title": "Documentos del curso"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/",
            "text": "Comandos b\u00e1sicos de red en Linux\n\uf0c1\n\n\nNomenclatura de tarjetas de red\n\uf0c1\n\n\nLas tarjetas de red en sistemas Linux se pueden llamar de las siguientes maneras:\n\n\n\n\nlo\n: Corresponde a la tarjeta \"loopback\". Recordemos que hemos dicho que esta tarjeta f\u00edsicamente no existe (es un \"invento\" del sistema operativo) y suele tener siempre tiene la IP 127.0.0.1/8. Sirve para establecer una conexi\u00f3n con s\u00ed misma, de tal forma que podemos tener en la misma m\u00e1quina un programa cliente que conecte a un programa servidor sin salir \"fuera\".\n\n\neno1, eno2\n: Tarjetas Ethernet integradas en la placa base ( \"on-board\")\n\n\nens1, ens2\n: Tarjetas Ethernet PCI ( \"slot\")\n\n\nenp2s0, p3p1\n: Tarjetas Ethernet que no se pueden localizar de otra forma debido a limitaciones de la BIOS\n\n\nwlp2s0\n:tarjetas WiFi\n\n\n\n\nDentro de las m\u00e1quinas virtuales de VirtualBox las tarjetas de red cogen siempre un nombre concreto: la tarjeta correspondiente a la primera pesta\u00f1a del cuadro de configuraci\u00f3n de red se llamar\u00e1 \"enp0s3\" dentro del sistema virtualizado, la segunda \"enp0s8\", la tercera \"enp0s9\" y la cuarta \"enp0s10\".\n\n\nVer la configuraci\u00f3n actual\n\uf0c1\n\n\nEstado y configuraci\u00f3n de las tarjetas detectadas\n\uf0c1\n\n\nEl comando \nip address show\n (o bien \nip address show dev nomTarjeta\n si s\u00f3lo se quiere obtener la informaci\u00f3n de una tarjeta determinada) nos muestra:\n\n\n\n\nLas direcciones MAC de las tarjetas\n\n\nSu estado respectivo (UP, DOWN)\n\n\nSus direcciones IP respectivas (y la m\u00e1scara correspondiente)\n\n\nOtros datos (como si permite el env\u00edo \"broadcast\", si est\u00e1 en modo \"promiscuo\", etc).\n\n\n\n\n\n\nNOTA\n\n\nEl comando \nip address show\n se puede escribir de forma m\u00e1s corta as\u00ed: \nip a s\n. Incluso, se puede dejar de escribir el verbo show (o s) porque es la acci\u00f3n por defecto (por lo tanto, se puede hacer \nip address\n o \nip a\n y ser\u00eda lo mismo). Tambi\u00e9n es \u00fatil el par\u00e1metro -c (as\u00ed: \nip -c a s\n) para ver los datos m\u00e1s relevantes en colores.\n\n\n\n\nPara activar / desactivar una tarjeta: ip link set {up|down} dev nomTarjeta\n\n\nPuerta de enlace\n\uf0c1\n\n\nEl comando \nip route show\n (o bien \nip route show dev nomTarjeta\n o sus variantes \nip route\n, \nip r s\n o \nip r\n) debe mostrar una l\u00ednea que comenzar\u00e1 con la expresi\u00f3n \n\"default v\u00eda\"\n seguida de la direcci\u00f3n IP de la puerta de enlace establecida. \nEste comando puede mostrar m\u00e1s l\u00edneas, pero no nos interesar\u00e1n mucho ... (quiz\u00e1s la m\u00e1s curiosa es una que sirve para indicar que no hay ninguna puerta de enlace para comunicarse con las m\u00e1quinas que pertenezcan a la misma red a la que pertenece nuestra m\u00e1quina).\n\n\nDNS\n\uf0c1\n\n\nPara saber la direcci\u00f3n IP del servidor DNS configurado en nuestra m\u00e1quina (o las IPs \u2026 si hay m\u00e1s de una se prueba conectar a la primera y si esta falla entonces se prueba la segunda, y as\u00ed) se puede consultar el archivo \netc/resolv.conf\n (concretamente, las l\u00edneas que comienzan por la palabra nameserver). Estos servidores ser\u00e1n los que todas las aplicaciones del sistema (desde el ping hasta el navegador) utilizar\u00e1n para averiguar cu\u00e1l es la IP del nombre que el usuario haya escrito.\n\n\nEl contenido de este archivo suele ser gestionado por diferentes programas (como puede ser el cliente \ndhclient\n, la aplicaci\u00f3n \nNetworkManager\n, el servicio \nnetworking\n, el servicio \nsystemd-networkd/resolved\n, etc) y es por ello que no se recomienda modificarlo manualmente ya que los cambios realizados a mano podr\u00edan \u00abMachacar\u00bb sin avisar en cualquier momento por cualquiera de estos programas.\n\n\nEn este sentido, estos programas (\ndhclient, NetworkManager, \u00abnetworking\u00bb, \u00absystemd-networkd / resolved, etc\n) guardan los servidores DNS que usan dentro de sus propios archivos de configuraci\u00f3n y los manipulan all\u00ed de forma aut\u00f3noma (por ejemplo NetworkManager usa /var/run/NetworkManager/resolv.conf, \u00absystemd-resolved\u00bb usa /run/systemd/resolve/resolv.conf, \u00abNetworking\u00bb usa la l\u00ednea dns-nameservers dentro de /etc/network/interfaces, etc) pero adem\u00e1s siempre vinculan en forma de enlace simb\u00f3lico su archivo propio respectivo al archivo com\u00fan /etc/resolv.conf para que los programas que utilicen este archivo com\u00fan no tengan problemas en encontrar los servidores DNS.\n\n\nEstablecer una configuraci\u00f3n de red est\u00e1tica de forma temporal\n\uf0c1\n\n\n\n\n\n\nPara asignar una IP / m\u00e1scara concreta a una tarjeta: \n\nip address add v.x.y.z/n dev nomTarjeta\n\n\n\n\n\n\nPara borrar una IP / m\u00e1scara concreta de una tarjeta: \nip address del v.x.y.z / n dev nomTarjeta\n\n\n\n\n\n\n\n\nNOTA\n\n\nTambi\u00e9n se puede hacer \nip address flush dev nomTarjeta\n si lo que se quiere es borrar de golpe cualesquiera de las eventuales diferentes direcciones IP que pueda tener la tarjeta indicada\n\n\n\n\nPara asignar la puerta de enlace concreta a una tarjeta: \nip route add default v\u00eda v.x.y.z dev nomTarjeta\n. Antes, sin embargo, deber\u00eda borrar la que hab\u00eda asignada antes (si no se hace da error), as\u00ed: \nip route del default dev nomTarjeta\n.\n\n\n\n\nNOTA\n\n\nTambi\u00e9n se puede escribir \nip route add 0.0.0.0/0 v\u00eda v.x.y.z dev nomTarjeta\n. Es equivalente.\n\n\n\n\n\n\nNOTA\n\n\nDe forma alternativa, en vez de hacer \nip route del \u2026\n y despu\u00e9s \nip route add \u2026\n, el cambio de puerta de enlace predeterminada se podr\u00eda hacer directamente en un solo paso, as\u00ed: \nip route change default v\u00eda v.x.y.z dev nomTarjeta\n\n\n\n\n\n\nNOTA\n\n\nTambi\u00e9n se puede indicar que se quiere utilizar una determinada puerta de enlace s\u00f3lo para llegar a una red-destino concreta. En este caso, entonces, no estar\u00edamos hablando de puerta de enlace \u00abpor defecto\u00bb sino de una puerta de enlace \u00abespec\u00edfica\u00bb. La puerta de enlace \u00abpor defecto\u00bb ser\u00eda usada una vez que el sistema hubiera comprobado que el destino deseado no forma parte del conjunto de destinos indicados en puertas de enlace espec\u00edficas. Para crear una puerta de enlace espec\u00edfica hay que ejecutar el comando \nip route add ip.red.Destino/Mascara v\u00eda v.x.y.z dev nomTarjeta\n Se puede a\u00f1adir adem\u00e1s un \u00faltimo par\u00e1metro metric n, que indica la preferencia de la ruta en el caso de que hubieran varias que llevaran al mismo destino (a modo de \u00abbackup\u00bb): un n menor indica una mayor preferencia.\n\n\n\n\n\n\nNOTA\n\n\nUna vez asignada una direcci\u00f3n IP a una tarjeta, el sistema calcula autom\u00e1ticamente su direcci\u00f3n IP de red correspondiente y genera una ruta a ella (es por eso que es necesario indicar la m\u00e1scara en ip address add \u2026)\nPor ejemplo, si se asigna la IP 203.0.113.25/24 a la tarjeta enp0s3, se crear\u00e1 autom\u00e1ticamente una ruta en la red 203.0.113.0/24 directa, por lo que el sistema sabr\u00e1 que para comunicarse con hosts de esta red no necesitar\u00e1 ninguna puerta de enlace intermediaria sino que lo podr\u00e1 hacer directamente.\n\n\n\n\nEstablecer una configuraci\u00f3n est\u00e1tica de forma permanente (en sistemas Debian cl\u00e1sicos)\n\uf0c1\n\n\nTodos los comandos anteriores, sin embargo, s\u00f3lo \u00abfuncionan\u00bb mientras la m\u00e1quina se mantiene encendida: si apaga entonces las direcciones IP / m\u00e1scaras y puertas de enlace configuradas con las \u00f3rdenes \u00abip\u00bb anteriores se pierden y hay, pues, que volver a ejecutarlas de nuevo en el siguiente inicio.\n\n\nPara que la configuraci\u00f3n deseada de IP / m\u00e1scara y puerta de enlace (y servidor DNS tambi\u00e9n, gestionado con alguno de los programas comentados en p\u00e1rrafos anteriores) para una determinada tarjeta de red se mantenga de forma permanente en cada reinicio de la m\u00e1quina, hay que escribir los valores adecuados en un determinado archivo. En sistemas Debian/Ubuntu, este archivo se denomina /etc/network/interfaces y debe tener un aspecto similar al siguiente (las l\u00edneas que comienzan por # son comentarios, las tabulaciones son opcionales):\n\n\n# Las l\u00edneas \"auto\" sirven para activar la tarjeta en cuesti\u00f3n (en este #caso la tarjeta \"lo\")\nauto lo\n# La l\u00ednea siguiente indica que la tarjeta \"lo\" es de \n# tipo \"loopback\" (y que, por tanto, tendr\u00e1 la IP 127.0.0.1)\niface lo inet loopback\n# En el mismo archivo se pueden configurar todas las tarjetas que \n# se quieran: la siguiente se llama enp3s0\nauto enp3s0\n# La palabra \"static\" indica que los valores de IP, m\u00e1scara, etc \n# son fijos en cada reinicio\niface enp3s0 inet static\n# A continuaci\u00f3n se indican los valores de IP, m\u00e1scara, puerta de \n# enlace y servidores DNS que se quieren asignar\naddress v.x.y.z\nnetmask w.w.w.w\ngateway v.x.y.z\ndns-nameservers v.x.y.z v.x.y.z\n\n\n\n\n\n\nAtenci\u00f3n\n\n\nAtenci\u00f3n, la l\u00ednea \u00ab\ndns-nameservers\n\u00bb del archivo anterior s\u00f3lo funciona (es decir, se copian los servidores DNS indicados all\u00ed en el archivo central del sistema donde deben estar para ser utilizados: /etc/resolv.conf) si hay instalado un paquete llamado \u00ab\nresolvconf\n\u00bb. Si no lo est\u00e1, estas l\u00edneas no se  tendr\u00e1n en cuenta.\n\n\n\n\nEste archivo es le\u00eddo por un servicio del sistema (un demonio) que se pone en marcha autom\u00e1ticamente al arrancar la m\u00e1quina y que se denomina \u00abnetworking\u00bb. Esto quiere decir que en cualquier momento que hagamos un cambio dentro de este archivo, para que se tenga en cuenta o bien habr\u00e1 que reiniciar la m\u00e1quina o bien simplemente reiniciar el servicio, as\u00ed: \nsudo systemctl restart networking\n\n\nEstablecer una configuraci\u00f3n est\u00e1tica de forma permanente (en sistemas systemd)\n\uf0c1\n\n\n\u00abSystemd-networkd\u00bb\n es un demonio que gestiona las configuraciones de las diferentes interfaces de red (f\u00edsicas y / o virtuales) de un sistema systemd, representando, pues, una alternativa al demonio \u00abNetworking\u00bb de sistemas Debian as\u00ed como tambi\u00e9n al scripts ifcfg- * cl\u00e1sicos de Fedora / Suse o al Network Manager integrado en muchos escritorios.\n\n\nPara empezar a utilizar este demonio es recomendable detener primero la \u00abcompetencia\u00bb, por ejemplo, en el caso de Ubuntu ejecutando\n\n\nsudo sytemctl disable networking && sudo systemctl stop networking)\n\n\nY entonces encenderlo junto con el servicio \u00absystemd-resolved\u00bb, as\u00ed, por ejemplo:\n\n\n\n\nNote\n\n\nAl igual que ocurr\u00eda con el paquete \u00abresolvconf\u00bb en los sistemas Debian, se necesita tener un servicio adicional instalado (y funcionando) en el sistema llamado \u00absystemd-resolved\u00bb si se quieren especificar entradas DNS expl\u00edcitas en los archivos .network (o bien si se obtienen v\u00eda DHCP). Este servicio lo que hace es, a partir de estas entradas, modificar el archivo /run/systemd/resolve/resolv.conf, el cual, por compatibilidad con muchos programas tradicionales, deber\u00eda apuntar en forma de enlace suave en /etc/resolv.conf (ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf). Alternativamente, se puede no utilizar systemd-resolved y modificar entonces el archivo /etc/resolv.conf a mano.\n\n\n\n\nSe pueden ver el nombre (y tipo y estado) de las interfaces de red actualmente reconocidas en el sistema (y su tipo y estado) mediante el comando \nnetworkctl list\n. Si en la columna SETUP aparece \u00abunmanaged\u00bb significa que esta interfaz concreta no es gestionada por systemd-networkd sino por alg\u00fan otro servicio alternativo. Otra orden que da m\u00e1s informaci\u00f3n es \nnetworkctl status\n. En cualquier caso, para hacer que se gestione por systemd-networkd, por cada interfaz hay que crear un archivo * .network dentro de la carpeta /etc/systemd/network (y reiniciar el servicio). En el caso concreto de querer asignar una IP est\u00e1tica, ser\u00eda necesario, pues, tener un archivo como este (llamado por ejemplo \u00ab/etc/systemd/network/lalala.network \u00ab):\n\n\n[Match]\nName=enp1s0\n#Identifica la tarjeta a la cual se le aplicar\u00e1 la configuraci\u00f3n\n[Network]\nDHCP=no\nAddress=10.1.10.9/24\nGateway=10.1.10.1\nDNS=10.1.10.2 #Opcional (Es necesario tener el servicio systemd-resolved funcionando)\nDNS=10.1.10.3 #Cada servidor DNS ha d'indicar-se en una l\u00ednia separada\n\n\n\n\nLos archivos de configuraci\u00f3n de systemd-networkd proporcionados por la distribuci\u00f3n se encuentran en \n/usr/lib/systemd/network\n y los administrados por nosotros se tienen que ubicar en \n/etc/systemd/network\n. Todos estos archivos se leen -sin distinci\u00f3n de donde est\u00e9n ubicados \u2013 en orden alfanum\u00e9rico seg\u00fan el nombre que tienen, ganando siempre la primera configuraci\u00f3n encontrada en caso de que afectara a la misma tarjeta. Eso s\u00ed, si en las dos carpetas se encuentra un fichero con el mismo nombre, lo que hay bajo \n/etc/systemd/network\n anula siempre a lo que hay en \n/usr/lib/systemd/network\n (una consecuencia de esto es que si el archivo en /etc/\u2026 apunta a /dev/null, lo que se estar\u00e1 haciendo es deshabilitar.\n\n\nExisten tres tipos diferentes de archivos de configuraci\u00f3n:\n\n\n\n\nlos \n\u00ab.network\u00bb\n aplican la configuraci\u00f3n descrita bajo su secci\u00f3n [Network] a aquellas tarjetas de red que tengan una caracter\u00edstica que concuerde con todos los valores indicados en las diferentes l\u00edneas bajo la secci\u00f3n [Match] (normalmente aqu\u00ed s\u00f3lo indica su nombre mediante una \u00fanica l\u00ednea \u00abName =\u00bb)\n\n\nlos \n\u00ab.netdev\u00bb\n sirven para crear nuevas interfaces de red de tipo virtual ( \u00abbridges\u00bb, \u00abbonds\u00bb, etc) -la configuraci\u00f3n de red se seguir\u00e1 indicando en su correspondiente archivo .network)\n\n\nlos \n\u00ab.link\u00bb\n sirven para definir nombres alternativos a las tarjetas de red en el momento de ser reconocidas por el sistema (v\u00eda systemd-udev).\n\n\n\n\nEn las l\u00edneas bajo la secci\u00f3n [Match] -por ejemplo, en \u00abName =\u00bb, se puede utilizar el comod\u00edn *. En esta l\u00ednea en concreto tambi\u00e9n se puede escribir un conjunto de nombres separados por un espacio en blanco a modo de diferentes alternativas.\n\n\nEn los archivos .network puede haber una secci\u00f3n (no vista en los ejemplos anteriores) titulada [Link] bajo la que pueden haber varias l\u00edneas m\u00e1s relacionadas con el comportamiento \u00abhardware\u00bb de la tarjeta, como la l\u00ednea \u00abMACAddress = xx: xx: xx: xx: xx: xx\u00bb, la cual sirve para asignar a la tarjeta en cuesti\u00f3n una direcci\u00f3n MAC ficticia, la l\u00ednea \u00abMTUBytes = no\u00bb, la cual sirve para indicar el tama\u00f1o de la MTU admitida (\u00fatil por ejemplo para activar los \u00abjumbo frames\u00bb si se pone 9000 como valor), o la l\u00ednea \u00abARP = no\u00bb para desactivar el protocolo ARP en la tarjeta en cuesti\u00f3n (activado por defecto).\n\n\nLos archivos .netdev suelen tener s\u00f3lo una secci\u00f3n titulada [netdev], la cual debe incluir dos l\u00edneas obligatoriamente: \u00abName =\u00bb (por asignar un nombre a la interfaz virtual que se crear\u00e1) y \u00abKind =\u00bb (para especificar el tipo de interfaz que ser\u00e1: \u00abbridge\u00bb, \u00abbond\u00bb, \u00abVlan\u00bb, \u00abveth\u00bb, etc). En el caso de que sea de tipo \u00abvlan\u00bb, aparecer\u00e1 entonces una secci\u00f3n titulada [VLAN] incluyendo como m\u00ednimo la l\u00ednea \u00abId =\u00bb para indicar el n\u00famero de VLAN que se est\u00e1 creando.\n\n\nLos archivos .link suelen tener una secci\u00f3n [Match] con la l\u00ednea \u00abMACAddress =\u00bb para identificar la tarjeta de red en cuesti\u00f3n y una secci\u00f3n\n[Link] que sirve para manipular las caracter\u00edsticas de esta tarjeta, como por ejemplo su nombre (con la l\u00ednea \u00abName =\u00bb y, opcionalmente, la l\u00ednea \u00abDescription =\u00bb). Si no se crea manualmente ning\u00fan archivo .link, la mayor\u00eda de distribuciones ofrecen un archivo .link predeterminado, generalmente llamado 99-default.link (y ubicado en / usr / lib / systemd / network); es por ello que hay que asegurarse que los ficheros .link \u00abmanuales\u00bb tengan un nombre que asegure su lectura antes de la del archivo 99-default.link.\n\n\nPara m\u00e1s informaci\u00f3n sobre las posibilidades que ofrecen todos estos archivos, consultar las p\u00e1ginas del manual \u00absystemd.network\u00bb, \u00abSystemd.netdev\u00bb y \u00absystemd.link\u00bb.\n\n\n\n\nAtenci\u00f3n\n\n\nNo s\u00f3lo existen el servicio \u00abnetworking\u00bb y \u00absystemd-networkd\u00bb para gestionar las tarjetas de red de nuestro sistema. Tambi\u00e9n podemos encontrar el servicio \u00abNetworkManager\u00bb (sobre todo en sistemas con escritorio) y en las \u00faltimas versiones de Ubuntu el servicio \u00abNetplan\u00bb, entre otros. !!!\n\n\n\n\nEstablecer una configuraci\u00f3n din\u00e1mica de forma temporal\n\uf0c1\n\n\nEn las configuraciones anteriores, tanto la temporal como la permanente, se establece una direcci\u00f3n IP / m\u00e1scara + puerta de enlace concreta, decidida por nosotros. Este m\u00e9todo puede ser \u00fatil para pocas m\u00e1quinas, pero en una red con muchos equipos, puede llegar a ser bastante farragoso, adem\u00e1s de que f\u00e1cilmente se pueden cometer errores (IPs duplicadas, IP no asignadas).\n\n\nOtro m\u00e9todo para establecer estos datos es el m\u00e9todo \u00abdin\u00e1mico\u00bb, en el que la m\u00e1quina en cuesti\u00f3n no tiene asignada de forma fija IP / m\u00e1scara + puerta de enlace + servidor DNS sino que estos datos los obtiene de la red: all\u00ed deber\u00e1 haber escuchando un ordenador ejecutando un software especial llamado \u00abServidor DHCP\u00bb, el cual sirve precisamente para atender estas peticiones de \u00abdatos de red\u00bb y asignarlas a quien las pida. De este modo, se tiene una gesti\u00f3n centralizada del reparto de direcciones IP / m\u00e1scara + puerta de enlace + servidores DNS sin necesidad de realizar ninguna configuraci\u00f3n espec\u00edfica en las m\u00e1quinas clientes. Eso s\u00ed, claro: primero se deber\u00e1 haber instalado y configurado convenientemente en nuestra red este software \u00abservidor DHCP\u00bb (un ejemplo es el paquete \u00abisc-dhcp-server \u00ab), tarea que no veremos (se presupone que esto ya est\u00e1 hecho).\n\n\n\n\nNota\n\n\nOtro cliente similar es el comando host nomDNS [ip.serv.DNS]\n\n\n\n\nPara pedir en un momento determinado una configuraci\u00f3n completa de red (IP, m\u00e1scara, puerta de enlace, servidores DNS, etc) a un servidor DHCP ya funcionando en nuestra LAN hemos de ejecutar un cliente DHCP, como el comando \ndhclient\n\n\nDhclient nomTarjeta\n Pide -para la tarjeta indicada- los datos de red (IP, m\u00e1scara, puerta de enlace, servidor DNS, etc) a alg\u00fan servidor DHCP que est\u00e9 escuchando a la LAN de nuestra m\u00e1quina.\n\n\n-v Muestra por pantalla todo el proceso de petici\u00f3n y respuesta (\u00fatil para ver si va)\n\n\n-r Borra todos los datos de red que pueda tener actualmente la tarjeta indicada\n\n\nEstablecer una configuraci\u00f3n din\u00e1mica de forma permanente\n\uf0c1\n\n\nEn sistemas Debian cl\u00e1sicos\n\uf0c1\n\n\nPara pedir los datos de red a alg\u00fan servidor DHCP de nuestra red, en vez\nde tener que hacerlo manualmente con el comando \ndhclient\n, se puede hacer de forma autom\u00e1tica cada vez que nuestra m\u00e1quina arranque (de modo que nosotros no tengamos que hacer nada y ya tengamos, si todo va bien, estos datos ya asignadas una vez iniciamos sesi\u00f3n). Esto se logra simplemente escribiendo las siguientes l\u00edneas en el archivo /etc/network/interfaces:\n\n\nauto enp3s0\niface enp3s0 inet dhcp\n\n\n\n\nEn sistemas systemd\n\uf0c1\n\n\nEn el caso concreto de querer asignar una IP din\u00e1mica en un sistema con el demonio systemd-netword funcionando, habr\u00e1 que tener un archivo como este (llamado por ejemplo \u00ab/Etc/systemd/network/lalala.network\u00bb):\n\n\n[Match]\nName = enp1s0\n[Network]\nDHCP = yes # Tambi\u00e9n podr\u00eda valer ipv4 o ipv6 seg\u00fan el tipo de direcciones IP que queremos recibir\n\n\n\n\nping\n\uf0c1\n\n\nping ip o Nombre Maq. Remota\n \n\n\nComprueba si la m\u00e1quina remota indicada responde. Sirve, por tanto, para saber si hay conexi\u00f3n de red con aquella m\u00e1quina (si no, podr\u00eda ser debido a cualquier causa: cable mal enchufado o roto, m\u00e1quina remota apagada, etc). En este sentido, son interesantes los datos estad\u00edsticos que aparecen al final (paquetes enviados, recibidos, perdidos, etc) y el tiempo que han tardado en enviarse estos paquetes de prueba (y recibirse la respuesta) -y as\u00ed comprobar la saturaci\u00f3n del medio.\n\n\n-n No resuelve nombres (es decir, no hace la consulta previa en el servidor DNS del sistema). Por lo tanto, s\u00f3lo hace que funcione indicando direcciones IP\n\n\n-c n\u00ba N\u00famero de paquetes de prueba que se enviar\u00e1n (si no se indica, son infinitos y hay que detener el env\u00edo pulsando CTRL + C)\n\n\n-i n\u00baN\u00famero de segundos que se espera para enviar el siguiente paquete\n\n\n-f Mode \u00abflood\u00bb. Env\u00eda paquetes a la m\u00e1xima velocidad posible, mostrando un punto por cada paquete enviado y borr\u00e1ndose el por cada respuesta recibida: por lo tanto, para ir bien habr\u00eda que s\u00f3lo se viera un punto y fuera desapareciendo: si se ven muchos puntos es que hay p\u00e9rdida de paquetes. Hay que ser root para que funcione\n\n\n-I eno1 Indica la tarjeta de red para la que se enviar\u00e1n los paquetes (por si la m\u00e1quina tuviera m\u00e1s de una)\n\n\nmtr\n\uf0c1\n\n\nmtr ip.o Nom.Maq.Remota\n\n\nSirve para conocer el camino seguido por un paquete desde la m\u00e1quina origen hasta la indicada, mostrando la IP (o nombre) de todos los routers\nintermedios a trav\u00e9s de los que va pasando. tambi\u00e9n muestra estad\u00edsticas de tiempo empleado en cada paquete, el mejor tiempo, el peor, los paquetes perdidos, etc\n\n\n-n No resuelve nombres (es decir, no hace la consulta previa en el servidor DNS del sistema).\n\n\n-c n\u00ba N\u00famero de paquetes de prueba que se enviar\u00e1n (si no se indica, son infinitos y hay que parar el env\u00edo pulsando CTRL + C)\n\n\n-i n\u00ba N\u00famero de segundos que se espera para enviar el siguiente paquete\n\n\nss\n\uf0c1\n\n\nMuestra datos sobre las conexiones existentes (o que pueden existir) en\nnuestra m\u00e1quina. Concretamente, muestra el estado de la conexi\u00f3n (los m\u00e1s habituales son ESTABLISHED y LISTEN -este \u00faltimo indica que el\npuerto est\u00e1 abierto pero sin conexi\u00f3n -\u2026 otros estados a menudo son\ntemporales y terminan derivando en una conexi\u00f3n establecida o bien\ndesapareciendo), muestra la IP y el puerto local utilizados para establecer la conexi\u00f3n (o para escuchar, segundos) y la IP y puerto remoto donde la\ncorrespondiente IP + puerto local est\u00e1n conectados.\n\n\nNOTA: Otro cliente similar es el comando \nhost nomDNS [ip.serv.DNS]\n\n\n-t Mostrar s\u00f3lo las conexiones TCP actuales\n\n\n-u Mostrar s\u00f3lo las conexiones UDP actuales\n\n\n-n No resuelve nombres (es decir: muestra IPs y puertos en formato num\u00e9rico en lugar de con nombres)\n\n\n-a (Combinado con -t y/o -u): Muestra, adem\u00e1s de las conexiones actuales, los puertos a la escucha\n\n\n-l (Combinado con -t y / o -u): Muestra s\u00f3lo los puertos a la escucha (las conexiones actuales no)\n\n\n-p (Combinado con -t y / o -u): Muestra 1 columna m\u00e1s: el ejecutable \u00abdetr\u00e1s\u00bb de cada puerto local\n\n\n\u2013s Muestra un resumen con estad\u00edsticas\n\n\nncat\n\uf0c1\n\n\nncat ip.oNom.Maq.Remota noport\n\n\nCliente Netcat que viene dentro del paquete \u00abnmap\u00bb: realiza una\nconexi\u00f3n (TCP) en la m\u00e1quina y puerto indicado. Se puede a\u00f1adir el\npar\u00e1metro -v (modo verboso) y -n (no resuelve nombres), entre otros.\n\n\n-v Modo verboso (-vv es m\u00e1s verboso y -vvv m\u00e1s a\u00fan)\n\n\nncat -l -k -p n\u00ba\n Servidor Netcat: pone a la escucha el n\u00ba de puerto (TCP) indicado. el argumento -l sirve para \u00ababrir\u00bb el puerto, el par\u00e1metro -p sirve para indicar el n\u00famero de puerto a abrir y el par\u00e1metro -k permite que se puedan conectar m\u00e1s de un cliente a la vez.\n\n\n-e /ruta/comando Todo lo que se reciba de la red ser\u00e1 pasado al comando indicado, la salida ser\u00e1 devuelta al cliente. Si el comando indicado fuera\n/Bin/bash, la entrada se entender\u00e1 como un comando a ejecutar (y la\nsalida ser\u00e1 la salida del comando ejecutado).\nExemples Ncat\n\n\nChat\n \n\n\nServidor: \nncat -l -p 5588\n <\u2014> Cliente: \nncat ipServidor 5588\n\n\nEl servidor se pone a escuchar en el puerto 5588 (por defecto siempre es TCP), con lo que todo lo que le llegue de la red -es decir, del cliente-lo pasar\u00e1 a la stdout (pantalla), y todo lo que escriba por stdin (teclado) pasar\u00e1 a la red -es decir, hacia el cliente-. Lo mismo ocurre en el otro lado de la comunicaci\u00f3n. Si se a\u00f1ade el par\u00e1metro -k al servidor, m\u00faltiples clientes podr\u00e1n enviar mensajes al servidor y este, lo que env\u00ede, lo enviar\u00e1 a todos sin discriminaci\u00f3n\n\n\nEnv\u00edo de un archivo\n\n\nServidor: \nncat -l -p 5555 < archivo\n <-> Cliente: \nncat ipServidor 5555 > archivo\n\n\nMuy similar a lo anterior: el servidor se pone a escuchar en el puerto 5555, pero en vez de responder por teclado a la stdin, la entrada proviene de un archivo, el cual esperar\u00e1 latente a que cuando se establezca una comunicaci\u00f3n por ese puerto, su contenido viaje bit a bit por la red hacia el cliente, el cual lo recibir\u00e1 y lo guardar\u00e1 en forma de archivo otra vez. Lo malo es que tal como se ha hecho, no se sabe cu\u00e1ndo se ha acabado la transferencia: hay que esperar un tiempo prudencial y entonces hacer Ctrl+C.\n\n\nReproducci\u00f3n de audio en streaming\n\n\nServidor: \nncat -l -p 5858\n Cliente: \nncat ipServidor 5858 | mpg123 \u2013\n\n\nEl ejemplo es id\u00e9ntico al anterior, teniendo un archivo en este caso de audio. La \u00fanica diferencia es que en el cliente, el archivo no se redirecciona para grabarlo en disco sino que se entuba a un reproductor de audio por consola, como mpg123 (el gui\u00f3n del final es para indicarle que el fichero o lista de reproducci\u00f3n le proviene de la tuber\u00eda).\n\n\nClonaci\u00f3n de discos por red\n\n\nServidor: \nncat -l -p 5678 | dd of=a.iso.gz\n <\u2014->Cliente: \ndd if=/dev/sda | gzip -c | ncat ipServidor 5678\n\n\nEl ejemplo es parecido al anterior: primero en el cliente se comprime bit a bit el contenido del disco \u00absda\u00bb y se le env\u00eda ya comprimido al servidor, el cual recibe este contenido binario y lo almacena en un archivo, bit a bit too.\n\n\nnmap\n\uf0c1\n\n\nnmap -sn { ipInici-ipFinal [altraIP \u2026] | ipConAsteriscos }\n\n\nMuestra qu\u00e9 ordenadores est\u00e1n presentes en la red. existen muchos otros par\u00e1metros de escaneo (-sU, -sX, -sF, etc) que utilizan diferentes t\u00e9cnicas m\u00e1s\no \u2013 r\u00e1pidas / sigilosas / precisas, pero no las veremos.\n\n\n-v Modo verboso (-vv es m\u00e1s verboso y -vvv m\u00e1s a\u00fan)\n\n\n-n No resuelve nombres\n\n\nnmap -p n\u00ba, n\u00ba-n\u00ba ipOrdenador\n Muestra qu\u00e9 puertos (del rango indicado) tiene abiertos un ordenador concreto. Aqu\u00ed tambi\u00e9n se pueden utilizar diferentes t\u00e9cnicas pero tampoco profundizaremos\n\n\n-O Muestra el sistema operativo del ordenador y los programas \u00abdetr\u00e1s\u00bb de los\npuertos abiertos. Se puede combinar con el par\u00e1metro -sV, el cual muestra tambi\u00e9n las versiones. El par\u00e1metro -A es la combinaci\u00f3n de los dos.\n\n\nnslookup\n\uf0c1\n\n\nnslookup nombreDNS [ip.serv.DNS]\n\n\nCliente DNS que pregunta al servidor indicado o, si no se indica ninguno, al que est\u00e9 configurado en \n/etc/resolv.conf\n. Normalmente, adem\u00e1s de devolver la IP (o IPs equivalentes) asociadas al nombre indicado, tambi\u00e9n muestra los \u00abalias\u00bb que tiene este nombre\n\n\n\n\nNOTA\n\n\nOtro cliente similar es el comando \nhost nomDNS [ip.serv.DNS]\n\n\n\n\n\n\nNOTA\n\n\nOtro cliente similar es el comando \ndig [@ip.serv.DNS] nomDNS.\n O \ndrill\n\n\n\n\n\n\nNOTA\n\n\nOtro cliente pero s\u00f3lo compatible con systemd-resolved es \nsystemd-resolve\n\n\n\n\nwhois\n\uf0c1\n\n\nwhois dominioDNS\n\n\nConsulta en los servidores whois publicos (administrados por la IANA) para averiguar el propietario o registrador del dominio\n\n\nwget\n\uf0c1\n\n\nwget https://url/un/archivo\n\n\nDescarga al disco duro el archivo indicado\n\n\n-c Contin\u00faa la descarga (si anteriormente fall\u00f3) desde donde se interrumpi\u00f3\n\n\n-O nombre Indica el nombre que tendr\u00e1 el archivo una vez descargado\n\n\n-r Realiza una descarga recursiva si la URL indicada es la de una carpeta en vez de la de un archivo. Combinado con el par\u00e1metro -l n\u00ba sirve para indicar hasta qu\u00e9 nivel (1 = una subcarpeta, 2 =dos subcarpetas) se quiere descargar \u2026 si no se indica se entiende \u00abinfinito\u00bb\n\n\n-N Descarga s\u00f3lo los archivos m\u00e1s nuevos que los locales\n\n\n-A \u00abext1\u00bb, \u00abext2\u00bb, \u2026 Descarga s\u00f3lo los archivos que encuentre con la extensi\u00f3n indicada El par\u00e1metro contrario (descarga todo excepto los archivos indicados) es -R\n\n\n\u2013no-parent No descarga contenido anterior a la URL indicada\n\n\n-nd Todo lo descarga en la misma carpeta local (sin respetar, pues, la jerarqu\u00eda de carpetas del sitio remoto)\n\n\n-k Una vez hecha la descarga, transforma los enlaces para que todo el contenido se pueda visitar offline (cambia las rutas absolutas para relativas y los recursos no descargados los referencia con la URL completa\n\n\ncurl\n\uf0c1\n\n\ncurl https://url/un/archivo\n\n\nDescargar el fichero indicado y muestra en pantalla su contenido\n\n\n-o nombre Descargar archivo indicado y lo guarda en el disco duro con el nombre que se especifique\n\n\n-O Descargar el fichero indicado y lo guarda en el disco duro con el nombre que tenga el original\n\n\n-C \u2013 Contin\u00faa la descarga desde el no de byte indicado (si es un gui\u00f3n, ser\u00e1 a partir de donde se par\u00f3 la descarga -fallida- anterior del mismo archivo\n\n\n-s Modo \u00absilencioso\u00bb (no muestra ni las estad\u00edsticas de descarga ni los errores, nada)\n\n\n-SS Modo \u00absilencioso\u00bb pero mostrando los mensajes de error\n\n\n-v Modo \u00abverboso\u00bb. Sirve para mostrar las cabeceras de cliente enviadas a la petici\u00f3n\n\n\n-Y No descarga el archivo: s\u00f3lo muestra la cabecera de respuesta HTTP del servidor\n\n\n-y Mostrar en pantalla tanto las cabeceras de respuesta como el contenido del archivo pedido\n\n\n-D nombre Guarda en el disco duro, en forma de archivo con el nombre indica, las cabeceras de respuesta\n\n\n-L Si el servidor web devuelve un c\u00f3digo de redirecci\u00f3n (3xx), lo sigue autom\u00e1ticamente\n\n\n-H \u00abcabecera: valor\u00bb Realiza una petici\u00f3n indicando un valor concreto para la cabecera HTTP de cliente indicada. Se pueden poner m\u00faltiples par\u00e1metros -H.\n\n\n\u2013X tipo Realiza una petici\u00f3n del tipo indicado (POST, PUT, etc). Por defecto son GET",
            "title": "Comandos b\u00e1sicos de red en Linux"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#comandos-basicos-de-red-en-linux",
            "text": "",
            "title": "Comandos b\u00e1sicos de red en Linux"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#nomenclatura-de-tarjetas-de-red",
            "text": "Las tarjetas de red en sistemas Linux se pueden llamar de las siguientes maneras:   lo : Corresponde a la tarjeta \"loopback\". Recordemos que hemos dicho que esta tarjeta f\u00edsicamente no existe (es un \"invento\" del sistema operativo) y suele tener siempre tiene la IP 127.0.0.1/8. Sirve para establecer una conexi\u00f3n con s\u00ed misma, de tal forma que podemos tener en la misma m\u00e1quina un programa cliente que conecte a un programa servidor sin salir \"fuera\".  eno1, eno2 : Tarjetas Ethernet integradas en la placa base ( \"on-board\")  ens1, ens2 : Tarjetas Ethernet PCI ( \"slot\")  enp2s0, p3p1 : Tarjetas Ethernet que no se pueden localizar de otra forma debido a limitaciones de la BIOS  wlp2s0 :tarjetas WiFi   Dentro de las m\u00e1quinas virtuales de VirtualBox las tarjetas de red cogen siempre un nombre concreto: la tarjeta correspondiente a la primera pesta\u00f1a del cuadro de configuraci\u00f3n de red se llamar\u00e1 \"enp0s3\" dentro del sistema virtualizado, la segunda \"enp0s8\", la tercera \"enp0s9\" y la cuarta \"enp0s10\".",
            "title": "Nomenclatura de tarjetas de red"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#ver-la-configuracion-actual",
            "text": "Estado y configuraci\u00f3n de las tarjetas detectadas \uf0c1  El comando  ip address show  (o bien  ip address show dev nomTarjeta  si s\u00f3lo se quiere obtener la informaci\u00f3n de una tarjeta determinada) nos muestra:   Las direcciones MAC de las tarjetas  Su estado respectivo (UP, DOWN)  Sus direcciones IP respectivas (y la m\u00e1scara correspondiente)  Otros datos (como si permite el env\u00edo \"broadcast\", si est\u00e1 en modo \"promiscuo\", etc).    NOTA  El comando  ip address show  se puede escribir de forma m\u00e1s corta as\u00ed:  ip a s . Incluso, se puede dejar de escribir el verbo show (o s) porque es la acci\u00f3n por defecto (por lo tanto, se puede hacer  ip address  o  ip a  y ser\u00eda lo mismo). Tambi\u00e9n es \u00fatil el par\u00e1metro -c (as\u00ed:  ip -c a s ) para ver los datos m\u00e1s relevantes en colores.   Para activar / desactivar una tarjeta: ip link set {up|down} dev nomTarjeta  Puerta de enlace \uf0c1  El comando  ip route show  (o bien  ip route show dev nomTarjeta  o sus variantes  ip route ,  ip r s  o  ip r ) debe mostrar una l\u00ednea que comenzar\u00e1 con la expresi\u00f3n  \"default v\u00eda\"  seguida de la direcci\u00f3n IP de la puerta de enlace establecida. \nEste comando puede mostrar m\u00e1s l\u00edneas, pero no nos interesar\u00e1n mucho ... (quiz\u00e1s la m\u00e1s curiosa es una que sirve para indicar que no hay ninguna puerta de enlace para comunicarse con las m\u00e1quinas que pertenezcan a la misma red a la que pertenece nuestra m\u00e1quina).  DNS \uf0c1  Para saber la direcci\u00f3n IP del servidor DNS configurado en nuestra m\u00e1quina (o las IPs \u2026 si hay m\u00e1s de una se prueba conectar a la primera y si esta falla entonces se prueba la segunda, y as\u00ed) se puede consultar el archivo  etc/resolv.conf  (concretamente, las l\u00edneas que comienzan por la palabra nameserver). Estos servidores ser\u00e1n los que todas las aplicaciones del sistema (desde el ping hasta el navegador) utilizar\u00e1n para averiguar cu\u00e1l es la IP del nombre que el usuario haya escrito.  El contenido de este archivo suele ser gestionado por diferentes programas (como puede ser el cliente  dhclient , la aplicaci\u00f3n  NetworkManager , el servicio  networking , el servicio  systemd-networkd/resolved , etc) y es por ello que no se recomienda modificarlo manualmente ya que los cambios realizados a mano podr\u00edan \u00abMachacar\u00bb sin avisar en cualquier momento por cualquiera de estos programas.  En este sentido, estos programas ( dhclient, NetworkManager, \u00abnetworking\u00bb, \u00absystemd-networkd / resolved, etc ) guardan los servidores DNS que usan dentro de sus propios archivos de configuraci\u00f3n y los manipulan all\u00ed de forma aut\u00f3noma (por ejemplo NetworkManager usa /var/run/NetworkManager/resolv.conf, \u00absystemd-resolved\u00bb usa /run/systemd/resolve/resolv.conf, \u00abNetworking\u00bb usa la l\u00ednea dns-nameservers dentro de /etc/network/interfaces, etc) pero adem\u00e1s siempre vinculan en forma de enlace simb\u00f3lico su archivo propio respectivo al archivo com\u00fan /etc/resolv.conf para que los programas que utilicen este archivo com\u00fan no tengan problemas en encontrar los servidores DNS.",
            "title": "Ver la configuraci\u00f3n actual"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-de-red-estatica-de-forma-temporal",
            "text": "Para asignar una IP / m\u00e1scara concreta a una tarjeta:  ip address add v.x.y.z/n dev nomTarjeta    Para borrar una IP / m\u00e1scara concreta de una tarjeta:  ip address del v.x.y.z / n dev nomTarjeta     NOTA  Tambi\u00e9n se puede hacer  ip address flush dev nomTarjeta  si lo que se quiere es borrar de golpe cualesquiera de las eventuales diferentes direcciones IP que pueda tener la tarjeta indicada   Para asignar la puerta de enlace concreta a una tarjeta:  ip route add default v\u00eda v.x.y.z dev nomTarjeta . Antes, sin embargo, deber\u00eda borrar la que hab\u00eda asignada antes (si no se hace da error), as\u00ed:  ip route del default dev nomTarjeta .   NOTA  Tambi\u00e9n se puede escribir  ip route add 0.0.0.0/0 v\u00eda v.x.y.z dev nomTarjeta . Es equivalente.    NOTA  De forma alternativa, en vez de hacer  ip route del \u2026  y despu\u00e9s  ip route add \u2026 , el cambio de puerta de enlace predeterminada se podr\u00eda hacer directamente en un solo paso, as\u00ed:  ip route change default v\u00eda v.x.y.z dev nomTarjeta    NOTA  Tambi\u00e9n se puede indicar que se quiere utilizar una determinada puerta de enlace s\u00f3lo para llegar a una red-destino concreta. En este caso, entonces, no estar\u00edamos hablando de puerta de enlace \u00abpor defecto\u00bb sino de una puerta de enlace \u00abespec\u00edfica\u00bb. La puerta de enlace \u00abpor defecto\u00bb ser\u00eda usada una vez que el sistema hubiera comprobado que el destino deseado no forma parte del conjunto de destinos indicados en puertas de enlace espec\u00edficas. Para crear una puerta de enlace espec\u00edfica hay que ejecutar el comando  ip route add ip.red.Destino/Mascara v\u00eda v.x.y.z dev nomTarjeta  Se puede a\u00f1adir adem\u00e1s un \u00faltimo par\u00e1metro metric n, que indica la preferencia de la ruta en el caso de que hubieran varias que llevaran al mismo destino (a modo de \u00abbackup\u00bb): un n menor indica una mayor preferencia.    NOTA  Una vez asignada una direcci\u00f3n IP a una tarjeta, el sistema calcula autom\u00e1ticamente su direcci\u00f3n IP de red correspondiente y genera una ruta a ella (es por eso que es necesario indicar la m\u00e1scara en ip address add \u2026)\nPor ejemplo, si se asigna la IP 203.0.113.25/24 a la tarjeta enp0s3, se crear\u00e1 autom\u00e1ticamente una ruta en la red 203.0.113.0/24 directa, por lo que el sistema sabr\u00e1 que para comunicarse con hosts de esta red no necesitar\u00e1 ninguna puerta de enlace intermediaria sino que lo podr\u00e1 hacer directamente.",
            "title": "Establecer una configuraci\u00f3n de red est\u00e1tica de forma temporal"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-estatica-de-forma-permanente-en-sistemas-debian-clasicos",
            "text": "Todos los comandos anteriores, sin embargo, s\u00f3lo \u00abfuncionan\u00bb mientras la m\u00e1quina se mantiene encendida: si apaga entonces las direcciones IP / m\u00e1scaras y puertas de enlace configuradas con las \u00f3rdenes \u00abip\u00bb anteriores se pierden y hay, pues, que volver a ejecutarlas de nuevo en el siguiente inicio.  Para que la configuraci\u00f3n deseada de IP / m\u00e1scara y puerta de enlace (y servidor DNS tambi\u00e9n, gestionado con alguno de los programas comentados en p\u00e1rrafos anteriores) para una determinada tarjeta de red se mantenga de forma permanente en cada reinicio de la m\u00e1quina, hay que escribir los valores adecuados en un determinado archivo. En sistemas Debian/Ubuntu, este archivo se denomina /etc/network/interfaces y debe tener un aspecto similar al siguiente (las l\u00edneas que comienzan por # son comentarios, las tabulaciones son opcionales):  # Las l\u00edneas \"auto\" sirven para activar la tarjeta en cuesti\u00f3n (en este #caso la tarjeta \"lo\")\nauto lo\n# La l\u00ednea siguiente indica que la tarjeta \"lo\" es de \n# tipo \"loopback\" (y que, por tanto, tendr\u00e1 la IP 127.0.0.1)\niface lo inet loopback\n# En el mismo archivo se pueden configurar todas las tarjetas que \n# se quieran: la siguiente se llama enp3s0\nauto enp3s0\n# La palabra \"static\" indica que los valores de IP, m\u00e1scara, etc \n# son fijos en cada reinicio\niface enp3s0 inet static\n# A continuaci\u00f3n se indican los valores de IP, m\u00e1scara, puerta de \n# enlace y servidores DNS que se quieren asignar\naddress v.x.y.z\nnetmask w.w.w.w\ngateway v.x.y.z\ndns-nameservers v.x.y.z v.x.y.z   Atenci\u00f3n  Atenci\u00f3n, la l\u00ednea \u00ab dns-nameservers \u00bb del archivo anterior s\u00f3lo funciona (es decir, se copian los servidores DNS indicados all\u00ed en el archivo central del sistema donde deben estar para ser utilizados: /etc/resolv.conf) si hay instalado un paquete llamado \u00ab resolvconf \u00bb. Si no lo est\u00e1, estas l\u00edneas no se  tendr\u00e1n en cuenta.   Este archivo es le\u00eddo por un servicio del sistema (un demonio) que se pone en marcha autom\u00e1ticamente al arrancar la m\u00e1quina y que se denomina \u00abnetworking\u00bb. Esto quiere decir que en cualquier momento que hagamos un cambio dentro de este archivo, para que se tenga en cuenta o bien habr\u00e1 que reiniciar la m\u00e1quina o bien simplemente reiniciar el servicio, as\u00ed:  sudo systemctl restart networking",
            "title": "Establecer una configuraci\u00f3n est\u00e1tica de forma permanente (en sistemas Debian cl\u00e1sicos)"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-estatica-de-forma-permanente-en-sistemas-systemd",
            "text": "\u00abSystemd-networkd\u00bb  es un demonio que gestiona las configuraciones de las diferentes interfaces de red (f\u00edsicas y / o virtuales) de un sistema systemd, representando, pues, una alternativa al demonio \u00abNetworking\u00bb de sistemas Debian as\u00ed como tambi\u00e9n al scripts ifcfg- * cl\u00e1sicos de Fedora / Suse o al Network Manager integrado en muchos escritorios.  Para empezar a utilizar este demonio es recomendable detener primero la \u00abcompetencia\u00bb, por ejemplo, en el caso de Ubuntu ejecutando  sudo sytemctl disable networking && sudo systemctl stop networking)  Y entonces encenderlo junto con el servicio \u00absystemd-resolved\u00bb, as\u00ed, por ejemplo:   Note  Al igual que ocurr\u00eda con el paquete \u00abresolvconf\u00bb en los sistemas Debian, se necesita tener un servicio adicional instalado (y funcionando) en el sistema llamado \u00absystemd-resolved\u00bb si se quieren especificar entradas DNS expl\u00edcitas en los archivos .network (o bien si se obtienen v\u00eda DHCP). Este servicio lo que hace es, a partir de estas entradas, modificar el archivo /run/systemd/resolve/resolv.conf, el cual, por compatibilidad con muchos programas tradicionales, deber\u00eda apuntar en forma de enlace suave en /etc/resolv.conf (ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf). Alternativamente, se puede no utilizar systemd-resolved y modificar entonces el archivo /etc/resolv.conf a mano.   Se pueden ver el nombre (y tipo y estado) de las interfaces de red actualmente reconocidas en el sistema (y su tipo y estado) mediante el comando  networkctl list . Si en la columna SETUP aparece \u00abunmanaged\u00bb significa que esta interfaz concreta no es gestionada por systemd-networkd sino por alg\u00fan otro servicio alternativo. Otra orden que da m\u00e1s informaci\u00f3n es  networkctl status . En cualquier caso, para hacer que se gestione por systemd-networkd, por cada interfaz hay que crear un archivo * .network dentro de la carpeta /etc/systemd/network (y reiniciar el servicio). En el caso concreto de querer asignar una IP est\u00e1tica, ser\u00eda necesario, pues, tener un archivo como este (llamado por ejemplo \u00ab/etc/systemd/network/lalala.network \u00ab):  [Match]\nName=enp1s0\n#Identifica la tarjeta a la cual se le aplicar\u00e1 la configuraci\u00f3n\n[Network]\nDHCP=no\nAddress=10.1.10.9/24\nGateway=10.1.10.1\nDNS=10.1.10.2 #Opcional (Es necesario tener el servicio systemd-resolved funcionando)\nDNS=10.1.10.3 #Cada servidor DNS ha d'indicar-se en una l\u00ednia separada  Los archivos de configuraci\u00f3n de systemd-networkd proporcionados por la distribuci\u00f3n se encuentran en  /usr/lib/systemd/network  y los administrados por nosotros se tienen que ubicar en  /etc/systemd/network . Todos estos archivos se leen -sin distinci\u00f3n de donde est\u00e9n ubicados \u2013 en orden alfanum\u00e9rico seg\u00fan el nombre que tienen, ganando siempre la primera configuraci\u00f3n encontrada en caso de que afectara a la misma tarjeta. Eso s\u00ed, si en las dos carpetas se encuentra un fichero con el mismo nombre, lo que hay bajo  /etc/systemd/network  anula siempre a lo que hay en  /usr/lib/systemd/network  (una consecuencia de esto es que si el archivo en /etc/\u2026 apunta a /dev/null, lo que se estar\u00e1 haciendo es deshabilitar.  Existen tres tipos diferentes de archivos de configuraci\u00f3n:   los  \u00ab.network\u00bb  aplican la configuraci\u00f3n descrita bajo su secci\u00f3n [Network] a aquellas tarjetas de red que tengan una caracter\u00edstica que concuerde con todos los valores indicados en las diferentes l\u00edneas bajo la secci\u00f3n [Match] (normalmente aqu\u00ed s\u00f3lo indica su nombre mediante una \u00fanica l\u00ednea \u00abName =\u00bb)  los  \u00ab.netdev\u00bb  sirven para crear nuevas interfaces de red de tipo virtual ( \u00abbridges\u00bb, \u00abbonds\u00bb, etc) -la configuraci\u00f3n de red se seguir\u00e1 indicando en su correspondiente archivo .network)  los  \u00ab.link\u00bb  sirven para definir nombres alternativos a las tarjetas de red en el momento de ser reconocidas por el sistema (v\u00eda systemd-udev).   En las l\u00edneas bajo la secci\u00f3n [Match] -por ejemplo, en \u00abName =\u00bb, se puede utilizar el comod\u00edn *. En esta l\u00ednea en concreto tambi\u00e9n se puede escribir un conjunto de nombres separados por un espacio en blanco a modo de diferentes alternativas.  En los archivos .network puede haber una secci\u00f3n (no vista en los ejemplos anteriores) titulada [Link] bajo la que pueden haber varias l\u00edneas m\u00e1s relacionadas con el comportamiento \u00abhardware\u00bb de la tarjeta, como la l\u00ednea \u00abMACAddress = xx: xx: xx: xx: xx: xx\u00bb, la cual sirve para asignar a la tarjeta en cuesti\u00f3n una direcci\u00f3n MAC ficticia, la l\u00ednea \u00abMTUBytes = no\u00bb, la cual sirve para indicar el tama\u00f1o de la MTU admitida (\u00fatil por ejemplo para activar los \u00abjumbo frames\u00bb si se pone 9000 como valor), o la l\u00ednea \u00abARP = no\u00bb para desactivar el protocolo ARP en la tarjeta en cuesti\u00f3n (activado por defecto).  Los archivos .netdev suelen tener s\u00f3lo una secci\u00f3n titulada [netdev], la cual debe incluir dos l\u00edneas obligatoriamente: \u00abName =\u00bb (por asignar un nombre a la interfaz virtual que se crear\u00e1) y \u00abKind =\u00bb (para especificar el tipo de interfaz que ser\u00e1: \u00abbridge\u00bb, \u00abbond\u00bb, \u00abVlan\u00bb, \u00abveth\u00bb, etc). En el caso de que sea de tipo \u00abvlan\u00bb, aparecer\u00e1 entonces una secci\u00f3n titulada [VLAN] incluyendo como m\u00ednimo la l\u00ednea \u00abId =\u00bb para indicar el n\u00famero de VLAN que se est\u00e1 creando.  Los archivos .link suelen tener una secci\u00f3n [Match] con la l\u00ednea \u00abMACAddress =\u00bb para identificar la tarjeta de red en cuesti\u00f3n y una secci\u00f3n\n[Link] que sirve para manipular las caracter\u00edsticas de esta tarjeta, como por ejemplo su nombre (con la l\u00ednea \u00abName =\u00bb y, opcionalmente, la l\u00ednea \u00abDescription =\u00bb). Si no se crea manualmente ning\u00fan archivo .link, la mayor\u00eda de distribuciones ofrecen un archivo .link predeterminado, generalmente llamado 99-default.link (y ubicado en / usr / lib / systemd / network); es por ello que hay que asegurarse que los ficheros .link \u00abmanuales\u00bb tengan un nombre que asegure su lectura antes de la del archivo 99-default.link.  Para m\u00e1s informaci\u00f3n sobre las posibilidades que ofrecen todos estos archivos, consultar las p\u00e1ginas del manual \u00absystemd.network\u00bb, \u00abSystemd.netdev\u00bb y \u00absystemd.link\u00bb.   Atenci\u00f3n  No s\u00f3lo existen el servicio \u00abnetworking\u00bb y \u00absystemd-networkd\u00bb para gestionar las tarjetas de red de nuestro sistema. Tambi\u00e9n podemos encontrar el servicio \u00abNetworkManager\u00bb (sobre todo en sistemas con escritorio) y en las \u00faltimas versiones de Ubuntu el servicio \u00abNetplan\u00bb, entre otros. !!!",
            "title": "Establecer una configuraci\u00f3n est\u00e1tica de forma permanente (en sistemas systemd)"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-dinamica-de-forma-temporal",
            "text": "En las configuraciones anteriores, tanto la temporal como la permanente, se establece una direcci\u00f3n IP / m\u00e1scara + puerta de enlace concreta, decidida por nosotros. Este m\u00e9todo puede ser \u00fatil para pocas m\u00e1quinas, pero en una red con muchos equipos, puede llegar a ser bastante farragoso, adem\u00e1s de que f\u00e1cilmente se pueden cometer errores (IPs duplicadas, IP no asignadas).  Otro m\u00e9todo para establecer estos datos es el m\u00e9todo \u00abdin\u00e1mico\u00bb, en el que la m\u00e1quina en cuesti\u00f3n no tiene asignada de forma fija IP / m\u00e1scara + puerta de enlace + servidor DNS sino que estos datos los obtiene de la red: all\u00ed deber\u00e1 haber escuchando un ordenador ejecutando un software especial llamado \u00abServidor DHCP\u00bb, el cual sirve precisamente para atender estas peticiones de \u00abdatos de red\u00bb y asignarlas a quien las pida. De este modo, se tiene una gesti\u00f3n centralizada del reparto de direcciones IP / m\u00e1scara + puerta de enlace + servidores DNS sin necesidad de realizar ninguna configuraci\u00f3n espec\u00edfica en las m\u00e1quinas clientes. Eso s\u00ed, claro: primero se deber\u00e1 haber instalado y configurado convenientemente en nuestra red este software \u00abservidor DHCP\u00bb (un ejemplo es el paquete \u00abisc-dhcp-server \u00ab), tarea que no veremos (se presupone que esto ya est\u00e1 hecho).   Nota  Otro cliente similar es el comando host nomDNS [ip.serv.DNS]   Para pedir en un momento determinado una configuraci\u00f3n completa de red (IP, m\u00e1scara, puerta de enlace, servidores DNS, etc) a un servidor DHCP ya funcionando en nuestra LAN hemos de ejecutar un cliente DHCP, como el comando  dhclient  Dhclient nomTarjeta  Pide -para la tarjeta indicada- los datos de red (IP, m\u00e1scara, puerta de enlace, servidor DNS, etc) a alg\u00fan servidor DHCP que est\u00e9 escuchando a la LAN de nuestra m\u00e1quina.  -v Muestra por pantalla todo el proceso de petici\u00f3n y respuesta (\u00fatil para ver si va)  -r Borra todos los datos de red que pueda tener actualmente la tarjeta indicada",
            "title": "Establecer una configuraci\u00f3n din\u00e1mica de forma temporal"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#establecer-una-configuracion-dinamica-de-forma-permanente",
            "text": "En sistemas Debian cl\u00e1sicos \uf0c1  Para pedir los datos de red a alg\u00fan servidor DHCP de nuestra red, en vez\nde tener que hacerlo manualmente con el comando  dhclient , se puede hacer de forma autom\u00e1tica cada vez que nuestra m\u00e1quina arranque (de modo que nosotros no tengamos que hacer nada y ya tengamos, si todo va bien, estos datos ya asignadas una vez iniciamos sesi\u00f3n). Esto se logra simplemente escribiendo las siguientes l\u00edneas en el archivo /etc/network/interfaces:  auto enp3s0\niface enp3s0 inet dhcp  En sistemas systemd \uf0c1  En el caso concreto de querer asignar una IP din\u00e1mica en un sistema con el demonio systemd-netword funcionando, habr\u00e1 que tener un archivo como este (llamado por ejemplo \u00ab/Etc/systemd/network/lalala.network\u00bb):  [Match]\nName = enp1s0\n[Network]\nDHCP = yes # Tambi\u00e9n podr\u00eda valer ipv4 o ipv6 seg\u00fan el tipo de direcciones IP que queremos recibir",
            "title": "Establecer una configuraci\u00f3n din\u00e1mica de forma permanente"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#ping",
            "text": "ping ip o Nombre Maq. Remota    Comprueba si la m\u00e1quina remota indicada responde. Sirve, por tanto, para saber si hay conexi\u00f3n de red con aquella m\u00e1quina (si no, podr\u00eda ser debido a cualquier causa: cable mal enchufado o roto, m\u00e1quina remota apagada, etc). En este sentido, son interesantes los datos estad\u00edsticos que aparecen al final (paquetes enviados, recibidos, perdidos, etc) y el tiempo que han tardado en enviarse estos paquetes de prueba (y recibirse la respuesta) -y as\u00ed comprobar la saturaci\u00f3n del medio.  -n No resuelve nombres (es decir, no hace la consulta previa en el servidor DNS del sistema). Por lo tanto, s\u00f3lo hace que funcione indicando direcciones IP  -c n\u00ba N\u00famero de paquetes de prueba que se enviar\u00e1n (si no se indica, son infinitos y hay que detener el env\u00edo pulsando CTRL + C)  -i n\u00baN\u00famero de segundos que se espera para enviar el siguiente paquete  -f Mode \u00abflood\u00bb. Env\u00eda paquetes a la m\u00e1xima velocidad posible, mostrando un punto por cada paquete enviado y borr\u00e1ndose el por cada respuesta recibida: por lo tanto, para ir bien habr\u00eda que s\u00f3lo se viera un punto y fuera desapareciendo: si se ven muchos puntos es que hay p\u00e9rdida de paquetes. Hay que ser root para que funcione  -I eno1 Indica la tarjeta de red para la que se enviar\u00e1n los paquetes (por si la m\u00e1quina tuviera m\u00e1s de una)",
            "title": "ping"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#mtr",
            "text": "mtr ip.o Nom.Maq.Remota  Sirve para conocer el camino seguido por un paquete desde la m\u00e1quina origen hasta la indicada, mostrando la IP (o nombre) de todos los routers\nintermedios a trav\u00e9s de los que va pasando. tambi\u00e9n muestra estad\u00edsticas de tiempo empleado en cada paquete, el mejor tiempo, el peor, los paquetes perdidos, etc  -n No resuelve nombres (es decir, no hace la consulta previa en el servidor DNS del sistema).  -c n\u00ba N\u00famero de paquetes de prueba que se enviar\u00e1n (si no se indica, son infinitos y hay que parar el env\u00edo pulsando CTRL + C)  -i n\u00ba N\u00famero de segundos que se espera para enviar el siguiente paquete",
            "title": "mtr"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#ss",
            "text": "Muestra datos sobre las conexiones existentes (o que pueden existir) en\nnuestra m\u00e1quina. Concretamente, muestra el estado de la conexi\u00f3n (los m\u00e1s habituales son ESTABLISHED y LISTEN -este \u00faltimo indica que el\npuerto est\u00e1 abierto pero sin conexi\u00f3n -\u2026 otros estados a menudo son\ntemporales y terminan derivando en una conexi\u00f3n establecida o bien\ndesapareciendo), muestra la IP y el puerto local utilizados para establecer la conexi\u00f3n (o para escuchar, segundos) y la IP y puerto remoto donde la\ncorrespondiente IP + puerto local est\u00e1n conectados.  NOTA: Otro cliente similar es el comando  host nomDNS [ip.serv.DNS]  -t Mostrar s\u00f3lo las conexiones TCP actuales  -u Mostrar s\u00f3lo las conexiones UDP actuales  -n No resuelve nombres (es decir: muestra IPs y puertos en formato num\u00e9rico en lugar de con nombres)  -a (Combinado con -t y/o -u): Muestra, adem\u00e1s de las conexiones actuales, los puertos a la escucha  -l (Combinado con -t y / o -u): Muestra s\u00f3lo los puertos a la escucha (las conexiones actuales no)  -p (Combinado con -t y / o -u): Muestra 1 columna m\u00e1s: el ejecutable \u00abdetr\u00e1s\u00bb de cada puerto local  \u2013s Muestra un resumen con estad\u00edsticas",
            "title": "ss"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#ncat",
            "text": "ncat ip.oNom.Maq.Remota noport  Cliente Netcat que viene dentro del paquete \u00abnmap\u00bb: realiza una\nconexi\u00f3n (TCP) en la m\u00e1quina y puerto indicado. Se puede a\u00f1adir el\npar\u00e1metro -v (modo verboso) y -n (no resuelve nombres), entre otros.  -v Modo verboso (-vv es m\u00e1s verboso y -vvv m\u00e1s a\u00fan)  ncat -l -k -p n\u00ba  Servidor Netcat: pone a la escucha el n\u00ba de puerto (TCP) indicado. el argumento -l sirve para \u00ababrir\u00bb el puerto, el par\u00e1metro -p sirve para indicar el n\u00famero de puerto a abrir y el par\u00e1metro -k permite que se puedan conectar m\u00e1s de un cliente a la vez.  -e /ruta/comando Todo lo que se reciba de la red ser\u00e1 pasado al comando indicado, la salida ser\u00e1 devuelta al cliente. Si el comando indicado fuera\n/Bin/bash, la entrada se entender\u00e1 como un comando a ejecutar (y la\nsalida ser\u00e1 la salida del comando ejecutado).\nExemples Ncat  Chat    Servidor:  ncat -l -p 5588  <\u2014> Cliente:  ncat ipServidor 5588  El servidor se pone a escuchar en el puerto 5588 (por defecto siempre es TCP), con lo que todo lo que le llegue de la red -es decir, del cliente-lo pasar\u00e1 a la stdout (pantalla), y todo lo que escriba por stdin (teclado) pasar\u00e1 a la red -es decir, hacia el cliente-. Lo mismo ocurre en el otro lado de la comunicaci\u00f3n. Si se a\u00f1ade el par\u00e1metro -k al servidor, m\u00faltiples clientes podr\u00e1n enviar mensajes al servidor y este, lo que env\u00ede, lo enviar\u00e1 a todos sin discriminaci\u00f3n  Env\u00edo de un archivo  Servidor:  ncat -l -p 5555 < archivo  <-> Cliente:  ncat ipServidor 5555 > archivo  Muy similar a lo anterior: el servidor se pone a escuchar en el puerto 5555, pero en vez de responder por teclado a la stdin, la entrada proviene de un archivo, el cual esperar\u00e1 latente a que cuando se establezca una comunicaci\u00f3n por ese puerto, su contenido viaje bit a bit por la red hacia el cliente, el cual lo recibir\u00e1 y lo guardar\u00e1 en forma de archivo otra vez. Lo malo es que tal como se ha hecho, no se sabe cu\u00e1ndo se ha acabado la transferencia: hay que esperar un tiempo prudencial y entonces hacer Ctrl+C.  Reproducci\u00f3n de audio en streaming  Servidor:  ncat -l -p 5858  Cliente:  ncat ipServidor 5858 | mpg123 \u2013  El ejemplo es id\u00e9ntico al anterior, teniendo un archivo en este caso de audio. La \u00fanica diferencia es que en el cliente, el archivo no se redirecciona para grabarlo en disco sino que se entuba a un reproductor de audio por consola, como mpg123 (el gui\u00f3n del final es para indicarle que el fichero o lista de reproducci\u00f3n le proviene de la tuber\u00eda).  Clonaci\u00f3n de discos por red  Servidor:  ncat -l -p 5678 | dd of=a.iso.gz  <\u2014->Cliente:  dd if=/dev/sda | gzip -c | ncat ipServidor 5678  El ejemplo es parecido al anterior: primero en el cliente se comprime bit a bit el contenido del disco \u00absda\u00bb y se le env\u00eda ya comprimido al servidor, el cual recibe este contenido binario y lo almacena en un archivo, bit a bit too.",
            "title": "ncat"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#nmap",
            "text": "nmap -sn { ipInici-ipFinal [altraIP \u2026] | ipConAsteriscos }  Muestra qu\u00e9 ordenadores est\u00e1n presentes en la red. existen muchos otros par\u00e1metros de escaneo (-sU, -sX, -sF, etc) que utilizan diferentes t\u00e9cnicas m\u00e1s\no \u2013 r\u00e1pidas / sigilosas / precisas, pero no las veremos.  -v Modo verboso (-vv es m\u00e1s verboso y -vvv m\u00e1s a\u00fan)  -n No resuelve nombres  nmap -p n\u00ba, n\u00ba-n\u00ba ipOrdenador  Muestra qu\u00e9 puertos (del rango indicado) tiene abiertos un ordenador concreto. Aqu\u00ed tambi\u00e9n se pueden utilizar diferentes t\u00e9cnicas pero tampoco profundizaremos  -O Muestra el sistema operativo del ordenador y los programas \u00abdetr\u00e1s\u00bb de los\npuertos abiertos. Se puede combinar con el par\u00e1metro -sV, el cual muestra tambi\u00e9n las versiones. El par\u00e1metro -A es la combinaci\u00f3n de los dos.",
            "title": "nmap"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#nslookup",
            "text": "nslookup nombreDNS [ip.serv.DNS]  Cliente DNS que pregunta al servidor indicado o, si no se indica ninguno, al que est\u00e9 configurado en  /etc/resolv.conf . Normalmente, adem\u00e1s de devolver la IP (o IPs equivalentes) asociadas al nombre indicado, tambi\u00e9n muestra los \u00abalias\u00bb que tiene este nombre   NOTA  Otro cliente similar es el comando  host nomDNS [ip.serv.DNS]    NOTA  Otro cliente similar es el comando  dig [@ip.serv.DNS] nomDNS.  O  drill    NOTA  Otro cliente pero s\u00f3lo compatible con systemd-resolved es  systemd-resolve",
            "title": "nslookup"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#whois",
            "text": "whois dominioDNS  Consulta en los servidores whois publicos (administrados por la IANA) para averiguar el propietario o registrador del dominio",
            "title": "whois"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#wget",
            "text": "wget https://url/un/archivo  Descarga al disco duro el archivo indicado  -c Contin\u00faa la descarga (si anteriormente fall\u00f3) desde donde se interrumpi\u00f3  -O nombre Indica el nombre que tendr\u00e1 el archivo una vez descargado  -r Realiza una descarga recursiva si la URL indicada es la de una carpeta en vez de la de un archivo. Combinado con el par\u00e1metro -l n\u00ba sirve para indicar hasta qu\u00e9 nivel (1 = una subcarpeta, 2 =dos subcarpetas) se quiere descargar \u2026 si no se indica se entiende \u00abinfinito\u00bb  -N Descarga s\u00f3lo los archivos m\u00e1s nuevos que los locales  -A \u00abext1\u00bb, \u00abext2\u00bb, \u2026 Descarga s\u00f3lo los archivos que encuentre con la extensi\u00f3n indicada El par\u00e1metro contrario (descarga todo excepto los archivos indicados) es -R  \u2013no-parent No descarga contenido anterior a la URL indicada  -nd Todo lo descarga en la misma carpeta local (sin respetar, pues, la jerarqu\u00eda de carpetas del sitio remoto)  -k Una vez hecha la descarga, transforma los enlaces para que todo el contenido se pueda visitar offline (cambia las rutas absolutas para relativas y los recursos no descargados los referencia con la URL completa",
            "title": "wget"
        },
        {
            "location": "/LPIC3/1-Previos/Comandos b\u00e1sicos de red en Linux/#curl",
            "text": "curl https://url/un/archivo  Descargar el fichero indicado y muestra en pantalla su contenido  -o nombre Descargar archivo indicado y lo guarda en el disco duro con el nombre que se especifique  -O Descargar el fichero indicado y lo guarda en el disco duro con el nombre que tenga el original  -C \u2013 Contin\u00faa la descarga desde el no de byte indicado (si es un gui\u00f3n, ser\u00e1 a partir de donde se par\u00f3 la descarga -fallida- anterior del mismo archivo  -s Modo \u00absilencioso\u00bb (no muestra ni las estad\u00edsticas de descarga ni los errores, nada)  -SS Modo \u00absilencioso\u00bb pero mostrando los mensajes de error  -v Modo \u00abverboso\u00bb. Sirve para mostrar las cabeceras de cliente enviadas a la petici\u00f3n  -Y No descarga el archivo: s\u00f3lo muestra la cabecera de respuesta HTTP del servidor  -y Mostrar en pantalla tanto las cabeceras de respuesta como el contenido del archivo pedido  -D nombre Guarda en el disco duro, en forma de archivo con el nombre indica, las cabeceras de respuesta  -L Si el servidor web devuelve un c\u00f3digo de redirecci\u00f3n (3xx), lo sigue autom\u00e1ticamente  -H \u00abcabecera: valor\u00bb Realiza una petici\u00f3n indicando un valor concreto para la cabecera HTTP de cliente indicada. Se pueden poner m\u00faltiples par\u00e1metros -H.  \u2013X tipo Realiza una petici\u00f3n del tipo indicado (POST, PUT, etc). Por defecto son GET",
            "title": "curl"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/",
            "text": "Systemd (I)\n\uf0c1\n\n\nIntroducci\u00f3n\n\uf0c1\n\n\nSystemd es varias cosas:\n\n\n\n\nEl proceso Init (PID 1) del sistema\n\n\nEl gestor de demonios\n\n\nUn intermediario entre aplicaciones de usuario y ciertas partes de la API del kernel de Linux\n\n\n\n\nLa configuraci\u00f3n general de systemd se encuentra en el archivo \n/etc/systemd/system.conf\n; muchos valores por defecto est\u00e1n all\u00ed establecidos.\n\n\nPara saber la versi\u00f3n actual de systemd que hay funcionando el sistema, hacer \nsystemctl --version\n\n\n\"Units\": tipos y ubicaci\u00f3n\n\uf0c1\n\n\nTodo lo que es gestionado por systemd se llama \"unit\" y cada \"unit\" es descrita por un archivo de configuraci\u00f3n propio, el cual tendr\u00e1 una extensi\u00f3n diferente seg\u00fan el tipo de de unidad que se trate:\n\n\n\n\n.service\n: Describe la configuraci\u00f3n de un demonio\n\n\n.socket\n: Describe la configuraci\u00f3n de un socket (de tipo UNIX o TCP / IP) asociado a un .service\n\n\n.device\n: Describe un dispositivo hardware reconocido por el kernel (v\u00eda udev o sysfs) gestionado por systemd\n\n\n.mount\n: Describe un punto de montaje gestionado por systemd\n\n\n.automount\n: Describe un punto de automontaje asociado a un .mount\n\n\n.swap\n: Describe una partici\u00f3n o archivo de intercambio gestionado por systemd\n\n\n.target\n: Define un grupo de Units (se utiliza a modo de \"metapaquete\" de Units)\n\n\n.path\n: Describe una carpeta o archivo monitorizado por la API Inotify del kernel\n\n\n.timer\n: Describe la temporizaci\u00f3n / activaci\u00f3n de una tarea programada (usando el programador systemd)\n\n\n.slice\n: Define un grupo de Units asociadas a procesos para administrar y limitar los recursos comunes (CPU, memoria, discos, red). Usa internamente los llamados \"cgroups\" del kernel\n\n\n\n\nLos archivos de configuraci\u00f3n de las Units (sean del tipo que sean) pueden estar repartidos en tres carpetas distintas:\n\n\n\n\n/usr/lib/systemd/system\n: Para Units proporcionadas por los paquetes instalados en el sistema\n\n\n/run/systemd/system\n: Para Units generadas en tiempo real durante la ejecuci\u00f3n del sistema. no persistentes\n\n\n/etc/systemd/system\n: Para Units proporcionadas por el administrador del sistema\n\n\n\n\nLos archivos en \n/etc/...\n \nsobreescriben\n los archivos \nhom\u00f3nimos\n que est\u00e9n en \n/run/...\n los cuales sobreescriben los que est\u00e9n en \n/usr/lib/...\n (o en algunas distribuciones, \n/lib/...\n). Si no tienen el mismo nombre, todos los archivos de las tres carpetas se mezclan ordenados por su nombre de forma numericoalfab\u00e8tica y se van leyendo en este orden hasta el final.\n\n\nPor otra parte, si dentro de \n/usr/lib/...\n, \n/run/...\n o \n/etc/...\n hay una carpeta llamada como una unit seguido del sufijo \".d\", cualquier archivo con extensi\u00f3n * .conf que haya en su interior ser\u00e1 le\u00eddo justo despu\u00e9s de los ficheros de configuraci\u00f3n de la unit pertinente. Esto sirve para poder a\u00f1adir (o sobreescribir) opciones de configuraci\u00f3n concretas (las presentes en estos archivos) sin tener que tocar las configuraciones \"gen\u00e9ricas\" de la unit. por\nejemplo: el archivo \n/usr/lib/systemd/system/beep.service.d/foo.conf\n puede ser \u00fatil para modificar la configuraci\u00f3n definida en \n/usr/lib/systemd/systemd/beep.service\n (y de este modo, hacer posible que un paquete pueda cambiar la configuraci\u00f3n establecida por otro) y el archivo \n/etc/systemd/system/beep.service.d/foo.conf\n puede ser \u00fatil para modificar la configuraci\u00f3n definida en \n/usr/lib/systemd/system/beep.service\n (y de este modo, hacer\nposible que un administrador pueda cambiar ciertas partes de la configuraci\u00f3n de la unit preempaquetada al sistema sin tener que reemplazar completamente). Estos archivos \"override\" (concretamente con el nombre \n/etc/systemd/system/nomUnit.d/override.conf\n) se pueden generar de una manera muy c\u00f3moda y r\u00e1pida con la orden \nsystemctl edit nomUnit\n\n\nAlgunas \"units\" contienen un s\u00edmbolo @ en su nombre (por ejemplo, nom@cadena.service); esto significa que son instancias de una unit-plantilla, el archivo de configuraci\u00f3n de la cual es el que no contiene la parte\n\"Cadena\" en su nombre (as\u00ed: nombre @.service). La parte \"cadena\" es el identificador de la instancia (de hecho, dentro del archivo de configuraci\u00f3n de la unit-plantilla el valor \"cadena\" sustituye todas las ocurrencias del especificador especial %i).\n\n\nComandos para gestionar Units (principalmente de tipo \"service\")\n\uf0c1\n\n\nA continuaci\u00f3n mostramos algunos de los comandos m\u00e1s importantes para gestionar Units principalmente (No exclusivamente) de tipo \"service\":\n\n\nsystemctl [list-Units] [-t {service | socket | ...}] [--all | --failed | --state = inactive]\n\n\n\n\n\n\nMuestra el estado de las Units que est\u00e1n \"activas\" (del tipo indicado, si no se indica, aparecen todas).\n\n\n\n\n\n\nSi se escribe --state = inactive se muestra el estado de las Units que est\u00e1n \"inactivas\"\n\n\n\n\nComo valor del par\u00e1metro \n--state\n tambi\u00e9n se puede poner cualquier valor v\u00e1lido de la columna SUB\n\n\nSi se escribe \n--failed\n se muestra el estado de todas las Units con errores\n\n\n\n\nSi se escribe --all se muestra el estado de todas las Units ( \"activas\", \"inactivas\", con errores y otros)\n-La diferencia entre las columnas LOAD, ACTIVE y SUB la dice la salida de la propia pedido:\n\n\n\n\n\n\nLOAD\n = Indica si la unido ha sido cargada en RAM. Posibles valores: \"loaded\", \"error\", \"Masked\"\n\n\n\n\n\n\nACTIVE\n = Estado gen\u00e9rico de la unit. Posibles valores: \"active\", \"inactive\", \"failed\", \"(des) activating\"\n\n\n\n\n\n\nSUB\n = Estado m\u00e1s concreto de la unit, depende del tipo de unit, posibles valores \"plugged\", \"mounted\", \"running\", \"exited\", \"waiting\", \"listening\", etc\n\n\n\n\n\n\n\n\n\n\nsystemctl [-t {service | socket | ...}] list-unit-files\n\n\nEl comando \nlist-units\n s\u00f3lo muestra las units que systemd ha intentado leer y cargar en memoria. Ya que systemd s\u00f3lo lee las units que \u00e9l piensa que necesita, as\u00ed no incluye necesariamente todas las units disponibles en el  sistema. Para ver todas las units, incluyendo aquellas que systemd no ha intentando ni siquiera cargar, hay que utilizar list-unit-files. Este subcomando muestra el \"estado de carga\" de cada unit;posibles valores son:\n\n\n\n\n\n\n\"enabled\" o \"enabled-runtime\" : La unit se activar\u00e1 en el siguiente reinicio -y subsiguientes-.\n\n\n\n\nNOTA\n\n\nEsto se consigue gracias a la existencia de un enlace al archivo de configuraci\u00f3n de la unit en cuesti\u00f3n dentro de la carpeta \n/etc/systemd/system/nomTarget.target.wants\n, creado en alg\u00fan momento previo con el comando systemctl enable (ver m\u00e1s abajo) o de forma manual con ln -s\n\n\n\n\n\n\n\n\n\"static \": La unit no tiene secci\u00f3n \"[Install]\" en su archivo de configuraci\u00f3n. Esto hace que los comandos systemctl enable (y sobre todo systemctl disable ) no funcionen. Por tanto, el hecho de que la unit est\u00e9\nactivada o no en un determinado \"target\" depender\u00e1 de la existencia \"est\u00e1tica\" de su enlace correspondiente dentro de la carpeta \n/etc/systemd/system/nomTarget.target.wants\n. Este tipo de units suelen estar asociadas a las que realizan una acci\u00f3n \"oneshot\" o bien a las que son usadas s\u00f3lo como\ndependencia de alguna otra unit (y por tanto no deben ejecutarse por s\u00ed mismas)\n\n\n\n\n\n\n\"generated\": La unit se activar\u00e1 mediante un mecanismo autom\u00e1tico especial llamado \"generator\", ejecutado al arrancar el sistema. Cada unit en este estado tiene su propio \"generator\".\n\n\n\n\n\n\n\"transient\" : La unit es temporal y no sobrevivir\u00e1 al siguiente reinicio\n\n\n\n\n\n\n\"disabled \": La unit est\u00e1 desactivada y, por tanto, no se pondr\u00e1 en marcha en los siguientes reinicios (gracias a la inexistencia del enlace correspondiente dentro de \n/etc/systemd/system/nomTarget.target.wants\n).\nTampoco podr\u00e1 ser iniciada autom\u00e1ticamente mediante otros sistemas (como v\u00eda socket, v\u00eda D-Bus o bien v\u00eda conexi\u00f3n de hardware. No obstante, podr\u00e1 ser puesta en marcha en cualquier momento \"manualmente\" ejecutando systemctl start ( ver m\u00e1s abajo)\n\n\n\n\n\n\n\"Masked\" o \"Masked-runtime \": La unido est\u00e1 Enmascarado (es decir, est\u00e1 desactivada y, por tanto, no se\npondr\u00e1 en marcha los siguientes reinicios ni autom\u00e1ticamente, pero adem\u00e1s, tampoco podr\u00e1 ser puesta nunca\nen marcha manualmente con systemctl start ni siquiera si es una dependencia de otro servicio)\nsystemctl {start | stop | restart} nomUnit [.service]\nActiva / Desactiva / Reiniciar la unido indicada inmediatamente siguiendo las indicaciones escritas a su\narchivo de configuraci\u00f3n correspondiente.\nNOTA: Si la unido no fuera de tipo \".service\", entonces habr\u00e1 que indicar su tipo expl\u00edcitamente \u00faltima su nombre (por\nejemplo, systemctl start nomUnit.socket ). Esta norma es extensiva para el resto de pedidos\nsystemctl {enable | disable} nomUnit [.service]\nActivar\u00e1 / desactivar\u00e1 autom\u00e1ticamente la unido indicada a partir del siguiente reinicio (y siguientes)\nNOTA: En realidad lo que hace enable / disable es crear / eliminar un enlace dentro de la carpeta\n\"/ etc / systemd / systemd / nomTarget .target.wants\" en el archivo de configuraci\u00f3n de la unido en cuesti\u00f3n (donde \"nomTarget\" viene definido en\nla directiva WantedBy de la secci\u00f3n \"[Install]\" de dicho archivo).\nsystemctl {mask | unmask} nomUnit [.service]\nEnmascara / desenmascarar la unido indicada.\nNOTA: Esto lo consigue vinculando el archivo de configuraci\u00f3n ubicado en / etc / ... de la unido en cuesti\u00f3n a / dev / null\nsystemctl is-enabled nomUnit [.service]\nDevuelve $? = 0 si la unido indicada est\u00e1 configurada para activarse en los siguientes reinicios (es decir, si\nest\u00e1 en los estados -Listados para systemctl list-unido-files -: \"enabled\", \"enabled-runtime\", \"static\",\n\"Generated\" o \"transient\") y adem\u00e1s, muestra en pantalla este estado.\nsystemctl is-active nomUnit [.service]\nDevuelve $? = 0 si la unido indicada est\u00e1 activa y, adem\u00e1s, muestra en pantalla este estado (valor listado en la\ncolumna ACTIVE de systemctl list-unidos )\nsystemctl is-failed nomUnit [.service]\nDevuelve $? = 0 si la unido indicada fall\u00f3 al intentar activarse y, adem\u00e1s, muestra en pantalla este\nestado. Si no queremos que se muestren los estados en pantalla (esto tambi\u00e9n por is-enabled y is-active ), se\npuede a\u00f1adir el par\u00e1metro -q\nNOTA: Una unido puede estar en estado \"failed\" miedo m\u00faltiples razones: para que el proceso ha terminado con un c\u00f3digo de error\ndiferente de 0, porque ha finalizado de forma anormal, porque se ha superado un timeout determinado, etc.\nsystemctl status {nomUnit [.service] | PID}\nMuestra el estado e informaci\u00f3n variada sobre la unido o proceso indicado. Si se indica una unido se puede ver ...:\nLoaded: loaded (/usr/lib/systemd/system/cups.service; enabled; vendor preset: disabled)\nActive: active (running) since Sat 2017-11-18 20:48:06 CET; 4h 2min agosto\nDocs: man: cupsd (8)\nMain PID : 745 (cupsd)\nStatus: \"Scheduler is running ...\"\nTasks: 1 (l\u00edmite: 4915)\nCGroup: /system.slice/cups.service\n\u2514\u2500745 / usr / sbin / cupsd -l\n\u00daltimas l\u00edneas de journald -u (se puede usar los par\u00e1metros hom\u00f3nimos -n n\u00ba y -o xxx)\nLos valores para la l\u00ednea \"Loaded:\" son los mismos que aparecen en la columna LOAD de list-unidos\nSeguidamente se indican los valores del estado actual y el predefinido por paquete, que ser\u00e1n uno de los\ndetallados anteriormente al hablar de list-unido-filas\nLos valores para la l\u00ednea \"Active:\" son los mismos que aparecen en la columna ACTIVE de list-unidos\nEl punto ( \"\u25cf\") es blanco si la unido est\u00e1 \"inactive\"; rojo si \"failed\" o verde si \"active\"\nPage 4\nSi se indica un PID en vez de una unido, se puede ver la misma informaci\u00f3n, pero esta manera\npuede ser \u00fatil para conocer la unido a la que est\u00e1 asociado un determinado proceso, por ejemplo (aunque\npara conocer esta informaci\u00f3n tambi\u00e9n se podr\u00edan observar los valores de la columna \"unido\" mostrada\npara el pedido ps si as\u00ed se indica con el par\u00e1metro -o ):\ncups.service - CUPS Scheduler\nLoaded: loaded ( /usr/lib/systemd/system/cups.service ; enabled; vendor preset:\nActive: active (running) since Sat 2017-11-18 20:48:06 CET; 4h 2min agosto\nDocs: man: cupsd (8)\nMain PID: 745 (cupsd)\nStatus: \"Scheduler is running ...\"\nTasks: 1 (l\u00edmite: 4915)\nCGroup: /system.slice/cups.service\n\u2514\u2500745 / usr / sbin / cupsd -l\n\u00daltimas l\u00edneas de journald _PID = (se puede usar los par\u00e1metros hom\u00f3nimos -n n\u00ba y -o xxx)\nsystemctl show {nomUnit [.service] | PID}\nMuestra la configuraci\u00f3n actual de la unido (obtenida a partir del archivo general system.conf y del archivo\nde configuraci\u00f3n propio de la unit) indicada en un formato adecuado para ser procesado por m\u00e1quinas. con\npar\u00e1metro -p \"nomClau, unAltreNom, ...\" se pueden obtener s\u00f3lo las parejas clave <-> valor deseadas.\nsystemctl daemon-reload\nActualizar todos los archivos de configuraci\u00f3n de unidos nuevas o modificadas desde la \u00faltima vez que se\npuso en marcha systemd (incluyendo los generators).\nsystemctl help nomUnit [.service]\nAbre la p\u00e1gina man asociada a la unido indicada (en su fichero de configuraci\u00f3n debe venir indicada)\nsystemctl edit nomUnit [.service]\nCrea (con el editor de texto predeterminado del sistema) un fichero de configuraci\u00f3n (inicialmente vac\u00edo) para\nla unido indicada llamado \"/ etc / systemd / system / nomUnit. tipusUnit .d / override.conf\" para sobrescribir\n(O ampliar) la configuraci\u00f3n ya existente por ella. Una vez guardados los cambios, recarga la unido\nautom\u00e1ticamente con esta nueva configuraci\u00f3n. Si se quisiera editar directamente el archivo\n\"/ etc / systemd / system / nomUnit .tipusUnit \", hay que a\u00f1adir entonces el par\u00e1metro --full\nsystemctl cat nomUnit [.service]\nMuestra la configuraci\u00f3n final actual resultante de haber le\u00eddo los diferentes ficheros de configuraci\u00f3n\nposibles de la unido indicada\nsystemd-delta\nMuestra qu\u00e9 archivos de configuraci\u00f3n de unidos est\u00e1n sobreescritos o ampliados (de / usr / lib a / etc y / o con\narchivos \"overrides\"), enmascarados, redireccionados (con la l\u00ednea Alias \u200b\u200b= de la secci\u00f3n [Install]), etc y por\ncu\u00e1les\nsystemctl kill [--signal = n\u00ba] nomUnit [.service]\nEnv\u00eda una se\u00f1al concreta (indicada con el par\u00e1metro --signal ; por defecto es la n\u00ba15, SIGTERM) a\ntodos procesos asociados a la unido indicada.\nNOTA : kill goes directly and send a signal to every process in the group, however stop goes through the\nofficial configured way to seco down a service, ie invokes the stop command configured with ExecStop = in the service\nfile. Usually stop should be sufficient. kill is the Tougher versi\u00f3n, for casas where you either do not want the official\nshutdown command of a service to run, oro when the service is hosed and hung in other ways.\nPage 5\nSystemd tambi\u00e9n permite definir servicios para que no est\u00e9n asociados al sistema global sino que \u00fanicamente\nformen parte de la sesi\u00f3n de un usuario est\u00e1ndar, gener\u00e1ndose una instancia particular del servicio para cada usuario\nactivo en la m\u00e1quina. De este modo, cada instancia se iniciar\u00e1 autom\u00e1ticamente despu\u00e9s de iniciar la sesi\u00f3n\nde un usuario y se parar\u00e1 en salir.\nNOTA: Esto es posible gracias a que justo despu\u00e9s del primer inicio de sesi\u00f3n que se realice al sistema se pone en marcha (gracias al\nm\u00f3dulo PAM \"pam_systemd\") el pedido systemd -user ( quien es quien permitir\u00e1 este funcionamiento individual para todas las sesiones\nde usuarios que inicien a partir de entonces), adem\u00e1s del proceso con PID 1 propiamente dicho, que es systemd -system . El proceso systemd -\nuser finalizar\u00e1 autom\u00e1ticamente justo despu\u00e9s de haberse cerrado el \u00faltimo inicio de sesi\u00f3n existente al sistema.\nLos ficheros de configuraci\u00f3n de las unidos \"de tipo usuario\" se encuentran en otras carpetas de las de las unidos \"de\nsistema \". Concretamente (se muestran en orden de precedencia ascendente):\n\"/ Usr / lib / systemd / user\": Para unidos proporcionados por los paquetes instalados en el sistema\n\"~ / .Local / share / systemd / user\": Para unidos de paquetes que han sido instaladas en la carpeta personal\n\"/ Etc / systemd / user\": Para unidos proporcionados por administrador del sistema\n\"~ / .Config / systemd / user\": Para unidos construidas por el propio usuario\nNOTA: La variable especial% h se puede utilizar dentro de los archivos de configuraci\u00f3n de las unidos \"de usuario\" para indicar la ruta de la\ncarpeta personal del usuario en cuesti\u00f3n.\nOtra caracter\u00edstica de las unidos \"de usuario\" es que pueden ser gestionadas por parte de este usuario sin\nque deba ser administrador del sistema; esto lo puede hacer con las mismas pedidos systemctl ... ya\nconocidas s\u00f3lo que a\u00f1adiendo el par\u00e1metro --user As\u00ed, por ejemplo, para arrancar un servicio autom\u00e1ticamente\ncada vez que se inicie nuestra sesi\u00f3n habr\u00e1 que ejecutar systemctl --user enable nomUnit ; para ver el estado de\ntodas nuestras unidos \"de usuario\" habr\u00e1 que hacer systemctl --user list-unidos ; para recargar las unidos modificadas\nhabr\u00e1 que hacer systemctl --user daemon-reload , etc\nSecciones y directivas comunes en los ficheros de configuraci\u00f3n de las unidos\nLa estructura interna de los archivos de configuraci\u00f3n de las unidos est\u00e1 organizada en secciones, distinguidas\ncada una por un encabezamiento may\u00fasculas y min\u00fasculas rodeado de corchetes ( [Encabezamiento] ). Dentro de las\nsecciones se definen diferentes directivas (tambi\u00e9n may\u00fasculas y min\u00fasculas) en la forma de parejas\nNomDirectiva = valor , donde el valor puede ser una palabra, una frase, una ruta, un n\u00famero, t rue / yes of levante / no , una\nfecha, etc, dependiendo de su significado.\nNOTA: Tambi\u00e9n pueden existir directivas donde no se escriba ning\u00fan valor (es decir, as\u00ed: NomDirectiva = ). En este caso, se estar\u00e1\n\"Resetear\" (es decir, anulando) el valor que previamente se hubiera dado en otro sitio\nLa primera secci\u00f3n (aunque el orden no importa) siempre suele ser la llamada [Unido] y se utiliza para\ndefinir datos sobre la propia unido en s\u00ed como unido que es y la relaci\u00f3n que tiene \u00e9sta con otros unidos. algunas\nde sus directivas m\u00e1s habituales son:\nDescription = Una breve descripci\u00f3n de la unido\nSu valor es devuelto por diferente herramientas systemd\nDocumentation = man: sshd (8) https: //ruta/pag.html\nProporciona una lista de URIS que apuntan a documentaci\u00f3n de la unido.\nEl pedido systemctl status las muestra\nWants = unservei.service unaltre.service untarget.target ...\nLista las unidos que ser\u00eda bueno que estuvieran iniciadas para que el unido en cuesti\u00f3n pueda\nfuncionar correctamente. Si no lo est\u00e1n ya, systemd las iniciar\u00e1 en paralelo junto con\nel unido en cuesti\u00f3n; si se quiere indicar un cierto orden en vez de iniciar todas en paralelo, se puede\nutilizar las directivas After = o Before =. Si alguna de las unidos listadas falla al iniciarse,\nel unido en cuesti\u00f3n se iniciar\u00e1 igualmente\nPage 6\nRequires = unservei.service unaltre.service untarget.target ...\nLista las unidos que imprescindiblemente deben estar iniciadas para que el unido en cuesti\u00f3n pueda\nfuncionar correctamente. Si no lo est\u00e1n ya, systemd las iniciar\u00e1 en paralelo junto con\nel unido en cuesti\u00f3n; si se quiere indicar un cierto orden en vez de iniciar todas en paralelo, se puede\nutilizar las directivas After = o Before =. Si alguna de las unidos listadas falla al iniciarse,\nel unido en cuesti\u00f3n tambi\u00e9n fallar\u00e1 autom\u00e1ticamente\nBindsTo = unservei.service unaltre.service untarget.target ...\nSimilar a Requires = pero, adem\u00e1s, hace que el unido en cuesti\u00f3n se detenga autom\u00e1ticamente si alguna de\nlas unidos asociadas finaliza.\nBefore = unservei.service unaltre.service untarget.target ...\nIndica, de las unidos listadas en las directivas Wants = o Requires =, qu\u00e9 no se iniciar\u00e1n en\nparalelo sino tras la unido en cuesti\u00f3n. Si aqu\u00ed se indicara alguna unido que no se encontrara\nlistada en Wants = o Requires =, esta directiva no se tendr\u00e1 en cuenta.\nAfter = unservei.service unaltre.service untarget.target ...\nIndica, de las unidos listadas en las directivas Wants = o Requires =, qu\u00e9 no se iniciar\u00e1n en\nparalelo sino antes de la unido en cuesti\u00f3n. Si aqu\u00ed se indicara alguna unido que no se encontrara\nlistada en Wants = o Requires =, esta directiva no se tendr\u00e1 en cuenta.\nNOTA: El m\u00e1s t\u00edpico es tener una unido A que necesita que la unido B est\u00e9 funcionando previamente para poderse poner\nen marcha. En este caso, simplemente habr\u00eda que a\u00f1adir las l\u00edneas Requires = B y After = B en la secci\u00f3n [Unido] del unido A. Si la\ndependencia es opcional, se puede sustituir Requires = B para Wants = B\nConflicts = unservei.service unaltre.service ...\nLista las unidos que no pueden estar funcionando a la vez que el unido en cuesti\u00f3n. iniciar\nuna unido con esta directiva causar\u00e1 que las aqu\u00ed listadas detengan autom\u00e1ticamente.\nConditionXXXX = ...\nHay un conjunto de directivas que empiezan por \"Condition\" que permiten al administrador\ncomprobar ciertas condiciones antes de iniciar el unido. Si la condici\u00f3n no se cumple, la unido es\nignorada. Algunos ejemplos son:\nConditionKernelCommandLine = param [= valor]\nConditionACPower = {yes | no}\nConditionPathExists = [!] / Ruta / archivo / o / carpeta\nConditionPathExistsGlob = [!] / Ruta / archivos / o / carpetas\nConditionPathIsDirectory = [!] / Ruta / carpeta\nConditionPathIsSymbolicLink = [!] / Ruta / enlace\nConditionPathIsMountPoint = [!] / Ruta / carpeta\nConditionPathIsReadWrite = [!] / Ruta / archivo / o / carpeta\nConditionDirectoryNotEmpty = [!] / Ruta / carpeta\nConditionFileNotEmpty = [!] / Ruta / archivo\nConditionFileIsExecutable = [!] / Ruta / archivo\nAssertXXXX = ...\nAl igual que con \"ConditionXXX\", hay un conjunto de directivas que empiezan por \"Assert\"\nque permiten al administrador comprobar ciertas condiciones antes de iniciar el unido. la\ndiferencia es que aqu\u00ed, si la condici\u00f3n no se cumple, se emite un error.\nOnFailure = unaunit.service unaaltra.service ...\nIndica las unidos que se activar\u00e1n cuando la unido en cuesti\u00f3n entre en estado \"failed\". esta\ndirectiva puede utilizarse, por ejemplo, para ejecutar una unido que env\u00ede un correo electr\u00f3nico\ncuando la unido en cuesti\u00f3n, que podr\u00e1 ser un servicio, falle.\nPage 7\nAllowIsolate = yes\nEsta directiva s\u00f3lo tiene sentido para unidos de tipo target. Si su valor es \"yes\" (por\ndefecto es \"no\") indica que el target en cuesti\u00f3n admitir\u00e1 que se le aplique el pedido\nsystemctl Isolate (ver m\u00e1s abajo)\nPor otra parte, la \u00faltima secci\u00f3n (aunque el orden no importa) de un archivo de configuraci\u00f3n de una unido\nsiempre suele ser la llamada [Install] , la cual, atenci\u00f3n, es opcional. Se utiliza para definir c\u00f3mo y cuando el unido puede\nser activada o desactivada. Algunas de sus directivas m\u00e1s habituales son:\nWantedBy = untarget.target unaltre.target ...\nIndica los targets donde el unido en cuesti\u00f3n se activar\u00e1 en ejecutar el comando systemctl enable\nCuando se ejecuta este comando, lo que pasa es que por cada target indicado aqu\u00ed aparecer\u00e1,\ndentro de cada carpeta \"/etc/systemd/system/nomTarget.wants\" respectiva, un enlace simb\u00f3lico\napuntando al propio archivo de configuraci\u00f3n del unido en cuesti\u00f3n. La existencia de este enlace es el\nque realmente activa de forma efectiva un servicio autom\u00e1ticamente. Eliminar los links de todas\nlas carpetas \"nomTarget.wants\" pertinentes implica desactivar la unido (que es lo que hace, de hecho,\nel pedido systemctl disable a partir de la lista de targets que encuentra en la l\u00ednea WantedBy = ).\nPor ejemplo, si el archivo de configuraci\u00f3n de la unido en cuesti\u00f3n (que llamaremos pepito.service)\ntiene una l\u00ednea como WantedBy = multi-user.target, al ejecutar systemctl enable pepito.service\naparecer\u00e1 dentro de la carpeta /etc/systemd/system/multi-user.wants un link apuntando a este\narchivo de configuraci\u00f3n\nRequiredBy = untarget.target unaltre.target ...\nSimilar a WantedBy = pero donde el fallo del unido en cuesti\u00f3n en ejecutar systemctl enable har\u00e1\nque los targets indicados aqu\u00ed no puedan llegar a alcanzar. La carpeta donde se encuentra el link de\nel unido en este caso se denomina \"/etc/systemd/system/nomTarget.requires\"\nAlias \u200b\u200b= unaltrenom.tipusUnit\nPermite al unido en cuesti\u00f3n fue activada con systemctl enable utilizando otro nombre diferente\nAlso = unservei.service unaltre.service ...\nPermite activar o desactivar diferentes unidos como conjunto. La lista debe consistir en todas las\nunidos que tambi\u00e9n se quieren tener habilitadas cuando la unido en cuesti\u00f3n est\u00e9 habilitada\nSecci\u00f3n [Service] (por unidos de tipo .service):\nDependiendo del tipo de unido que tengamos nos podremos encontrar con diferentes secciones espec\u00edficas dentro\nde su fichero de configuraci\u00f3n, normalmente escritas entre la secci\u00f3n [Unido] el principio y la secci\u00f3n [Install] del\nfinal (si existe). En el caso de las unidos de tipo \"service\", por ejemplo, nos encontramos con la secci\u00f3n espec\u00edfica\nllamada [Service] , la cual puede incluir diferentes directivas como las siguientes:\nNOTA: Las unidos de tipo device, snapshot y target no tienen secciones espec\u00edficas\nType = maneraDarrancar\nExisten diferentes m\u00e9todos para iniciar un servicio, y el m\u00e9todo elegido, el cual depender\u00e1 del tipo\nde ejecutable a poner en marcha, se indicar\u00e1 en esta directiva. Las posibilidades m\u00e1s\ncomunes son:\nsimple: El servicio nativamente se queda en primer plano de forma indefinida y es systemd quien el\npone en segundo plano (le crea un fichero PID, lo para cuando sea necesario, etc). Systemd interpreta que el\nservicio est\u00e1 listo luego que el ejecutable asociado se pone en marcha (aunque esto sea\ndemasiado pronto para que no est\u00e9 listo todav\u00eda para recibir peticiones)\nforking: El servicio nativamente ya se pone en segundo plano. Systemd interpreta que el servicio est\u00e1\nlisto cuando pasa efectivamente a segundo plano. En este caso conviene indicar tambi\u00e9n la directiva\nPidFile = / ruta / fitxer.pid para que systemd tenga un control sobre qu\u00e9 proceso es el que est\u00e1\nen segundo plano y lo pueda identificar\nPage 8\noneshot: \u00datil para scripts, que se ejecutan (haciendo systemctl start igualmente) una vez y finalizan.\nSystemd esperar\u00e1 hasta que el proceso finalice e interpreta que est\u00e1 listo cuando haya finalizado.\nSe puede considerar el uso de la directiva RemainAfterExit = yes para \"enga\u00f1ar\" a systemd\ndici\u00e9ndole que el servicio contin\u00faa activo aunque el proceso haya finalizado; en este caso, la\ndirectiva ExecStop = no se llegar\u00e1 a hacer efectiva nunca.\nTambi\u00e9n est\u00e1n las posibilidades \"dbus\" (similar a \"simple\" pero systemd interpreta que est\u00e1 listo\ncuando el nombre indicado en BusName = ha sido adquirido), \"idle\" (similar a \"simple\" pero con\nla ejecuci\u00f3n retrasada hasta que no se ejecute nada m\u00e1s; se puede utilizar este m\u00e9todo, por\nejemplo, para emitir un sonido justo despu\u00e9s de la finalizaci\u00f3n del arranque del sistema.) y \"notify\"\n(El sistema m\u00e1s completo, donde se establece un canal de comunicaci\u00f3n interno entre el servicio y\nSystemd para notificarse estados y eventos v\u00eda la API propia de systemd sd_notify () y donde\nSystemd interpreta que est\u00e1 listo cuando recibe el estado correspondiente a trav\u00e9s de este canal; si\nqueremos que scripts utilicen este m\u00e9todo hay que usar el comando systemd-notify )\nExecStart = / ruta / ejecutable param1 param2 ...\nIndica el pedido (y par\u00e1metros) a ejecutar cuando se realiza un systemctl start Si la ruta de\nel ejecutable comienza con un gui\u00f3n ( \"-\"), valores de retorno del pedido diferentes de 0 (que\nnormalmente se considerar\u00edan se\u00f1al de error) se considerar\u00e1n como v\u00e1lidos.\nNOTA : Podemos utilizar incluso la directiva SuccessExitStatus = para indicar qu\u00e9 valor consideramos como salida\nexitosa del programa\nNOTA: No habr\u00eda que escribir la ruta absoluta del ejecutable si \u00e9sta se encuentra en la lista de rutas que muestra la\npedido systemd-path , pero en general se recomienda escribirla para evitar sorpresas\nNOTA: No se permiten escribir redireccionador ( \">\", \">>\", \"<\". \"|\") Ni el s\u00edmbolo \"&\" para pasar a segundo plano\nExecStartPre = / ruta / ejecutable param1 param2 ...\nIndica el pedido (y par\u00e1metros) a ejecutar antes de la indicada en ExecStart. pueden haber\nm\u00e1s de una l\u00ednea ExecStartPre al mismo archivo, ejecut\u00e1ndose entonces cada por orden. la\nruta del ejecutable tambi\u00e9n puede ir precedida de un gui\u00f3n ( \"-\"), con el mismo significado\nExecStartPost = / ruta / ejecutable param1 param2 ...\nIndica el pedido (y par\u00e1metros) a ejecutar despu\u00e9s de la indicada en ExecStart. pueden haber\nm\u00e1s de una l\u00ednea ExecStartPost al mismo archivo, ejecut\u00e1ndose entonces cada por orden. un\nejemplo de posible uso: el env\u00edo de un correo justo despu\u00e9s de haberse puesto en marcha el\nservicio corresponent.La ruta del ejecutable tambi\u00e9n puede ir precedida de un gui\u00f3n ( \"-\"), con el\nmismo significado\nExecStop = / ruta / ejecutable param1 param2 ...\nIndica el pedido (y par\u00e1metros) a ejecutar cuando se realiza un systemctl stop Hay que tener en\ncuenta que en el caso de un servicio de tipo \"oneshot\", si no se especifica la directiva\nRemainAfterExit = yes , el pedido indicada en ExecStop ejecutar\u00e1 autom\u00e1ticamente justo\ntras ExecStart.\nExecStopPost = / ruta / ejecutable param1 param2 ...\nIndica el pedido (y par\u00e1metros) a ejecutar despu\u00e9s de la indicada en ExecStop. pueden haber\nm\u00e1s de una l\u00ednea ExecStartPost al mismo archivo, ejecut\u00e1ndose entonces cada por orden.\nRestart = {always | no | on-success | on-failure | ...}\nIndica las circunstancias bajo las que systemd intentar\u00e1 reiniciar autom\u00e1ticamente un servicio\nque haya finalizado. En concreto, el valor \"always\" indica que en cualquier tipo de finalizaci\u00f3n\nse volver\u00e1 a intentar reiniciar; el valor \"no\" indica que en ning\u00fan finalizaci\u00f3n intentar\u00e1 reiniciar,\nel valor \"on-success\" indica que s\u00f3lo se intentar\u00e1 reiniciar si la finalizaci\u00f3n ha sido correcta\ny \"on-failure\" si la finalizaci\u00f3n no lo ha sido debido a cualquier tipo de fallo (ya sea que\nse ha sobrepasado el tiempo de espera del arranque o el apagado, que se ha devuelto un valor diferente\nde 0, etc)\nPage 9\nNOTA: Se podr\u00eda dar el caso de que un servicio estuviera reinici\u00e1ndose todo el rato. Con StartLimitBurts = se puede\nconfigurar el n\u00famero m\u00e1ximo de veces que se quiere que se reinicie y con StartLimitIntervalSec = se puede\nconfigurar el tiempo durante el cual se contar\u00e1 este n\u00famero m\u00e1ximo de veces. Si se llega a este n\u00famero dentro\nde este tiempo, el servicio no se volver\u00e1 a reiniciar autom\u00e1ticamente y tampoco se podr\u00e1 iniciar manualmente hasta\npasado el tiempo indicado (momento en el que se vuelve a contar). Tambi\u00e9n existe la directiva StartLimitAction = ,\nla que sirve para indicar la acci\u00f3n a realizar cuando se alcanza el n\u00famero m\u00e1ximo de reinicios; su valor por defecto es\n\"None\" pero puede valer tambi\u00e9n \"reboot\" (reinicio limpio), \"reboot-force\" (reinicio abrupto) y \"reboot-immediate\" (reinicio\nmuy abrupto)\nRestartSec = n\u00bas\nIndica el n\u00famero de segundos que systemd esperar\u00e1 al reiniciar el servicio despu\u00e9s de que\nhaya detenido (si as\u00ed lo marca la directiva Restart =).\nTimeoutSec = n\u00ba\nIndica el n\u00famero de segundos que systemd esperar\u00e1 a que el servicio en cuesti\u00f3n inicie o detenga\nantes de marcarlo como \"failed\" (y reiniciarlo si fuera el caso debido a la configuraci\u00f3n de la\ndirectiva Restart =). Se puede indicar espec\u00edficamente un tiempo de espera s\u00f3lo para el inicio con la\ndirectiva TimeoutStartSec = y otro tiempo de espera diferente por el apag\u00f3n con la directiva\nTimeoutStopSec = . Si no se especifica nada, se toma el valor por defecto (5 min) que est\u00e1 indicado\na /etc/systemd/system.conf\nRemainAfterExit = yes\nTal como ya lo hemos comentado, esta directiva se utiliza en servicios de tipo \"oneshot\" para\nque la directiva ExecStop = no se ejecute al terminar la ejecuci\u00f3n del pedido sino en hacer\nsystemctl stop\nPidFile = /ruta/fitxer.pid\nTal como ya lo hemos comentado, esta directiva se utiliza en servicios de tipo \"forking\" para\nse\u00f1alar a systemd cu\u00e1l ser\u00e1 el archivo PID utilizado por el servicio de manera que pueda\ncontrolar m\u00e1s f\u00e1cilmente.\nUser = unusuari\nGroup = ungrup\nSiete the user oro group that the processes are executed as, respectively. They can take a single\nuser / group name, oro a numeric ID as argumento. For system services (services run by the\nsystem service manager, ie managed by PID 1) the default is \"root\". For user services of\na\u00f1o other user, switching user identity is not permitted, Hence the only valid setting is the\nsame user the user s service manager is running as. If no group is set, the default group of the\nuser is used.\nWorkingDirectory = / ruta / carpeta\nIndica el directorio de trabajo del servicio en cuesti\u00f3n. Si no se especifica esta directiva, el\nvalor por defecto es \"/\" (en el caso de servicios de sistema) o $ HOME (en el caso de servicios\nde usuario, es decir, iniciados con --user -). Si la ruta se precede con un s\u00edmbolo \"-\", el hecho de\nque la carpeta correspondiente no exista no se interpretar\u00e1 como un error. Si se ha indicado la\ndirectiva User =, se puede escribir \"~\" como valor de esta directiva, equivalente as\u00ed a la ruta\nde la carpeta personal del usuario indicado en User =.\nStandardOutput = {null | tty | journal | socket}\nIndica donde se imprimir\u00e1 la salida est\u00e1ndar de los programas indicados en las directivas ExecStart =,\ny ExecStop =. El valor \"null\" representa el destino / dev / null. El valor \"tty\" representa un\nterminal (ya sea de tipo virtual - / dev / ttyX- o pseudo - / dev / pts / X-), el cual deber\u00e1 ser\nespecificado mediante la directiva TTYPath = . El valor \"journal\" es el valor por defecto (es\ndecir, que si el programa en cuesti\u00f3n imprimiera algo en la pantalla del terminal en\nejecutarse en primer plano, esta salida se redireccionar\u00e1 el Journal en ejecutarse v\u00eda\nun archivo .service). El valor \"socket\" sirve para indicar que la salida debe enviarse al\nsocket asociado al servidor con el fin de viajar al otro extremo de la comunicaci\u00f3n (ver m\u00e1s\nadelante).\nPage 10\nNOTA: El hecho de que por defecto la salida est\u00e1ndar vaya a parar en el Journal se puede cambiar de forma general para\ntodas las unidos a la directiva DefaultStandardOutput del archivo /etc/systemd/system.conf\nNOTA: Tambi\u00e9n existe la directiva StandardError = {null | tty | journal | socket} , similar a\nStandardOutput = pero para la salida de error\nEJERCICIOS:\nTodos los ejercicios se har\u00e1n en una m\u00e1quina virtual donde el usuario pueda tener permisos de administrador:\n1.-a) Ejecutar systemctl list-unidos -t service | grep ufw (si est\u00e1s en Ubuntu) o systemctl list-unidos -t service |\ngrep firewalld (si est\u00e1 en Fedora). \u00bfQu\u00e9 significa la palabra \"loaded\"? Y \"active\"? Confirma esto ejecutando\nsystemctl status ufw / systemctl status firewalld\nb) Ahora enmascara la unido ufw / firewalld. \u00bfQu\u00e9 pasa realmente cuando s'enmascara una unido? Pista: consulte donde\napunta el reci\u00e9n creado archivo /etc/systemd/system/ufw.service (o /etc/systemd/system/firewalld.service)\nc) Ejecutar systemctl list-unidos -t service | grep ufw (o systemctl list-unidos -t service | grep firewalld ) de nuevo.\n\u00bfPor qu\u00e9 todav\u00eda aparece la palabra \"active\"? Confirma esto ejecutando systemctl status ufw / systemctl status\nfirewalld\nd) Si ahora ejecutas systemctl stop ufw (o systemctl stop firewalld ) , \u00bfqu\u00e9 muestra systemctl list-unidos -t service |\ngrep ufw (o systemctl list-unidos -t service | grep firewalld )? \u00bfPor qu\u00e9? \u00bfQu\u00e9 deber\u00edas hacer para que vieras\nalgo? Pista: usa el par\u00e1metro --all\ne) Ejecutar el pedido systemd-delta . \u00bfQu\u00e9 significa la relaci\u00f3n indicada entre los dos archivos que aparecen en\nla l\u00ednea [Masked]? \u00bfY entre los dos archivos que aparecen en las l\u00edneas [EXTENDED]?\nNOTA: Tambi\u00e9n podr\u00eda haber alguna pareja de archivo en l\u00edneas [overrides] o incluso [EQUIVALENTE]\nf) Intenta iniciar el unido ufw (o firewalld) todav\u00eda Enmascarado. Puedes? Desenmascara y vuelve a intentarlo. puedes\nahora?\ng) Ejecutar el pedido systemctl edit ufw (o systemctl edit firewalld ) y, en el editor de texto que aparece, escribe la\nl\u00ednea Description = Hola amigo y guarda. A continuaci\u00f3n, ejecuta systemctl cat ufw (o systemctl cat firewalld ) .\n\u00bfQu\u00e9 ves? Y si vuelves a ejecutar systemd-delta ?\n2.-a) Crear un archivo llamado /etc/systemd/system/pepe.service con el siguiente contenido ...:\n[Unido]\nDescription = Pepe se colega\n[Service]\nType = oneshot\nExecStart = / bin / ls -l\nExecStop = / bin / df -h\n[Install]\nWantedBy = multi-user.target\n... y a continuaci\u00f3n (despu\u00e9s de systemctl daemon-reload) ejecuta systemctl start pepe Qu\u00e9 ves? Y si haces journalctl\n-e, \u00bfqu\u00e9 ves? \u00bfPor qu\u00e9?\nb) \u00bfQu\u00e9 deber\u00edas modificar del archivo anterior para que el comando / bin / df -h no ejecutara justo despu\u00e9s de /\nbin / ls -l sino s\u00f3lo cuando se escriba systemctl stop pepe ? Pista: consulta la explicaci\u00f3n del tipo \"oneshot\" en la\nteor\u00eda. Pru\u00e9balo utilizando los pedidos systemctl -full edit pepe, systemctl daemon-reload y, de nuevo,\njournalctl -e\nPage 11\nc) Para qu\u00e9 sirve la l\u00ednea WantedBy = ... ? O dicho de otro modo: \u00bfqu\u00e9 relaci\u00f3n tiene esta l\u00ednea con la\npedido systemctl enable ? Pista: observa el contenido de la carpeta / etc / systemd / system / multi-\nuser.target.wants\nd) \u00bfQu\u00e9 deber\u00edas modificar del archivo anterior para que la salida de los pedidos ejecutadas por la unido (ya\nsea \u200b\u200ba ExectStart = oa ExecStop =) no vaya a parar al Journal sino que se visualice el terminal / dev / tty4?\nPru\u00e9balo.\n3.-a) Crear un script llamado \"/ opt / yeah\" con el siguiente contenido (y dale permisos de ejecuci\u00f3n):\n\n\n\n\n\n\n! / Bin / bash\n\uf0c1\n\n\nwhile [[true]]\ndo\ncurl -s ipinfo.io/ip\n/ Bin / sleep 3\nd\u00e9\nb) Crear un archivo llamado \"/etc/systemd/system/pepa.service\" con el siguiente contenido ...:\n[Unido]\nDescription = Pepa se colega\n[Service]\nType = simple\nExecStartPre = / usr / bin / systemd-cat -t PEPA -p grito echo \"Empieza\"\nExecStart = / opt / yeah\nExecStop = / usr / bin / systemd-cat -t PEPA -p grito echo \"Termino\"\n\n\nStandardOutput = null\n\uf0c1\n\n\n[Install]\nWantedBy = multi-user.target\n... y a continuaci\u00f3n (despu\u00e9s de systemctl daemon-reload) ejecuta systemctl start pepa. S y haces journalctl -f, que\nvoces? \u00bfPor qu\u00e9? Y si ejecutas systemctl stop pepa , que ves entonces el Journal? \u00bfPor qu\u00e9? Y si Descomente\nl\u00ednea que aparece comentada y vuelves a probar?\n4.-a) Crear un archivo llamado \"fiufiu.service\" dentro de \"/ etc / systemd / system\" con el siguiente contenido ...:\n[Unido]\nDescription = All we are saying is give peace a chance\n[Service]\nType = simple\nExecStart = / usr / bin / nc -l -p 5555\nRestart = on-success\n... y seguidamente ponerlo en marcha con el comando sudo systemctl start fiufiu . Comprueba con systemctl status\nfiufiu (o tambi\u00e9n con ss -tnl ) que se haya iniciado correctamente\nb) Ejecutar el pedido journalctl -ef y seguidamente, abre otro terminal para ejecutar en ellos el pedido nc\n127.0.0.1 5555 . Escribe algo la conexi\u00f3n abierta para este cliente Netcat y observa a la vez el\nque aparece en tiempo real en el Journal. \u00bfQu\u00e9 pasa? \u00bfPor qu\u00e9?\nc) Cerrar el cliente y vuelve a ejecutar. \u00bfEl servicio sigue funcionando? Ahora comenta la l\u00ednea Restart = ... que\naparece en el archivo fiufiu.service, reinicia el servicio y vuelve a ejecutar el cliente un par de veces. la primera\nvez deber\u00e1 conectarse sin problemas como siempre pero la segunda ya no. \u00bfPor qu\u00e9?\nPage 12\n5.-a) Instal.la el paquete \"apache2\" y observa, ejecutando el comando systemctl cat apache2 , el valor que tiene la\ndirectiva Restart =. Ejecuta entonces systemctl --signal = 9 kill apache2 y comprueba con systemctl status\napache2 si el servicio reinicia solo o no. \u00bfPor qu\u00e9 pasa lo que pasa?\nb) Cambiar ahora el valor de la directiva Restart = del unido del Apache2 mediante systemctl edit --full apache2\npara que valga \"no\" (recuerda que escribir como primera l\u00ednea el t\u00edtulo de la secci\u00f3n a la que pertenece la directiva\nque quieres sobreescribir -es decir, [Service] -). Despu\u00e9s de hacer systemctl daemon-reload (y de comprobar que la\nmodificaci\u00f3n es efectiva con systemd-delta o tambi\u00e9n systemctl cat apache2) , inicia el servicio de nuevo y\ncomprueba que efectivamente est\u00e9 iniciado. Vuelve a matar de nuevo con systemctl -signal = 9 kill apache2\ny vuelve a comprobar de nuevo si el servicio ha reiniciado autom\u00e1ticamente o no. \u00bfQu\u00e9 pasa ahora?\nc) Agregar mediante systemctl edit apache2 la l\u00ednea necesaria para llamar a una unido que se encargue\nejecutarse en el modo \"oneshot\" el pedido play /ruta/un/fitxer.mp3 cada vez que el Apache finalice debido a\nalguna situaci\u00f3n inesperada (como por ejemplo ser\u00eda una se\u00f1al kill 9)\nNOTA: El comando play encarga de reproducir el archivo de sonido indicado y admite muchos formatos posibles, no\ns\u00f3lo mp3. Forma parte del paquete \"sox\"\n6.a) Ejecuta systemctl disable ufw (o systemctl disable firewalld ) y seguidamente systemctl show --property\n\"Wants\" multi-user.target | grep -E \"(ufw | firewalld)\" \u00bfQu\u00e9 ves? \u00bfPor qu\u00e9? Pista: observa el mensaje que\naparece en pantalla en deshabilitar el servicio ufw\nb) Y si ahora ejecutas systemctl enable ufw (o systemctl enable firewalld ) y vuelves a ejecutar la misma\npedido? \u00bfQu\u00e9 ves ahora? \u00bfPor qu\u00e9? Pista: observa el contenido de la carpeta / etc / systemd / system / multi-\nuser.target.wants\nc) Deduce y di por qu\u00e9 la l\u00ednea After = de la unido ufw.service (o firewalld.service) tiene el valor que tiene.\nd) systemd puede no ser el proceso INIT de nuestro sistema Linux: aunque sea el m\u00e1s extendido con diferencia,\nte puedes encontrar distribuciones que utilicen sistemas INIT alternativos. Dime, de los siguientes comandos,\ncu\u00e1les sirven para comprobar si el proceso INIT de tu sistema es systemd (o no):\nfile / sbin / init\nman init\npgrep ^ systemd $\nPage 13\nSystemd (II)\ntargets\nPodemos definir un \"target\" como un \"estado\" del sistema definido por un determinado conjunto de servicios\npuestos en marcha (y otros que no). La idea es que, al arrancar el sistema, se llegue a un determinado \"target\"\n(Y, opcionalmente, a partir de all\u00ed, poder pasar a otro si fuera necesario). A continuaci\u00f3n se listan los \"targets\"\nm\u00e1s importantes (todos ellos ubicados dentro de / usr / lib / systemd / system):\npoweroff.target (o \"runlevel0.target\") Si se llega a este \"target\", se apaga el sistema\nreboot.target (o \"runlevel6.target\"): Si se llega a este \"target\", se reinicia el sistema\nrescue.target (o \"runlevel1.target\"): Si se llega a este \"target\", se inicia el sistema en modo texto,\nsin red y s\u00f3lo por el usuario root. Ser\u00eda similar a otro\ntarget llamado \" emergency.target \", pero el \"emergency\"\nes m\u00e1s \"radical\" que el \"rescate\" porque gracias a montar la\npartici\u00f3n ra\u00edz en modo s\u00f3lo lectura permite arrancar sistemas\nque el \"rescate\" quiz\u00e1s no puede.\nmulti-user.target (o \"runlevel3.target\"): En este caso se inicia el sistema en modo texto pero con\nred y multiusuario (el target predeterminado en servidores)\ngraphical.target (o \"runlevel5.target\"): En este caso, se inicia el sistema en modo gr\u00e1fico con red\ny multiusuario (el target por defecto en sistemas de escritorio)\nImplica haber pasado por el target \"multi-user\" previamente.\nOtros targets predefinidos que se instalan con systemd y que hay que conocer son:\nctrl-alt-del.target\nTarget activado cuando es pulsado CTRL + ALT + SUPR. Por defecto es un enlace a \"reboot.target\"\nsysinit.target\nTarget que ejecuta los primeros scripts de arranque\nsockets.target\nTarget que activa, al arrancar, todas las unidos de tipo \"socket\". Se recomienda, por tanto, que\ntodos los archivos de configuraci\u00f3n de una unido \"socket\" tengan a su l\u00ednea Wants = este target\nindicado (o bien WantedBy =)\ntimers.target\nTarget que activa, al arrancar, todas las unidos de tipo \"timer\". Se recomienda, por tanto, que\ntodos los archivos de configuraci\u00f3n de una unido \"timer\" tengan a su l\u00ednea Wants = este target\nindicado (o bien WantedBy =)\npaths.target\nTarget que activa, al arrancar, todas las unidos de tipo \"path\". Se recomienda, por tanto, que\ntodos los archivos de configuraci\u00f3n de una unido \"path\" tengan a su l\u00ednea Wants = este target\nindicado (o bien WantedBy =)\nswap.target\nTarget que habilita la memoria swap\nbasic.target\nTarget que pone en marcha todos los target relacionados con puntos de montaje, memorias swaps,\npaths, timers, sockets y otras unidades b\u00e1sicas necesarias para el funcionamiento del sistema.\nPage 14\ninitrd-fs.target\nEl generador systemd-fstab-generator a\u00f1ade autom\u00e1ticamente las unidos indicadas en la\ndirectiva Before = de esta unido a la unido especial \"sysroot-usr.mount\" (adem\u00e1s de todos los\npuntos de montaje existentes en / etc / fstab que tengan establecidas las opciones \"auto\" y\n\"X-initrd.mount\"). Ver m\u00e1s adelante una explicaci\u00f3n de las unidos de tipo mount.\ninitrd-root-fs.target\nEl generador systemd-fstab-generator a\u00f1ade autom\u00e1ticamente las unidos indicadas en la\ndirectiva Before = de esta unido a la unido especial \"sysroot-usr.mount\", la cual es generada a\npartir de los par\u00e1metros del kernel. Lo estudiaremos m\u00e1s adelante\nlocal-fs.target\nEl generador systemd-fstab-generator a\u00f1ade autom\u00e1ticamente las unidos indicadas en la\ndirectiva Before = de esta unido a todas las unidos de tipo \"mount\" que se refieren a puntos\nde montaje locales. Tambi\u00e9n a\u00f1ade a este target las dependencias de tipo Wants =\ncorrespondientes a los puntos de montaje existentes en / etc / fstab que tienen la opci\u00f3n \"auto\" establecida.\nVer m\u00e1s adelante una explicaci\u00f3n de las unidos de tipo mount.\nnetwork-online.target\nTarget que se activa autom\u00e1ticamente en cuanto el subsistema de red es funcional.\nCualquier servicio que tenga que trabajar en red se deber\u00e1 iniciar al menos en este target\nNOTA: Existe otro tarjet relacionado con la red llamado \"pre-network.target\" que est\u00e1 pensado para iniciar servicios\nantes de que cualquier tarjeta de red se configure. Su prop\u00f3sito principal es hacerlo servi con servicios de tipo cortafuegos,\npara establecer las reglas antes de que la configuraci\u00f3n de red funcione. Estos servicios deber\u00e1n tener una l\u00ednea\nBefore = network-pre.target y tambi\u00e9n una l\u00ednea Wants = network-pre.target a su archivo de configuraci\u00f3n\nNOTA: Existe otro tarjet relacionado con la red llamado simplemente \"network.target\" que s\u00f3lo indica que el stack\nsoftware de red ya se ha cargado en memoria pero esto no implica que las interfaces se hayan configurado todav\u00eda. este\ntarget est\u00e1 m\u00e1s pensado para el proceso de apagado de la m\u00e1quina para realizar este proceso de forma ordenada: pues\nla orden de apagado es al rev\u00e9s que el de arranque, cualquier unido que tenga una l\u00ednea After = network.target apagar\u00e1 antes\nque la red se descargue y esto har\u00e1 que esta unido apague sin interrumpir ninguna conexi\u00f3n que est\u00e9 pendiente\nprinter.target\nTarget que se activa autom\u00e1ticamente tan pronto como una impresora es enchufada o aparece\ndisponible durante el arranque. Aqu\u00ed donde se suele iniciar, por ejemplo, el servicio Cups.\nsound.target\nTarget que se activa autom\u00e1ticamente tan pronto como una tarjeta de audio es enchufada o\naparece disponible durante el arranque.\nbluetooth.target\nTarget que se activa autom\u00e1ticamente tan pronto como un controlador Bluetooth es enchufado o\naparece disponible durante el arranque.\nsmartcard.target\nTarget que se activa autom\u00e1ticamente tan pronto como un controlador Smartcard es enchufado o\naparece disponible durante el arranque.\nsystem-update.target\nTarget especial utilizada para actualizaciones del sistema. El generador systemd-System-\nupdate-generator redireccionar\u00e1 el proceso de arranque autom\u00e1ticamente a este target si la\ncarpeta / system-update existe\numount.target\nTarget que desmonta todos los puntos \"mount\" y \"automount\" durante el apagado del sistema\nfinal.target\nTarget utilizado durante el apagado del sistema que puede utilizarse para apagar los \u00faltimos servicios\ndespu\u00e9s de que los servicios \"normales\" ya se han detenido y los puntos de montaje se han desmontado.\nPage 15\nPara saber el target donde nos encontramos en este momento podemos hacer: systemctl get-default\nHay que tener en cuenta que m\u00faltiples targets pueden estar activados a la vez. Un target activado indica\nque systemd ha intentado iniciar todas las unidos asociadas a este target. Esto significa que el comando anterior\ns\u00f3lo nos dice cu\u00e1l es el target \"final\" donde hemos llegado, pero a lo largo del camino desde el arranque de la m\u00e1quina\nhasta llegar a este target \"final\" se han ido activando diferentes targets a modo de \"escalones\" intermedios. por\nver todos los targets activados, hay que hacer systemctl list-unidos -type = target\nSe puede cambiar el target actual a otro simplemente ejecutando: systemctl Isolate\nnomTargetDesti.target Para cambiar el target por defecto donde ir\u00e1 a parar autom\u00e1ticamente a cada arranque del\nsistema se puede hacer: systemctl set-default nomTargetDefecte.target\nNOTA: El comando anterior, en realidad lo \u00fanico que hace es revincular el link \"/etc/systemd/system/default.target\" en el archivo\n* .Target adecuado.\nNOTA: Otra manera de entrar al final del arranque del sistema en un determinado target predeterminado es a\u00f1adir la l\u00ednea\nsystemd.unit = nomTargetDesti.target a la lista de par\u00e1metros del kernel indicada en la configuraci\u00f3n del gestor de arranque\nHay una serie de pedidos espec\u00edficos para pasar a determinados estados (poweroff, reboot, etc) que se\npueden usar en vez del pedido systemctl Isolate gen\u00e9rica. Por ejemplo:\nsudo systemctl rescue : Similar a systemctl Isolate rescue.target\nsudo systemctl poweroff (o sudo poweroff a secas): Similar a systemctl Isolate poweroff.target\nsudo systemctl reboot (o sudo reboot a secas): Similar a systemctl Isolate reboot.target\nSi se quiere detener (-P) o reiniciar (-r) la m\u00e1quina en un momento futuro determinado (hh: mm), entonces habr\u00e1\nejecutar el comando: sudo shutdown {-P | -r} hh: mm\nSi se quiere detener (-P) o reiniciar (-r) la m\u00e1quina dentro de una cierta cantidad de minutos, entonces habr\u00e1 que ejecutar\nel pedido: sudo shutdown {-P | -r} + m\nNOTA: Dentro de la carpeta \"/ usr / lib / systemd / system-shutdown\" pueden haber archivos * .shutdown, que son scripts ejecutables que\nejecutar\u00e1n justo antes del apag\u00f3n / reinicio del sistema (es decir, justo en poner en marcha los servicios \"poweroff.service\" o\n\"Reboot.service\"). Quien ejecutar\u00e1 estos scripts es el binario / usr / lib / systemd / systemd-shutdown, el cual es invocado siempre por\nestos servicios, que lo colocan como PID 1 y es el responsable de desmontar los sistemas de ficheros, deshabilitar la swap, matar\nlos procesos que queden pendientes, etc. A los scripts ejecutados por / usr / lib / systemd / systemd-shutdown podemos utilizar un par\u00e1metro\n($ 1) que puede valer \"poweroff\" o \"reboot\" dependiendo de la acci\u00f3n que realizar\u00e1 y que nos podr\u00eda servir para distinguir qu\u00e9 queremos que haga\neste script seg\u00fan la acci\u00f3n indicada. Todos los scripts se ejecutan en paralelo. Hay que tener en cuenta, finalmente, que el sistema de ficheros\nen ese momento permanece montado pero en modo s\u00f3lo lectura.\nNOTA: En el pedido systemctl reboot le podemos a\u00f1adir varios par\u00e1metros interesantes, los cuales s\u00f3lo funcionan, sin embargo, en sistemas\nUEFI que han arrancado mediante el gestor de arranque systemd-boot :\n--firmware-setup : INDICATE to the system s firmware to reboot into the firmware setup interface (aka the \"UEFI control panel\")\n--boot-loader-menu = n\u00basegons : INDICATE to the system s boot loader to show the boot loader menu on the following boot the number\nof seconds specified as value. Pass 0 value in order to disable the menu timeout.\n- boot-loader-entry = entryID : INDICATE to the system s boot loader to boot into a specific boot loader entry on the following boot.\nTakes a boot loader entry identifier as argumento, oro \"help\" in order to list available entries.\nLo que hacen los par\u00e1metros anteriores es modificar determinados valores de variables EFI concretas (tal como se podr\u00eda haber hecho tambi\u00e9n\ncon el pedido efibootmgr ) para as\u00ed modificar el comportamiento de la UEFI el pr\u00f3ximo arranque\nPor otra parte, con el pedido sudo systemctl suspend podemos suspender el sistema (o dicho de otro\nmanera, nos permiten llegar al target \"suspend.target\") y con el pedido sudo systemctl hibernate la\npodemos poner a hibernar (o dicho de otro modo, permiten llegar al target \"hibernate.target\").\n\"Suspender\" significa que se guarda todo el estado del sistema en la RAM y se apaga la mayor\u00eda de dispositivos de la\nm\u00e1quina; cuando se pone en marcha de nuevo, el sistema restaura su estado previo de la RAM sin tener que reiniciarse\nde nuevo: este proceso es muy r\u00e1pido pero tiene el inconveniente de que obliga a mantener con alimentaci\u00f3n\nel\u00e9ctrica la m\u00e1quina todo el tiempo. \"Hibernar\" significa que se guarda todo el estado del sistema en el disco duro (si tiene\nespacio libre) y se apaga por completo la m\u00e1quina: cuando se pone en marcha de nuevo, el sistema restaura su estado previo desde el\ndisco duro sin tener que reiniciar de nuevo: este proceso es bastante lento pero tiene la ventaja de no tener que\nmantener con alimentaci\u00f3n el\u00e9ctrica la m\u00e1quina.\nPage 16\nNOTA: Dentro de la carpeta \"/ usr / lib / systemd / system-sleep\" pueden haber archivos * .sleep, que son scripts ejecutables que se ejecutar\u00e1n\njusto antes de la hibernaci\u00f3n o suspensi\u00f3n del sistema (es decir, justo en poner en marcha internamente los servicios \"systemd-\nhibernate.service \"o\" systemd-suspend.service \", los cuales, por cierto, nunca deben ser invocados directamente con systemctl start ... sino\nutilizando los pedidos explicadas en el p\u00e1rrafo anterior: systemctl hibernate o systemctl suspend ). Quien ejecutar\u00e1 estos scripts es\nel binario / usr / lib / systemd / systemd-sleep, el cual es invocado siempre por estos servicios y admite dos par\u00e1metros que podemos utilizar\nen estos scripts como $ 1 y $ 2 respectivamente. El primer par\u00e1metro puede valer \"pre\" o \"post\" dependiendo de si la m\u00e1quina est\u00e1 yendo a\nla suspensi\u00f3n / hibernaci\u00f3n o est\u00e1 volviendo, respectivamente. El segundo par\u00e1metro puede valer \"suspend\" o \"hibernate\" dependiendo de la acci\u00f3n\nque realizar\u00e1 y que nos podr\u00eda server para distinguir qu\u00e9 queremos que haga este script seg\u00fan la acci\u00f3n indicada. Todos los scripts\nejecutan en paralelo.\nSi se quiere realizar una tarea larga y asegurarse de que la m\u00e1quina no se suspender\u00e1 o apagar\u00e1 mientras tanto,\nse puede invocar el pedido correspondiente a esta tarea as\u00ed: systemd-inhibido comanda_llarga El pedido\nsystemd-inhibido --list muestra las tareas que tienen este truco en marcha. Si se quiere especificar una acci\u00f3n\nconcreta a inhibir se puede indicar con el par\u00e1metro - what = acci\u00f3n , donde \"acci\u00f3n\" puede ser por ejemplo la palabra\n\"Shutdown\" o \"sleep\" (equivalente a hibernaci\u00f3n o suspensi\u00f3n), entre otros. Encontrar\u00e1 m\u00e1s informaci\u00f3n en los\nprimeros p\u00e1rrafos de https://www.freedesktop.org/wiki/Software/systemd/inhibit/\nPara que el inicio con systemctl start de un determinado servicio (o target) se produzca dentro de un target\ndeterminado -llamado-el \"a.target\" - desde el propio archivo de configuraci\u00f3n del servicio en cuesti\u00f3n hay que escribir\nlas directivas Wants = a.target, Requires = a.target y / o After = a.target (estas directivas se aseguran de llegar\nprimero al target \"a.target\" para iniciar entonces el servicio en cuesti\u00f3n). Por otra parte, tambi\u00e9n existe la directiva\nConflicts = a.target , la que se asegura de no estar en el target \"a.target\" para poder iniciar el servicio en cuesti\u00f3n.\nEn el caso de querer iniciar siempre un servicio determinado autom\u00e1ticamente en el target \"a.target\", entonces\nhabr\u00e1 que escribir adem\u00e1s las directivas WantedBy = a.target o RequiredBy = a.target del archivo de configuraci\u00f3n del\nservicio (en este \u00faltimo caso, al hacer systemctl enable nomServei se crea un enlace a su archivo de configuraci\u00f3n\ndentro de \"/lib/systemd/system/a.target.wants\").\nLos archivos de configuraci\u00f3n de los targets s\u00f3lo tienen secciones [Unido] (y muy pocas la secci\u00f3n\n[Install]). En este sentido, es interesante consultar los archivos correspondientes, por ejemplo, a multi-user.target\no graphical.target: s\u00f3lo encontramos las directivas Description, Documentation, Wants, Requires, After,\nConflicts y AllowIsolate (ya partir de ellas podemos deducir las dependencias que hay entre targets ... aunque\npor eso hay pedidos espec\u00edficos que enseguida veremos).\nEJERCICIOS:\n1.- Crear un target nuevo llamado \"manolo.target\" donde el sistema deber\u00e1 entrar justo despu\u00e9s de activar\ngraphical.target (es decir, debe ser el \u00faltimo target al activarse). La idea ser\u00e1 asegurarte de que entras en\neste target para ejecutar un determinado servicio (lo llamaremos \"manolo.service\") el \u00faltimo de todos. para hacer\nesto, tienes que hacer lo siguiente:\na) Crear un nuevo fichero llamado \"/etc/systemd/system/manolo.target\" con el siguiente contenido:\n[Unido]\nDescription = Manolo is kind\nDocumentation = http: //www.lecturas.com\nRequires = graphical.target\nAfter = graphical.target\nConflicts = rescue.service rescue.target\nAllowIsolate = yes\nb) Crear un nuevo fichero llamado \"/etc/systemd/system/manolo.service\" con el siguiente contenido:\n[Unido]\nDescription = Manolo is soberbio\nPage 17\nDocumentation = http: //www.hola.com\nRequires = manolo.target\nAfter = manolo.target\n[Service]\nExecStart = / usr / bin / printf \"MANOLO \\ n\"\nRemainAfterExit = yes\n[Install]\nWantedBy = manolo.target\nc) Ejecutar systemctl enable manolo.service y reinicia la m\u00e1quina. \u00bfCrees que el servicio \"manolo\" estar\u00e1\nfuncionando autom\u00e1ticamente o no? \u00bfPor qu\u00e9 lo crees? Compru\u00e9balo ejecutando el pedido systemctl status\nmanolo.service (o tambi\u00e9n observando si aparece la palabra \"MANOLO\" en el Journal). PISTA: La respuesta de\nporque el servicio \"manolo\" estar\u00e1 funcionando (o no) se encuentra en el que muestra el pedido systemctl list-unidos -\nt target | grep \"manolo\" y en entender el significado de la l\u00ednea WantedBy =\nd ) A continuaci\u00f3n ejecuta systemctl start manolo.service . Despu\u00e9s de observar que el servicio se haya puesto en marcha\ncorrectamente (en la salida del pedido systemctl status manolo.service o tambi\u00e9n observando si aparece la\npalabra \"MANOLO\" en el Journal), \u00bfcrees que el pedido systemctl list-unidos -t target | grep \"manolo\"\nmostrar\u00e1 algo diferente respecto del apartado anterior? \u00bfPor qu\u00e9 lo crees? PISTA: La respuesta se encuentra en\nentender el significado de las l\u00edneas Requires = y After = del archivo \"manolo.service\"\ne) Ejecutar systemctl set-default manolo.target y vuelve a reiniciar la m\u00e1quina. \u00bfCrees que el servicio \"manolo\"\nahora estar\u00e1 funcionando autom\u00e1ticamente o no? \u00bfPor qu\u00e9 lo crees? Compru\u00e9balo ejecutando el pedido systemctl\nstatus manolo.service (o tambi\u00e9n observando si aparece la palabra \"MANOLO\" en el Journal). PISTA: La respuesta\nse encuentra en entender el significado de las l\u00edneas Requires = y After = del archivo \"manolo.target\"\n2.-a) Entra en el target de rescate. \u00bfQu\u00e9 pasa?\nb) Entra en el target de suspensi\u00f3n. \u00bfQu\u00e9 pasa?\nc) Entra en el target multi-user. \u00bfQu\u00e9 pasa?\nd) Crear un script ejecutable dentro de la carpeta \"/ usr / lib / systemd / system-sleep\" con el siguiente contenido ...:\n\n\n! / Bin / bash\n\uf0c1\n\n\nif [[ \"$ 1\" == \"pre\"]]\nthen\necho \"we are suspending oro hibernating at $ (date) ...\"> / tmp / systemd_suspend_test\nElif [[ \"$ 1\" == \"post\"]]\nthen\necho \"... and we are back from $ (date)\" >> / tmp / systemd_suspend_test\nfin\n... y prueba de suspender el sistema y volver a \"despertar\". \u00bfQu\u00e9 pasar\u00e1?\ne) \u00bfPara qu\u00e9 sirve este programa: https://github.com/ryran/reboot-guard ?\nPage 18\nboot chain\nPara saber la jerarqu\u00eda de dependencias de targets para llegar a iniciar un target (o service!) Determinado\nse puede utilizar el comando: systemctl list-dependencias nomTarget.target (o nomUnit.service )\nNOTA: Una forma alternativa de obtener una informaci\u00f3n similar ser\u00eda ejecutando systemctl show -p \"Wants\"\nnomTarget.target && systemctl show -p \"Requires\" nomTarget.target . Tambi\u00e9n se puede ejecutar systemctl status\nLas dependencias mostradas se corresponden a unidos que han sido \"required\" o \"wanted\" por las\nunidos superiores. Las dependencias recursivas s\u00f3lo se muestran los targets intermedios; si se quieren ver\ntambi\u00e9n por los service, mounts paths, socket, etc intermedios hay que incluir el par\u00e1metro --all al pedido\nanterior.\nTambi\u00e9n se pueden mostrar cu\u00e1les unidos dependen para funcionar del correcto inicio de un target (o service!)\ndeterminado con el pedido: systemctl list-dependencias --reverse nomTarget.target (o nomUnit.service )\nNOTA: Una forma alternativa de obtener una informaci\u00f3n similar ser\u00eda ejecutando systemctl show -p \"WantedBy\"\nnomTarget.target && systemctl show -p \"RequiredBy\" nomTarget.target\nOtros par\u00e1metros interesantes de este comando son --before y - after , los cuales sirven para\nmostrar unidos que dependen para funcionar del correcto inicio anterior o posterior de un target, respectivamente.\nPor otra parte, respecto al arranque del sistema podemos obtener una informaci\u00f3n m\u00e1s detallada sobre los\ntiempo que tarda cada unido en cargarse y el orden en que lo hace gracias al pedido systemd-analyze , lo\ntiene varias posibilidades\nsystemd-analyze : Muestra el tiempo total empleado en el arranque del sistema y qu\u00e9 parte de este tiempo ha sido\nempleado en tareas del kernel, qu\u00e9 parte en uso de initrd y qu\u00e9 parte en tareas de usuario\nsystemd-analyze blame : Muestra los tiempos disgregados por servicio. Hay que indicar que estos tiempos son \"en\nparalelo \", as\u00ed que la suma total que sale ser\u00e1 siempre muy superior al tiempo real empleado en\nel arranque.\nsystemd-analyze dote [nomTarget.target] | dot -T {png | svg} -o foto. {png | svg} : Genera una salida que\nsi se pasa a la aplicaci\u00f3n \"dot\" (perteneciente al paquete \"GraphViz\") generar\u00e1 finalmente un gr\u00e1fico\n(En formato png o svg) donde se pueden visualizar todas las dependencias del target (o servicio!)\nindicado (o, si no se indica, del \"default.target\"; tambi\u00e9n se pueden indicar comodines en el nombre del\ntarget / servicio).\nsystemd-analyze plot [nomTarget.target]> something.svg : Genera un gr\u00e1fico donde se muestra los tiempos\nde ejecuci\u00f3n y de bloqueo de cada unido durante el arranque hasta llegar al target (o servicio!)\nindicado (o, si no se indica, del \"default.target\")\nsystemd-analyze critical-chain [nomTarget.target] : Muestra el \u00e1rbol de dependencias bloqueantes por target (o\nservicio!) indicado. El tiempo mostrado despu\u00e9s de \"@\" indica el tiempo que hace que la unido est\u00e1 activa; el tiempo\nmostrado despu\u00e9s de \"+\" indica el tiempo que la unido ha tardado en activarse.\nOtras opciones del pedido systemd-analyze son syscall-filter, verify, dump, log-level, security, time ...\nSe puede ver si, una vez iniciado el sistema, a\u00fan quedan tareas pertenecientes al arranque para completar\nejecutando el pedido systemctl list-jobs\nPage 19\nEJERCICIOS:\n1.- a) \u00bfQu\u00e9 targets deben haberse iniciado para que el servicio gdm se pueda poner en marcha? (esto lo puedes\nsaber con el pedido s ystemctl list-dependencias ... )\nb) Ejecutar el pedido systemctl list-dependencias --reverse gdm.service Qu\u00e9 ves?\nc) \u00bfQu\u00e9 hace el pedido tree / etc / systemd / system y para qu\u00e9 podr\u00eda servirte?\n2.-a) Ejecutar systemd-analyze plot ... y observa qu\u00e9 unido bloquea m\u00e1s tiempo el arranque de tu sistema. prueba\nde desactivarla (esperemos no romper nada!) y reinicia. Ejecuta ahora systemd-analyze blame para comprobar si el\ntiempo total de arranque ha disminuido efectivamente.\nb) Instal.la el paquete \"GraphViz\" y genera un gr\u00e1fico Png con las dependencias del target multi-user. Haz una\nlista de las dependencias all\u00ed mostradas y adjunta la captura del gr\u00e1fico\nplantillas\nUna plantilla es un archivo de configuraci\u00f3n de tipo \"service\" que tiene la particularidad de permitir poner\nen marcha variantes de un mismo servicio sin tener que escribir un archivo \"service\" diferente para cada variante.\nB\u00e1sicamente, para utilizar una plantilla hay que hacer los siguientes pasos:\n1.- El archivo \"service\" que har\u00e1 de plantilla debe llamarse \"nomServei @ .service\". Es decir, hay que indicar\nel s\u00edmbolo arroba antes del punto\n2.- El contenido de este archivo plantilla puede ser exactamente igual que el de un archivo \"service\" est\u00e1ndar\n3.- A la hora de iniciar, parar, activar, desactivar, ver el estado, etc de una plantilla, se deber\u00e1 indicar\nel identificador concreto de la variante con la que queremos trabajar. Este identificador se establece la\nprimera vez que arranca la variante y simplemente consiste en una cadena entre la arroba y el punto,\nas\u00ed: systemctl start nomServei @ identificador. service A partir de aqu\u00ed, este identificador se har\u00e1\nservir de la misma manera por el resto de tareas relacionadas con la gesti\u00f3n de esta variante\nNOTA: An instance file is usually created as a symbolic link to the template file, with the link name including the instance\nidentifier. In this way, multiple links with unique Identifiers can point back to a single template file. When managing a\u00f1o\ninstance unido, systemd will look for a file with the exact instance name you Specify on the command line to use but if it\ncan not find one, it will look for an associated template file.\n4.- La gracia de las plantillas es que el valor del identificador indicado en el punto anterior se puede utilizar\ndin\u00e1micamente dentro del contenido del archivo plantilla (concretamente mediante el s\u00edmbolo \" % y \"), de\nlo que seg\u00fan el valor que haya adquirido% y por esa variante se podr\u00eda poner en marcha el\nservicio escuchando en un puerto diferente (si% y representa un n\u00famero de puerto), o bien utilizando un archivo de\nconfiguraci\u00f3n diferente (si% y representa un nombre de archivo), o lo que nos convenga.\nNOTA: Otros s\u00edmbolos especiales que se pueden indicar en un archivo de configuraci\u00f3n de una plantilla pueden ser\n% p : representa the unido name prefijo (this is the Portion of the unido name that comes before the @ symbol)\n% n : representa the full resulting unido name (% p plus% e)\n% u : The name of the user configured to run the unido.\n% U : The same as above, but as a numeric UID instead of name.\n% H : The host name of the system that is running the unido.\n%% : This is used to insert a literal percentage sign.\nPage 20\nPongamos un ejemplo. Imaginemos que tenemos un determinado servidor web que queremos ejecutar con dos\nconfiguraciones diferentes a la vez. La soluci\u00f3n ser\u00eda crear un archivo plantilla llamado por ejemplo\n\"Servidorweb @ .service\" con un contenido similar al siguiente:\n[Unido]\nDescription = My HTTP server\n[Service]\nType = simple\nExecStart = / usr / sbin / WebServer --config-file /etc/%i.conf\n[Install]\nWantedBy = multi-user.target\nCon este archivo, se podr\u00eda iniciar entonces el servidor dos veces, cada una indicando el nombre del archivo de\nconfiguraci\u00f3n deseado, as\u00ed:\nsudo systemctl start servidorweb@config1.service\nsudo systemctl start servidorweb@config2.service\nLos pedidos anteriores lo que har\u00e1n ser\u00e1 ejecutar, respectivamente, los pedidos: / usr / sbin / WebServer -\nconfig-file /etc/config1.conf y / usr / sbin / WebServer -config-file /etc/config2.conf\nEJERCICIOS:\n1.-a) Crear un archivo plantilla que permita poner en marcha diferentes servidores Ncat de forma permanente\n(Recuerda el par\u00e1metro -k) escuchando cada uno de ellos en un puerto diferente.\nNOTA: Deber\u00e1s instalar el paquete \"nmap\" para disponer del pedido ncat\nb) Iniciar un servidor Ncat a partir de la plantilla anterior escuchando en el puerto 2.222 y otro escuchando en el puerto\n3333. Comprueba que, efectivamente, estos dos puertos est\u00e9n abiertos observando la salida del pedido ss\n-tnl\nc) Conecta con el cliente Ncat a uno de los servidores anteriores y env\u00edale alg\u00fan mensaje. Cerrar el cliente (con\nCTRL + C) y ahora vuelve a ejecutarlo para conectar al otro servidor; vuelve a enviarle alg\u00fan otro mensaje y\nci\u00e9rralo de nuevo. Observa las \u00faltimas l\u00edneas del Journal: \u00bfqu\u00e9 ves?\n2.- Lee el siguiente p\u00e1rrafo y seguidamente contesta:\nWhen the user switches consolas using Ctrl + Alt + F2, Ctrl + Alt + F3, and so on, a new terminal then is spawned. in this\ncase systemd callos a service named getty @ .service providing the appropriate argumento such as tty2 oro tty3 to the unido\nfile. The% y identifier provides this argumento value to the agetty binary sonido the terminal starts on that new console (as it\ncan seen in ExecStart = line from template file).\na) Para qu\u00e9 sirve el pedido agetty? Busca en su p\u00e1gina del manual que hace su par\u00e1metro -ay\na\u00f1\u00e1delo a la invocaci\u00f3n del pedido escrita a la l\u00ednea ExecStart de dentro del archivo getty @ .service (recuerda\nde ejecutar sudo systemctl daemon-reload justo despu\u00e9s). \u00bfQu\u00e9 pasa ahora cuando pulses Ctrl + Alt + F2, etc?\nb) enmascarado la instancia tty5 de la plantilla getty @ .service. \u00bfQu\u00e9 pasa ahora si haces Ctrl + Alt + F5?\nNOTA: Es posible que tambi\u00e9n hayas de enmascarar la plantilla autovt @ .service para que funcione el ejercicio\nNOTA: Hay otras maneras m\u00e1s sofisticadas de desactivar terminales virtuales pero las veremos m\u00e1s adelante\nc) \u00bfQu\u00e9 te muestra el pedido systemctl status getty @ * ?\nPage 21\n3.- Supone que tienes un archivo llamado \"/etc/systemd/system/pepe@.service\" con el siguiente contenido:\n[Unido]\nDescription = lerele\n[Service]\nType = oneshot\nExecStart = / usr / local / bin / systemd-email% y admin@elpuig.xeill.net\nUser = nobody\nGroup = systemd-journal\ndonde \"systemd-email\" es un bash shell script escrito por nosotros dise\u00f1ado para enviar correos (suponiendo que\ntenemos un servidor Postfix o similar configurado en la m\u00e1quina) que tiene el siguiente c\u00f3digo:\n\n\n! / Bin / bash\n\uf0c1\n\n\nsystemctl status -full \"$ 1\" | mail -s \"$ 1\" $ 2\ny supone que has a\u00f1adido la l\u00ednea OnFailure=pepe@%i.service en la secci\u00f3n [Unido] del archivo \".service\"\ncorrespondiente al / los servicio / s que quiere monitorear.\na) \u00bfCu\u00e1l pedido deber\u00edas ejecutar para poner en marcha una instancia del servicio-plantilla pepe @ que\nse encargan de enviar mails en el momento que el servicio Cups falle?\nsockets\nUn aspecto muy interesante de systemd es que permite que un servidor no est\u00e9 permanentemente\nencendido sino que s\u00f3lo arranque \"bajo demanda\" (es decir, cuando detecte una conexi\u00f3n, normalmente externa).\nDe este modo, este servidor no consume m\u00e1s recursos que los m\u00ednimos imprescindibles, en el momento\njusto. Para lograr esto, lo que pasa es que s\u00ed hay un componente \"escuchando\" todo el rato posibles\nintentos de conexiones, pero este componente no es la unido \"service\" en s\u00ed sino un \"perro guardi\u00e1n\" que\ns\u00f3lo despertar\u00e1 unido \"service\" cuando sea necesario. Este \"perro guardi\u00e1n\" es la unido de tipo \"socket\".\nCada archivo de configuraci\u00f3n de una unido \"socket\" debe tener exactamente el mismo nombre que el archivo de\nconfiguraci\u00f3n de la unido \"service\" que quiere despertar (es decir, si tenemos el servicio \"a.service\", el socket\ncorrespondiente deber\u00e1 llamarse \"a.socket\"). La idea es tener la unido \"socket\" siempre encendido ( systemctl\nenable a.socket ) pero la unido \"service\" no ( systemctl disable a.service ); cuando se detecte una conexi\u00f3n, el\n\"socket\" autom\u00e1ticamente encender\u00e1 la unido \"service\" (esto se puede ver haciendo systemctl status a.service mientras\nexiste la conexi\u00f3n) y la apagar\u00e1 de nuevo pasado un determinado tiempo sin actividad (por defecto 5 minutos).\nObviamente, si par\u00e1ramos el \"socket\" ( systemctl stop a.socket ) o el deshabilit\u00e9ssim el pr\u00f3ximo reinicio ( systemctl\ndisable a.socket ) ya no habr\u00eda \"perro guardi\u00e1n\" atento y, por tanto, el servicio ya no se pondr\u00eda en marcha\nautom\u00e1ticamente.\nPara cambiar el puerto donde escucha un \"socket\" (entre otras cosas) hay que modificar la configuraci\u00f3n del\n\"Socket\" propiamente dicho y eso no depende de la configuraci\u00f3n del servidor en cuesti\u00f3n. Los archivos de configuraci\u00f3n\nde cada \"socket\" se pueden encontrar, como cualquier otra unido, o bien dentro de la carpeta \"/ usr / lib / systemd / system\"\no bien dentro de \"/ etc / systemd / system\" y se puede utilizar igualmente el pedido systemctl edit a.socket para\ngenerar archivos \"override\". La secci\u00f3n que nos interesa en estos tipos de ficheros es la secci\u00f3n [Socket] , lo\npuede contener alguna de las siguientes directivas m\u00e1s importantes:\nListenStream = [IP:] n\u00baport\nIndica el n\u00famero de puerto TCP por donde escuchar\u00e1 el socket. Opcionalmente, se puede indicar una IP\nconcreta para especificar que s\u00f3lo escuchar\u00e1 en el puerto ofrecido por aquella IP y ninguna m\u00e1s.\nNOTA: Se pueden indicar varias l\u00edneas ListemStream para hacer que el socket escuche en varios puertos a la vez. Por otra parte,\ncomo que esta l\u00ednea puede estar escrita en diferentes archivos, si se quiere asegurar que s\u00f3lo se escuche en un puerto concreto sin\ntener en cuenta otras l\u00edneas que pueda haber le\u00eddo systemd previamente, se puede a\u00f1adir primero una l\u00ednea ListemStream vac\u00eda\n(as\u00ed: ListemStream = ) y luego la l\u00ednea ListenStream asociada al puerto deseado; lo que hace la l\u00ednea ListemStream vac\u00eda es\n\"resetear\" todas las l\u00edneas ListemStream anteriores\nPage 22\nListenDatagram = [IP:] n\u00baport\nIndica el n\u00famero de puerto UDP por donde escuchar\u00e1 el socket. Opcionalmente, se puede indicar una IP\nconcreta para especificar que s\u00f3lo escuchar\u00e1 en el puerto ofrecido por aquella IP y ninguna m\u00e1s.\nListenSequentialPacket = / ruta / arxiu.socket\nIndica el socket de tipo UNIX por donde se escuchar\u00e1. S\u00f3lo sirve para comunicaciones entre\nprocesos de la misma m\u00e1quina\nService = unNomAlternatiu\nSi el nombre del archivo \"service\" no es igual que el nombre del archivo \"socket\", aqu\u00ed se puede indicar\nentonces el nombre que tiene el archivo \"service\" para que el socket el sepa encontrar.\nAccept = yes\nSi se indica, hace que se genere una instancia del servicio diferente para cada conexi\u00f3n. \u00datil cuando se\nutilizan plantillas. Si su valor es no (por defecto) s\u00f3lo una instancia del servicio\ngestionar\u00e1 todas las conexiones.\nEl pedido systemctl status * .socket nos permite saber cu\u00e1ntos y cu\u00e1les sockets est\u00e1n escuchando ahora\nmismo; el valor \"Accepted\" muestra cu\u00e1ntas conexiones se han realizado en total desde que el socket ha sido\niniciado y el valor \"Connected\" muestra cu\u00e1ntas conexiones est\u00e1n actualmente activas\nComo cualquier otra unido, se pueden ver la lista de sockets con el pedido s ystemctl list-unidos -t\nsocket pero adem\u00e1s disponemos del pedido espec\u00edfica systemctl list-sockets , la cual informa de qu\u00e9 servicio\ncorrespondiente activan y en qu\u00e9 puerto / socket UNIX escuchan.\nEJERCICIOS:\n1.-a) Crea el fichero \"/etc/systemd/system/dateserver.socket\" con el siguiente contenido:\n[Unido]\nDescription = Servicio de fecha en el puerto 55555\n[Socket]\nListenStream = 55555\nAccept = true\n[Install]\nWantedBy = sockets.target\nb) Crear el fichero \"/etc/systemd/system/dateserver@.service\" con el siguiente contenido:\n[Unido]\nDescription = Servicio de fecha\n[Service]\nType = simple\nExecStart = / opt / dateserver.sh\nStandardOutput = socket\nStandardError = journal\nc) Crear el fichero \"/opt/dateserver.sh\" con el siguiente contenido (y dale permisos de ejecuci\u00f3n!):\n\n\n! / Bin / bash\n\uf0c1\n\n\nwhile [[true]]\ndo\nPage 23\n\n\nAtenci\u00f3n: comprueba que date se encuentre dentro de / usr / bin; dependiendo de la distribuci\u00f3n eso cambia\n\uf0c1\n\n\n/ Usr / bin / date\nsleep 1\nd\u00e9\nd) Abre un terminal y ejecuta el comando nc ipServidor 55555 . \u00bfQu\u00e9 ves? Abre otro terminal diferente y\nejecuta el mismo pedido. \u00bfQu\u00e9 ves? \u00bfQu\u00e9 te muestra el pedido systemctl status dateserver.socket ? \u00bfY la\npedido systemctl status dateserver @ * ? \u00bfY el pedido systemctl list-unidos dateserver @ * ?\n2.- Haz que el servidor SSH que tengas instal.lat a la m\u00e1quina (si no lo tienes, instal.la'l) inicie s\u00f3lo a trav\u00e9s\nde un socket. concretamente:\na) Crear el fichero \"/etc/systemd/system/sshMitjo.socket\" con el siguiente contenido:\n[Unido]\nDescription = Mi SSH Socket\n[Socket]\nListenStream = 22\nAccept = yes\n[Install]\nWantedBy = sockets.target\nb) Crear el fichero \"/etc/systemd/system/sshMitjo@.service\" con el siguiente contenido:\n[Unido]\nDescription = Mi SSH Server\n[Service]\nType = simple\nExecStart = - / usr / sbin / sshd -y\nStandardInput = socket\nStandardOutput = socket\nNOTA: Aqu\u00ed la clave est\u00e1 en la combinaci\u00f3n del par\u00e1metro -y del binario sshd (el cual hace que habilitar la posibilidad de que pueda recibir\npeticiones a trav\u00e9s de sockets), y la directiva StandardInput (lo realiza de forma efectiva este tipo de comunicaci\u00f3n entre el\nsocket y el servidor SSH)\nNOTA: Importante is the \"-\" in front of the binary name. This ENSUR that the exit status of the para-connection sshd process is\nforgotten by systemd. Normally, systemd will store the exit status of a all service instances that die abnormally. SSH will sometimes\ndie abnormally with an exit code of 1 oro similar, and we want to make sure that this does not cause systemd to keep around\ninformation for numerous previous connections that died this way (until this information is forgotten with systemctl reset-failed).\nc) Ejecutar el pedido systemctl enable sshMitjo.socket y systemctl disable ssh.service (si fuera necesario) y reinicia\nla m\u00e1quina. Una vez hecho, comprueba que el socket sshMitjo est\u00e9 funcionando pero no el servicio sshMitjo.\nEjecuta ssh usuario @ ipServidor para entrar en el servidor SSH (deber\u00edas de conseguir sin problemas) y\ncomprueba seguidamente que ahora s\u00ed est\u00e1 funcionando una instancia del servicio sshMitjo\nd) \u00bfQu\u00e9 har\u00eda un pedido como systemctl killsshd@172.31.0.52 : 22-172.31.0.4: 47779.service?\nPage 24\n3.-a) En el ejercicio anterior hemos tenido la suerte de que el servidor SSH ofrece un par\u00e1metro (-y) que le permite\ndelegar la apertura de los sockets (puertos) a un \"agente externo\" como es systemd. Pero no siempre tendremos un\nservidor que ofrezca esta posibilidad. En este sentido, lee los siguientes p\u00e1rrafos y resumen con las\ntus propias palabras que explica:\nOne of the limitations of socket activaci\u00f3n is that it requires the activated application to be aware that it may be socket-activated; the\nprocess of accepting an existing socket is different from creating a listening socket from scratch. Consequently a lot of widely used\napplications do not support it. The systemd developers have known that it may take some time to get activaci\u00f3n apoyo everywhere, sonido\nthey Introduced \"systemd-socket-proxyd\", a small TCP and Unix domain socket proxy server. This does understand activaci\u00f3n, and\nwill sit between the network and our server, transparently forwarding packets between the two. The steps to use this tool are:\nStep 1: We create a socket that Listener on the puerto that will eventually be served by the proxy / server combination.\nStep 2: On the first connection to the socket systemd activados the proxy service and hands it the socket.\nStep 3: When the proxy is started the corresponding server is first Broughten up (thanks to the Requires / After dependency)\nThe proxy then shuttles all traffic between the server and the network. The only trick here is that we need to bind the server to a puerto\nother than the real-target puerto (8080 instead of 80 if we are running a webserver, for instance). This is because that puerto will be\nowned by the socket / proxy, and you can not bind two processes to the same socket and interface.\nStep 1: \"myserver-proxy.socket\" file\n[Socket]\nListenStream = 0.0.0.0: 80\n[Install]\nWantedBy = sockets.target\nStep 2: \"myserver-proxy.service\" file\n[Unido]\nRequires = myserver.service\nAfter = myserver.service\n[Service]\nExecStart = / usr / lib / systemd / systemd-socket-proxyd 127.0.0.1:8080\nStep 3: \"myserver.service\" file\n[Unido]\nDescription = Server example (replace ExecStart value with something more realistic)\n[Service]\n\n\nWe listening server s listening puerto only to loopback interface because it 's there where input packages comas from proxy\n\uf0c1\n\n\nExecStart = / usr / bin / ncat -k -l 127.0.0.1 8080",
            "title": "Systemd"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#systemd-i",
            "text": "",
            "title": "Systemd (I)"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#introduccion",
            "text": "Systemd es varias cosas:   El proceso Init (PID 1) del sistema  El gestor de demonios  Un intermediario entre aplicaciones de usuario y ciertas partes de la API del kernel de Linux   La configuraci\u00f3n general de systemd se encuentra en el archivo  /etc/systemd/system.conf ; muchos valores por defecto est\u00e1n all\u00ed establecidos.  Para saber la versi\u00f3n actual de systemd que hay funcionando el sistema, hacer  systemctl --version",
            "title": "Introducci\u00f3n"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#units-tipos-y-ubicacion",
            "text": "Todo lo que es gestionado por systemd se llama \"unit\" y cada \"unit\" es descrita por un archivo de configuraci\u00f3n propio, el cual tendr\u00e1 una extensi\u00f3n diferente seg\u00fan el tipo de de unidad que se trate:   .service : Describe la configuraci\u00f3n de un demonio  .socket : Describe la configuraci\u00f3n de un socket (de tipo UNIX o TCP / IP) asociado a un .service  .device : Describe un dispositivo hardware reconocido por el kernel (v\u00eda udev o sysfs) gestionado por systemd  .mount : Describe un punto de montaje gestionado por systemd  .automount : Describe un punto de automontaje asociado a un .mount  .swap : Describe una partici\u00f3n o archivo de intercambio gestionado por systemd  .target : Define un grupo de Units (se utiliza a modo de \"metapaquete\" de Units)  .path : Describe una carpeta o archivo monitorizado por la API Inotify del kernel  .timer : Describe la temporizaci\u00f3n / activaci\u00f3n de una tarea programada (usando el programador systemd)  .slice : Define un grupo de Units asociadas a procesos para administrar y limitar los recursos comunes (CPU, memoria, discos, red). Usa internamente los llamados \"cgroups\" del kernel   Los archivos de configuraci\u00f3n de las Units (sean del tipo que sean) pueden estar repartidos en tres carpetas distintas:   /usr/lib/systemd/system : Para Units proporcionadas por los paquetes instalados en el sistema  /run/systemd/system : Para Units generadas en tiempo real durante la ejecuci\u00f3n del sistema. no persistentes  /etc/systemd/system : Para Units proporcionadas por el administrador del sistema   Los archivos en  /etc/...   sobreescriben  los archivos  hom\u00f3nimos  que est\u00e9n en  /run/...  los cuales sobreescriben los que est\u00e9n en  /usr/lib/...  (o en algunas distribuciones,  /lib/... ). Si no tienen el mismo nombre, todos los archivos de las tres carpetas se mezclan ordenados por su nombre de forma numericoalfab\u00e8tica y se van leyendo en este orden hasta el final.  Por otra parte, si dentro de  /usr/lib/... ,  /run/...  o  /etc/...  hay una carpeta llamada como una unit seguido del sufijo \".d\", cualquier archivo con extensi\u00f3n * .conf que haya en su interior ser\u00e1 le\u00eddo justo despu\u00e9s de los ficheros de configuraci\u00f3n de la unit pertinente. Esto sirve para poder a\u00f1adir (o sobreescribir) opciones de configuraci\u00f3n concretas (las presentes en estos archivos) sin tener que tocar las configuraciones \"gen\u00e9ricas\" de la unit. por\nejemplo: el archivo  /usr/lib/systemd/system/beep.service.d/foo.conf  puede ser \u00fatil para modificar la configuraci\u00f3n definida en  /usr/lib/systemd/systemd/beep.service  (y de este modo, hacer posible que un paquete pueda cambiar la configuraci\u00f3n establecida por otro) y el archivo  /etc/systemd/system/beep.service.d/foo.conf  puede ser \u00fatil para modificar la configuraci\u00f3n definida en  /usr/lib/systemd/system/beep.service  (y de este modo, hacer\nposible que un administrador pueda cambiar ciertas partes de la configuraci\u00f3n de la unit preempaquetada al sistema sin tener que reemplazar completamente). Estos archivos \"override\" (concretamente con el nombre  /etc/systemd/system/nomUnit.d/override.conf ) se pueden generar de una manera muy c\u00f3moda y r\u00e1pida con la orden  systemctl edit nomUnit  Algunas \"units\" contienen un s\u00edmbolo @ en su nombre (por ejemplo, nom@cadena.service); esto significa que son instancias de una unit-plantilla, el archivo de configuraci\u00f3n de la cual es el que no contiene la parte\n\"Cadena\" en su nombre (as\u00ed: nombre @.service). La parte \"cadena\" es el identificador de la instancia (de hecho, dentro del archivo de configuraci\u00f3n de la unit-plantilla el valor \"cadena\" sustituye todas las ocurrencias del especificador especial %i).",
            "title": "\"Units\": tipos y ubicaci\u00f3n"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#comandos-para-gestionar-units-principalmente-de-tipo-service",
            "text": "A continuaci\u00f3n mostramos algunos de los comandos m\u00e1s importantes para gestionar Units principalmente (No exclusivamente) de tipo \"service\":  systemctl [list-Units] [-t {service | socket | ...}] [--all | --failed | --state = inactive]    Muestra el estado de las Units que est\u00e1n \"activas\" (del tipo indicado, si no se indica, aparecen todas).    Si se escribe --state = inactive se muestra el estado de las Units que est\u00e1n \"inactivas\"   Como valor del par\u00e1metro  --state  tambi\u00e9n se puede poner cualquier valor v\u00e1lido de la columna SUB  Si se escribe  --failed  se muestra el estado de todas las Units con errores   Si se escribe --all se muestra el estado de todas las Units ( \"activas\", \"inactivas\", con errores y otros)\n-La diferencia entre las columnas LOAD, ACTIVE y SUB la dice la salida de la propia pedido:    LOAD  = Indica si la unido ha sido cargada en RAM. Posibles valores: \"loaded\", \"error\", \"Masked\"    ACTIVE  = Estado gen\u00e9rico de la unit. Posibles valores: \"active\", \"inactive\", \"failed\", \"(des) activating\"    SUB  = Estado m\u00e1s concreto de la unit, depende del tipo de unit, posibles valores \"plugged\", \"mounted\", \"running\", \"exited\", \"waiting\", \"listening\", etc      systemctl [-t {service | socket | ...}] list-unit-files  El comando  list-units  s\u00f3lo muestra las units que systemd ha intentado leer y cargar en memoria. Ya que systemd s\u00f3lo lee las units que \u00e9l piensa que necesita, as\u00ed no incluye necesariamente todas las units disponibles en el  sistema. Para ver todas las units, incluyendo aquellas que systemd no ha intentando ni siquiera cargar, hay que utilizar list-unit-files. Este subcomando muestra el \"estado de carga\" de cada unit;posibles valores son:    \"enabled\" o \"enabled-runtime\" : La unit se activar\u00e1 en el siguiente reinicio -y subsiguientes-.   NOTA  Esto se consigue gracias a la existencia de un enlace al archivo de configuraci\u00f3n de la unit en cuesti\u00f3n dentro de la carpeta  /etc/systemd/system/nomTarget.target.wants , creado en alg\u00fan momento previo con el comando systemctl enable (ver m\u00e1s abajo) o de forma manual con ln -s     \"static \": La unit no tiene secci\u00f3n \"[Install]\" en su archivo de configuraci\u00f3n. Esto hace que los comandos systemctl enable (y sobre todo systemctl disable ) no funcionen. Por tanto, el hecho de que la unit est\u00e9\nactivada o no en un determinado \"target\" depender\u00e1 de la existencia \"est\u00e1tica\" de su enlace correspondiente dentro de la carpeta  /etc/systemd/system/nomTarget.target.wants . Este tipo de units suelen estar asociadas a las que realizan una acci\u00f3n \"oneshot\" o bien a las que son usadas s\u00f3lo como\ndependencia de alguna otra unit (y por tanto no deben ejecutarse por s\u00ed mismas)    \"generated\": La unit se activar\u00e1 mediante un mecanismo autom\u00e1tico especial llamado \"generator\", ejecutado al arrancar el sistema. Cada unit en este estado tiene su propio \"generator\".    \"transient\" : La unit es temporal y no sobrevivir\u00e1 al siguiente reinicio    \"disabled \": La unit est\u00e1 desactivada y, por tanto, no se pondr\u00e1 en marcha en los siguientes reinicios (gracias a la inexistencia del enlace correspondiente dentro de  /etc/systemd/system/nomTarget.target.wants ).\nTampoco podr\u00e1 ser iniciada autom\u00e1ticamente mediante otros sistemas (como v\u00eda socket, v\u00eda D-Bus o bien v\u00eda conexi\u00f3n de hardware. No obstante, podr\u00e1 ser puesta en marcha en cualquier momento \"manualmente\" ejecutando systemctl start ( ver m\u00e1s abajo)    \"Masked\" o \"Masked-runtime \": La unido est\u00e1 Enmascarado (es decir, est\u00e1 desactivada y, por tanto, no se\npondr\u00e1 en marcha los siguientes reinicios ni autom\u00e1ticamente, pero adem\u00e1s, tampoco podr\u00e1 ser puesta nunca\nen marcha manualmente con systemctl start ni siquiera si es una dependencia de otro servicio)\nsystemctl {start | stop | restart} nomUnit [.service]\nActiva / Desactiva / Reiniciar la unido indicada inmediatamente siguiendo las indicaciones escritas a su\narchivo de configuraci\u00f3n correspondiente.\nNOTA: Si la unido no fuera de tipo \".service\", entonces habr\u00e1 que indicar su tipo expl\u00edcitamente \u00faltima su nombre (por\nejemplo, systemctl start nomUnit.socket ). Esta norma es extensiva para el resto de pedidos\nsystemctl {enable | disable} nomUnit [.service]\nActivar\u00e1 / desactivar\u00e1 autom\u00e1ticamente la unido indicada a partir del siguiente reinicio (y siguientes)\nNOTA: En realidad lo que hace enable / disable es crear / eliminar un enlace dentro de la carpeta\n\"/ etc / systemd / systemd / nomTarget .target.wants\" en el archivo de configuraci\u00f3n de la unido en cuesti\u00f3n (donde \"nomTarget\" viene definido en\nla directiva WantedBy de la secci\u00f3n \"[Install]\" de dicho archivo).\nsystemctl {mask | unmask} nomUnit [.service]\nEnmascara / desenmascarar la unido indicada.\nNOTA: Esto lo consigue vinculando el archivo de configuraci\u00f3n ubicado en / etc / ... de la unido en cuesti\u00f3n a / dev / null\nsystemctl is-enabled nomUnit [.service]\nDevuelve $? = 0 si la unido indicada est\u00e1 configurada para activarse en los siguientes reinicios (es decir, si\nest\u00e1 en los estados -Listados para systemctl list-unido-files -: \"enabled\", \"enabled-runtime\", \"static\",\n\"Generated\" o \"transient\") y adem\u00e1s, muestra en pantalla este estado.\nsystemctl is-active nomUnit [.service]\nDevuelve $? = 0 si la unido indicada est\u00e1 activa y, adem\u00e1s, muestra en pantalla este estado (valor listado en la\ncolumna ACTIVE de systemctl list-unidos )\nsystemctl is-failed nomUnit [.service]\nDevuelve $? = 0 si la unido indicada fall\u00f3 al intentar activarse y, adem\u00e1s, muestra en pantalla este\nestado. Si no queremos que se muestren los estados en pantalla (esto tambi\u00e9n por is-enabled y is-active ), se\npuede a\u00f1adir el par\u00e1metro -q\nNOTA: Una unido puede estar en estado \"failed\" miedo m\u00faltiples razones: para que el proceso ha terminado con un c\u00f3digo de error\ndiferente de 0, porque ha finalizado de forma anormal, porque se ha superado un timeout determinado, etc.\nsystemctl status {nomUnit [.service] | PID}\nMuestra el estado e informaci\u00f3n variada sobre la unido o proceso indicado. Si se indica una unido se puede ver ...:\nLoaded: loaded (/usr/lib/systemd/system/cups.service; enabled; vendor preset: disabled)\nActive: active (running) since Sat 2017-11-18 20:48:06 CET; 4h 2min agosto\nDocs: man: cupsd (8)\nMain PID : 745 (cupsd)\nStatus: \"Scheduler is running ...\"\nTasks: 1 (l\u00edmite: 4915)\nCGroup: /system.slice/cups.service\n\u2514\u2500745 / usr / sbin / cupsd -l\n\u00daltimas l\u00edneas de journald -u (se puede usar los par\u00e1metros hom\u00f3nimos -n n\u00ba y -o xxx)\nLos valores para la l\u00ednea \"Loaded:\" son los mismos que aparecen en la columna LOAD de list-unidos\nSeguidamente se indican los valores del estado actual y el predefinido por paquete, que ser\u00e1n uno de los\ndetallados anteriormente al hablar de list-unido-filas\nLos valores para la l\u00ednea \"Active:\" son los mismos que aparecen en la columna ACTIVE de list-unidos\nEl punto ( \"\u25cf\") es blanco si la unido est\u00e1 \"inactive\"; rojo si \"failed\" o verde si \"active\"\nPage 4\nSi se indica un PID en vez de una unido, se puede ver la misma informaci\u00f3n, pero esta manera\npuede ser \u00fatil para conocer la unido a la que est\u00e1 asociado un determinado proceso, por ejemplo (aunque\npara conocer esta informaci\u00f3n tambi\u00e9n se podr\u00edan observar los valores de la columna \"unido\" mostrada\npara el pedido ps si as\u00ed se indica con el par\u00e1metro -o ):\ncups.service - CUPS Scheduler\nLoaded: loaded ( /usr/lib/systemd/system/cups.service ; enabled; vendor preset:\nActive: active (running) since Sat 2017-11-18 20:48:06 CET; 4h 2min agosto\nDocs: man: cupsd (8)\nMain PID: 745 (cupsd)\nStatus: \"Scheduler is running ...\"\nTasks: 1 (l\u00edmite: 4915)\nCGroup: /system.slice/cups.service\n\u2514\u2500745 / usr / sbin / cupsd -l\n\u00daltimas l\u00edneas de journald _PID = (se puede usar los par\u00e1metros hom\u00f3nimos -n n\u00ba y -o xxx)\nsystemctl show {nomUnit [.service] | PID}\nMuestra la configuraci\u00f3n actual de la unido (obtenida a partir del archivo general system.conf y del archivo\nde configuraci\u00f3n propio de la unit) indicada en un formato adecuado para ser procesado por m\u00e1quinas. con\npar\u00e1metro -p \"nomClau, unAltreNom, ...\" se pueden obtener s\u00f3lo las parejas clave <-> valor deseadas.\nsystemctl daemon-reload\nActualizar todos los archivos de configuraci\u00f3n de unidos nuevas o modificadas desde la \u00faltima vez que se\npuso en marcha systemd (incluyendo los generators).\nsystemctl help nomUnit [.service]\nAbre la p\u00e1gina man asociada a la unido indicada (en su fichero de configuraci\u00f3n debe venir indicada)\nsystemctl edit nomUnit [.service]\nCrea (con el editor de texto predeterminado del sistema) un fichero de configuraci\u00f3n (inicialmente vac\u00edo) para\nla unido indicada llamado \"/ etc / systemd / system / nomUnit. tipusUnit .d / override.conf\" para sobrescribir\n(O ampliar) la configuraci\u00f3n ya existente por ella. Una vez guardados los cambios, recarga la unido\nautom\u00e1ticamente con esta nueva configuraci\u00f3n. Si se quisiera editar directamente el archivo\n\"/ etc / systemd / system / nomUnit .tipusUnit \", hay que a\u00f1adir entonces el par\u00e1metro --full\nsystemctl cat nomUnit [.service]\nMuestra la configuraci\u00f3n final actual resultante de haber le\u00eddo los diferentes ficheros de configuraci\u00f3n\nposibles de la unido indicada\nsystemd-delta\nMuestra qu\u00e9 archivos de configuraci\u00f3n de unidos est\u00e1n sobreescritos o ampliados (de / usr / lib a / etc y / o con\narchivos \"overrides\"), enmascarados, redireccionados (con la l\u00ednea Alias \u200b\u200b= de la secci\u00f3n [Install]), etc y por\ncu\u00e1les\nsystemctl kill [--signal = n\u00ba] nomUnit [.service]\nEnv\u00eda una se\u00f1al concreta (indicada con el par\u00e1metro --signal ; por defecto es la n\u00ba15, SIGTERM) a\ntodos procesos asociados a la unido indicada.\nNOTA : kill goes directly and send a signal to every process in the group, however stop goes through the\nofficial configured way to seco down a service, ie invokes the stop command configured with ExecStop = in the service\nfile. Usually stop should be sufficient. kill is the Tougher versi\u00f3n, for casas where you either do not want the official\nshutdown command of a service to run, oro when the service is hosed and hung in other ways.\nPage 5\nSystemd tambi\u00e9n permite definir servicios para que no est\u00e9n asociados al sistema global sino que \u00fanicamente\nformen parte de la sesi\u00f3n de un usuario est\u00e1ndar, gener\u00e1ndose una instancia particular del servicio para cada usuario\nactivo en la m\u00e1quina. De este modo, cada instancia se iniciar\u00e1 autom\u00e1ticamente despu\u00e9s de iniciar la sesi\u00f3n\nde un usuario y se parar\u00e1 en salir.\nNOTA: Esto es posible gracias a que justo despu\u00e9s del primer inicio de sesi\u00f3n que se realice al sistema se pone en marcha (gracias al\nm\u00f3dulo PAM \"pam_systemd\") el pedido systemd -user ( quien es quien permitir\u00e1 este funcionamiento individual para todas las sesiones\nde usuarios que inicien a partir de entonces), adem\u00e1s del proceso con PID 1 propiamente dicho, que es systemd -system . El proceso systemd -\nuser finalizar\u00e1 autom\u00e1ticamente justo despu\u00e9s de haberse cerrado el \u00faltimo inicio de sesi\u00f3n existente al sistema.\nLos ficheros de configuraci\u00f3n de las unidos \"de tipo usuario\" se encuentran en otras carpetas de las de las unidos \"de\nsistema \". Concretamente (se muestran en orden de precedencia ascendente):\n\"/ Usr / lib / systemd / user\": Para unidos proporcionados por los paquetes instalados en el sistema\n\"~ / .Local / share / systemd / user\": Para unidos de paquetes que han sido instaladas en la carpeta personal\n\"/ Etc / systemd / user\": Para unidos proporcionados por administrador del sistema\n\"~ / .Config / systemd / user\": Para unidos construidas por el propio usuario\nNOTA: La variable especial% h se puede utilizar dentro de los archivos de configuraci\u00f3n de las unidos \"de usuario\" para indicar la ruta de la\ncarpeta personal del usuario en cuesti\u00f3n.\nOtra caracter\u00edstica de las unidos \"de usuario\" es que pueden ser gestionadas por parte de este usuario sin\nque deba ser administrador del sistema; esto lo puede hacer con las mismas pedidos systemctl ... ya\nconocidas s\u00f3lo que a\u00f1adiendo el par\u00e1metro --user As\u00ed, por ejemplo, para arrancar un servicio autom\u00e1ticamente\ncada vez que se inicie nuestra sesi\u00f3n habr\u00e1 que ejecutar systemctl --user enable nomUnit ; para ver el estado de\ntodas nuestras unidos \"de usuario\" habr\u00e1 que hacer systemctl --user list-unidos ; para recargar las unidos modificadas\nhabr\u00e1 que hacer systemctl --user daemon-reload , etc\nSecciones y directivas comunes en los ficheros de configuraci\u00f3n de las unidos\nLa estructura interna de los archivos de configuraci\u00f3n de las unidos est\u00e1 organizada en secciones, distinguidas\ncada una por un encabezamiento may\u00fasculas y min\u00fasculas rodeado de corchetes ( [Encabezamiento] ). Dentro de las\nsecciones se definen diferentes directivas (tambi\u00e9n may\u00fasculas y min\u00fasculas) en la forma de parejas\nNomDirectiva = valor , donde el valor puede ser una palabra, una frase, una ruta, un n\u00famero, t rue / yes of levante / no , una\nfecha, etc, dependiendo de su significado.\nNOTA: Tambi\u00e9n pueden existir directivas donde no se escriba ning\u00fan valor (es decir, as\u00ed: NomDirectiva = ). En este caso, se estar\u00e1\n\"Resetear\" (es decir, anulando) el valor que previamente se hubiera dado en otro sitio\nLa primera secci\u00f3n (aunque el orden no importa) siempre suele ser la llamada [Unido] y se utiliza para\ndefinir datos sobre la propia unido en s\u00ed como unido que es y la relaci\u00f3n que tiene \u00e9sta con otros unidos. algunas\nde sus directivas m\u00e1s habituales son:\nDescription = Una breve descripci\u00f3n de la unido\nSu valor es devuelto por diferente herramientas systemd\nDocumentation = man: sshd (8) https: //ruta/pag.html\nProporciona una lista de URIS que apuntan a documentaci\u00f3n de la unido.\nEl pedido systemctl status las muestra\nWants = unservei.service unaltre.service untarget.target ...\nLista las unidos que ser\u00eda bueno que estuvieran iniciadas para que el unido en cuesti\u00f3n pueda\nfuncionar correctamente. Si no lo est\u00e1n ya, systemd las iniciar\u00e1 en paralelo junto con\nel unido en cuesti\u00f3n; si se quiere indicar un cierto orden en vez de iniciar todas en paralelo, se puede\nutilizar las directivas After = o Before =. Si alguna de las unidos listadas falla al iniciarse,\nel unido en cuesti\u00f3n se iniciar\u00e1 igualmente\nPage 6\nRequires = unservei.service unaltre.service untarget.target ...\nLista las unidos que imprescindiblemente deben estar iniciadas para que el unido en cuesti\u00f3n pueda\nfuncionar correctamente. Si no lo est\u00e1n ya, systemd las iniciar\u00e1 en paralelo junto con\nel unido en cuesti\u00f3n; si se quiere indicar un cierto orden en vez de iniciar todas en paralelo, se puede\nutilizar las directivas After = o Before =. Si alguna de las unidos listadas falla al iniciarse,\nel unido en cuesti\u00f3n tambi\u00e9n fallar\u00e1 autom\u00e1ticamente\nBindsTo = unservei.service unaltre.service untarget.target ...\nSimilar a Requires = pero, adem\u00e1s, hace que el unido en cuesti\u00f3n se detenga autom\u00e1ticamente si alguna de\nlas unidos asociadas finaliza.\nBefore = unservei.service unaltre.service untarget.target ...\nIndica, de las unidos listadas en las directivas Wants = o Requires =, qu\u00e9 no se iniciar\u00e1n en\nparalelo sino tras la unido en cuesti\u00f3n. Si aqu\u00ed se indicara alguna unido que no se encontrara\nlistada en Wants = o Requires =, esta directiva no se tendr\u00e1 en cuenta.\nAfter = unservei.service unaltre.service untarget.target ...\nIndica, de las unidos listadas en las directivas Wants = o Requires =, qu\u00e9 no se iniciar\u00e1n en\nparalelo sino antes de la unido en cuesti\u00f3n. Si aqu\u00ed se indicara alguna unido que no se encontrara\nlistada en Wants = o Requires =, esta directiva no se tendr\u00e1 en cuenta.\nNOTA: El m\u00e1s t\u00edpico es tener una unido A que necesita que la unido B est\u00e9 funcionando previamente para poderse poner\nen marcha. En este caso, simplemente habr\u00eda que a\u00f1adir las l\u00edneas Requires = B y After = B en la secci\u00f3n [Unido] del unido A. Si la\ndependencia es opcional, se puede sustituir Requires = B para Wants = B\nConflicts = unservei.service unaltre.service ...\nLista las unidos que no pueden estar funcionando a la vez que el unido en cuesti\u00f3n. iniciar\nuna unido con esta directiva causar\u00e1 que las aqu\u00ed listadas detengan autom\u00e1ticamente.\nConditionXXXX = ...\nHay un conjunto de directivas que empiezan por \"Condition\" que permiten al administrador\ncomprobar ciertas condiciones antes de iniciar el unido. Si la condici\u00f3n no se cumple, la unido es\nignorada. Algunos ejemplos son:\nConditionKernelCommandLine = param [= valor]\nConditionACPower = {yes | no}\nConditionPathExists = [!] / Ruta / archivo / o / carpeta\nConditionPathExistsGlob = [!] / Ruta / archivos / o / carpetas\nConditionPathIsDirectory = [!] / Ruta / carpeta\nConditionPathIsSymbolicLink = [!] / Ruta / enlace\nConditionPathIsMountPoint = [!] / Ruta / carpeta\nConditionPathIsReadWrite = [!] / Ruta / archivo / o / carpeta\nConditionDirectoryNotEmpty = [!] / Ruta / carpeta\nConditionFileNotEmpty = [!] / Ruta / archivo\nConditionFileIsExecutable = [!] / Ruta / archivo\nAssertXXXX = ...\nAl igual que con \"ConditionXXX\", hay un conjunto de directivas que empiezan por \"Assert\"\nque permiten al administrador comprobar ciertas condiciones antes de iniciar el unido. la\ndiferencia es que aqu\u00ed, si la condici\u00f3n no se cumple, se emite un error.\nOnFailure = unaunit.service unaaltra.service ...\nIndica las unidos que se activar\u00e1n cuando la unido en cuesti\u00f3n entre en estado \"failed\". esta\ndirectiva puede utilizarse, por ejemplo, para ejecutar una unido que env\u00ede un correo electr\u00f3nico\ncuando la unido en cuesti\u00f3n, que podr\u00e1 ser un servicio, falle.\nPage 7\nAllowIsolate = yes\nEsta directiva s\u00f3lo tiene sentido para unidos de tipo target. Si su valor es \"yes\" (por\ndefecto es \"no\") indica que el target en cuesti\u00f3n admitir\u00e1 que se le aplique el pedido\nsystemctl Isolate (ver m\u00e1s abajo)\nPor otra parte, la \u00faltima secci\u00f3n (aunque el orden no importa) de un archivo de configuraci\u00f3n de una unido\nsiempre suele ser la llamada [Install] , la cual, atenci\u00f3n, es opcional. Se utiliza para definir c\u00f3mo y cuando el unido puede\nser activada o desactivada. Algunas de sus directivas m\u00e1s habituales son:\nWantedBy = untarget.target unaltre.target ...\nIndica los targets donde el unido en cuesti\u00f3n se activar\u00e1 en ejecutar el comando systemctl enable\nCuando se ejecuta este comando, lo que pasa es que por cada target indicado aqu\u00ed aparecer\u00e1,\ndentro de cada carpeta \"/etc/systemd/system/nomTarget.wants\" respectiva, un enlace simb\u00f3lico\napuntando al propio archivo de configuraci\u00f3n del unido en cuesti\u00f3n. La existencia de este enlace es el\nque realmente activa de forma efectiva un servicio autom\u00e1ticamente. Eliminar los links de todas\nlas carpetas \"nomTarget.wants\" pertinentes implica desactivar la unido (que es lo que hace, de hecho,\nel pedido systemctl disable a partir de la lista de targets que encuentra en la l\u00ednea WantedBy = ).\nPor ejemplo, si el archivo de configuraci\u00f3n de la unido en cuesti\u00f3n (que llamaremos pepito.service)\ntiene una l\u00ednea como WantedBy = multi-user.target, al ejecutar systemctl enable pepito.service\naparecer\u00e1 dentro de la carpeta /etc/systemd/system/multi-user.wants un link apuntando a este\narchivo de configuraci\u00f3n\nRequiredBy = untarget.target unaltre.target ...\nSimilar a WantedBy = pero donde el fallo del unido en cuesti\u00f3n en ejecutar systemctl enable har\u00e1\nque los targets indicados aqu\u00ed no puedan llegar a alcanzar. La carpeta donde se encuentra el link de\nel unido en este caso se denomina \"/etc/systemd/system/nomTarget.requires\"\nAlias \u200b\u200b= unaltrenom.tipusUnit\nPermite al unido en cuesti\u00f3n fue activada con systemctl enable utilizando otro nombre diferente\nAlso = unservei.service unaltre.service ...\nPermite activar o desactivar diferentes unidos como conjunto. La lista debe consistir en todas las\nunidos que tambi\u00e9n se quieren tener habilitadas cuando la unido en cuesti\u00f3n est\u00e9 habilitada\nSecci\u00f3n [Service] (por unidos de tipo .service):\nDependiendo del tipo de unido que tengamos nos podremos encontrar con diferentes secciones espec\u00edficas dentro\nde su fichero de configuraci\u00f3n, normalmente escritas entre la secci\u00f3n [Unido] el principio y la secci\u00f3n [Install] del\nfinal (si existe). En el caso de las unidos de tipo \"service\", por ejemplo, nos encontramos con la secci\u00f3n espec\u00edfica\nllamada [Service] , la cual puede incluir diferentes directivas como las siguientes:\nNOTA: Las unidos de tipo device, snapshot y target no tienen secciones espec\u00edficas\nType = maneraDarrancar\nExisten diferentes m\u00e9todos para iniciar un servicio, y el m\u00e9todo elegido, el cual depender\u00e1 del tipo\nde ejecutable a poner en marcha, se indicar\u00e1 en esta directiva. Las posibilidades m\u00e1s\ncomunes son:\nsimple: El servicio nativamente se queda en primer plano de forma indefinida y es systemd quien el\npone en segundo plano (le crea un fichero PID, lo para cuando sea necesario, etc). Systemd interpreta que el\nservicio est\u00e1 listo luego que el ejecutable asociado se pone en marcha (aunque esto sea\ndemasiado pronto para que no est\u00e9 listo todav\u00eda para recibir peticiones)\nforking: El servicio nativamente ya se pone en segundo plano. Systemd interpreta que el servicio est\u00e1\nlisto cuando pasa efectivamente a segundo plano. En este caso conviene indicar tambi\u00e9n la directiva\nPidFile = / ruta / fitxer.pid para que systemd tenga un control sobre qu\u00e9 proceso es el que est\u00e1\nen segundo plano y lo pueda identificar\nPage 8\noneshot: \u00datil para scripts, que se ejecutan (haciendo systemctl start igualmente) una vez y finalizan.\nSystemd esperar\u00e1 hasta que el proceso finalice e interpreta que est\u00e1 listo cuando haya finalizado.\nSe puede considerar el uso de la directiva RemainAfterExit = yes para \"enga\u00f1ar\" a systemd\ndici\u00e9ndole que el servicio contin\u00faa activo aunque el proceso haya finalizado; en este caso, la\ndirectiva ExecStop = no se llegar\u00e1 a hacer efectiva nunca.\nTambi\u00e9n est\u00e1n las posibilidades \"dbus\" (similar a \"simple\" pero systemd interpreta que est\u00e1 listo\ncuando el nombre indicado en BusName = ha sido adquirido), \"idle\" (similar a \"simple\" pero con\nla ejecuci\u00f3n retrasada hasta que no se ejecute nada m\u00e1s; se puede utilizar este m\u00e9todo, por\nejemplo, para emitir un sonido justo despu\u00e9s de la finalizaci\u00f3n del arranque del sistema.) y \"notify\"\n(El sistema m\u00e1s completo, donde se establece un canal de comunicaci\u00f3n interno entre el servicio y\nSystemd para notificarse estados y eventos v\u00eda la API propia de systemd sd_notify () y donde\nSystemd interpreta que est\u00e1 listo cuando recibe el estado correspondiente a trav\u00e9s de este canal; si\nqueremos que scripts utilicen este m\u00e9todo hay que usar el comando systemd-notify )\nExecStart = / ruta / ejecutable param1 param2 ...\nIndica el pedido (y par\u00e1metros) a ejecutar cuando se realiza un systemctl start Si la ruta de\nel ejecutable comienza con un gui\u00f3n ( \"-\"), valores de retorno del pedido diferentes de 0 (que\nnormalmente se considerar\u00edan se\u00f1al de error) se considerar\u00e1n como v\u00e1lidos.\nNOTA : Podemos utilizar incluso la directiva SuccessExitStatus = para indicar qu\u00e9 valor consideramos como salida\nexitosa del programa\nNOTA: No habr\u00eda que escribir la ruta absoluta del ejecutable si \u00e9sta se encuentra en la lista de rutas que muestra la\npedido systemd-path , pero en general se recomienda escribirla para evitar sorpresas\nNOTA: No se permiten escribir redireccionador ( \">\", \">>\", \"<\". \"|\") Ni el s\u00edmbolo \"&\" para pasar a segundo plano\nExecStartPre = / ruta / ejecutable param1 param2 ...\nIndica el pedido (y par\u00e1metros) a ejecutar antes de la indicada en ExecStart. pueden haber\nm\u00e1s de una l\u00ednea ExecStartPre al mismo archivo, ejecut\u00e1ndose entonces cada por orden. la\nruta del ejecutable tambi\u00e9n puede ir precedida de un gui\u00f3n ( \"-\"), con el mismo significado\nExecStartPost = / ruta / ejecutable param1 param2 ...\nIndica el pedido (y par\u00e1metros) a ejecutar despu\u00e9s de la indicada en ExecStart. pueden haber\nm\u00e1s de una l\u00ednea ExecStartPost al mismo archivo, ejecut\u00e1ndose entonces cada por orden. un\nejemplo de posible uso: el env\u00edo de un correo justo despu\u00e9s de haberse puesto en marcha el\nservicio corresponent.La ruta del ejecutable tambi\u00e9n puede ir precedida de un gui\u00f3n ( \"-\"), con el\nmismo significado\nExecStop = / ruta / ejecutable param1 param2 ...\nIndica el pedido (y par\u00e1metros) a ejecutar cuando se realiza un systemctl stop Hay que tener en\ncuenta que en el caso de un servicio de tipo \"oneshot\", si no se especifica la directiva\nRemainAfterExit = yes , el pedido indicada en ExecStop ejecutar\u00e1 autom\u00e1ticamente justo\ntras ExecStart.\nExecStopPost = / ruta / ejecutable param1 param2 ...\nIndica el pedido (y par\u00e1metros) a ejecutar despu\u00e9s de la indicada en ExecStop. pueden haber\nm\u00e1s de una l\u00ednea ExecStartPost al mismo archivo, ejecut\u00e1ndose entonces cada por orden.\nRestart = {always | no | on-success | on-failure | ...}\nIndica las circunstancias bajo las que systemd intentar\u00e1 reiniciar autom\u00e1ticamente un servicio\nque haya finalizado. En concreto, el valor \"always\" indica que en cualquier tipo de finalizaci\u00f3n\nse volver\u00e1 a intentar reiniciar; el valor \"no\" indica que en ning\u00fan finalizaci\u00f3n intentar\u00e1 reiniciar,\nel valor \"on-success\" indica que s\u00f3lo se intentar\u00e1 reiniciar si la finalizaci\u00f3n ha sido correcta\ny \"on-failure\" si la finalizaci\u00f3n no lo ha sido debido a cualquier tipo de fallo (ya sea que\nse ha sobrepasado el tiempo de espera del arranque o el apagado, que se ha devuelto un valor diferente\nde 0, etc)\nPage 9\nNOTA: Se podr\u00eda dar el caso de que un servicio estuviera reinici\u00e1ndose todo el rato. Con StartLimitBurts = se puede\nconfigurar el n\u00famero m\u00e1ximo de veces que se quiere que se reinicie y con StartLimitIntervalSec = se puede\nconfigurar el tiempo durante el cual se contar\u00e1 este n\u00famero m\u00e1ximo de veces. Si se llega a este n\u00famero dentro\nde este tiempo, el servicio no se volver\u00e1 a reiniciar autom\u00e1ticamente y tampoco se podr\u00e1 iniciar manualmente hasta\npasado el tiempo indicado (momento en el que se vuelve a contar). Tambi\u00e9n existe la directiva StartLimitAction = ,\nla que sirve para indicar la acci\u00f3n a realizar cuando se alcanza el n\u00famero m\u00e1ximo de reinicios; su valor por defecto es\n\"None\" pero puede valer tambi\u00e9n \"reboot\" (reinicio limpio), \"reboot-force\" (reinicio abrupto) y \"reboot-immediate\" (reinicio\nmuy abrupto)\nRestartSec = n\u00bas\nIndica el n\u00famero de segundos que systemd esperar\u00e1 al reiniciar el servicio despu\u00e9s de que\nhaya detenido (si as\u00ed lo marca la directiva Restart =).\nTimeoutSec = n\u00ba\nIndica el n\u00famero de segundos que systemd esperar\u00e1 a que el servicio en cuesti\u00f3n inicie o detenga\nantes de marcarlo como \"failed\" (y reiniciarlo si fuera el caso debido a la configuraci\u00f3n de la\ndirectiva Restart =). Se puede indicar espec\u00edficamente un tiempo de espera s\u00f3lo para el inicio con la\ndirectiva TimeoutStartSec = y otro tiempo de espera diferente por el apag\u00f3n con la directiva\nTimeoutStopSec = . Si no se especifica nada, se toma el valor por defecto (5 min) que est\u00e1 indicado\na /etc/systemd/system.conf\nRemainAfterExit = yes\nTal como ya lo hemos comentado, esta directiva se utiliza en servicios de tipo \"oneshot\" para\nque la directiva ExecStop = no se ejecute al terminar la ejecuci\u00f3n del pedido sino en hacer\nsystemctl stop\nPidFile = /ruta/fitxer.pid\nTal como ya lo hemos comentado, esta directiva se utiliza en servicios de tipo \"forking\" para\nse\u00f1alar a systemd cu\u00e1l ser\u00e1 el archivo PID utilizado por el servicio de manera que pueda\ncontrolar m\u00e1s f\u00e1cilmente.\nUser = unusuari\nGroup = ungrup\nSiete the user oro group that the processes are executed as, respectively. They can take a single\nuser / group name, oro a numeric ID as argumento. For system services (services run by the\nsystem service manager, ie managed by PID 1) the default is \"root\". For user services of\na\u00f1o other user, switching user identity is not permitted, Hence the only valid setting is the\nsame user the user s service manager is running as. If no group is set, the default group of the\nuser is used.\nWorkingDirectory = / ruta / carpeta\nIndica el directorio de trabajo del servicio en cuesti\u00f3n. Si no se especifica esta directiva, el\nvalor por defecto es \"/\" (en el caso de servicios de sistema) o $ HOME (en el caso de servicios\nde usuario, es decir, iniciados con --user -). Si la ruta se precede con un s\u00edmbolo \"-\", el hecho de\nque la carpeta correspondiente no exista no se interpretar\u00e1 como un error. Si se ha indicado la\ndirectiva User =, se puede escribir \"~\" como valor de esta directiva, equivalente as\u00ed a la ruta\nde la carpeta personal del usuario indicado en User =.\nStandardOutput = {null | tty | journal | socket}\nIndica donde se imprimir\u00e1 la salida est\u00e1ndar de los programas indicados en las directivas ExecStart =,\ny ExecStop =. El valor \"null\" representa el destino / dev / null. El valor \"tty\" representa un\nterminal (ya sea de tipo virtual - / dev / ttyX- o pseudo - / dev / pts / X-), el cual deber\u00e1 ser\nespecificado mediante la directiva TTYPath = . El valor \"journal\" es el valor por defecto (es\ndecir, que si el programa en cuesti\u00f3n imprimiera algo en la pantalla del terminal en\nejecutarse en primer plano, esta salida se redireccionar\u00e1 el Journal en ejecutarse v\u00eda\nun archivo .service). El valor \"socket\" sirve para indicar que la salida debe enviarse al\nsocket asociado al servidor con el fin de viajar al otro extremo de la comunicaci\u00f3n (ver m\u00e1s\nadelante).\nPage 10\nNOTA: El hecho de que por defecto la salida est\u00e1ndar vaya a parar en el Journal se puede cambiar de forma general para\ntodas las unidos a la directiva DefaultStandardOutput del archivo /etc/systemd/system.conf\nNOTA: Tambi\u00e9n existe la directiva StandardError = {null | tty | journal | socket} , similar a\nStandardOutput = pero para la salida de error\nEJERCICIOS:\nTodos los ejercicios se har\u00e1n en una m\u00e1quina virtual donde el usuario pueda tener permisos de administrador:\n1.-a) Ejecutar systemctl list-unidos -t service | grep ufw (si est\u00e1s en Ubuntu) o systemctl list-unidos -t service |\ngrep firewalld (si est\u00e1 en Fedora). \u00bfQu\u00e9 significa la palabra \"loaded\"? Y \"active\"? Confirma esto ejecutando\nsystemctl status ufw / systemctl status firewalld\nb) Ahora enmascara la unido ufw / firewalld. \u00bfQu\u00e9 pasa realmente cuando s'enmascara una unido? Pista: consulte donde\napunta el reci\u00e9n creado archivo /etc/systemd/system/ufw.service (o /etc/systemd/system/firewalld.service)\nc) Ejecutar systemctl list-unidos -t service | grep ufw (o systemctl list-unidos -t service | grep firewalld ) de nuevo.\n\u00bfPor qu\u00e9 todav\u00eda aparece la palabra \"active\"? Confirma esto ejecutando systemctl status ufw / systemctl status\nfirewalld\nd) Si ahora ejecutas systemctl stop ufw (o systemctl stop firewalld ) , \u00bfqu\u00e9 muestra systemctl list-unidos -t service |\ngrep ufw (o systemctl list-unidos -t service | grep firewalld )? \u00bfPor qu\u00e9? \u00bfQu\u00e9 deber\u00edas hacer para que vieras\nalgo? Pista: usa el par\u00e1metro --all\ne) Ejecutar el pedido systemd-delta . \u00bfQu\u00e9 significa la relaci\u00f3n indicada entre los dos archivos que aparecen en\nla l\u00ednea [Masked]? \u00bfY entre los dos archivos que aparecen en las l\u00edneas [EXTENDED]?\nNOTA: Tambi\u00e9n podr\u00eda haber alguna pareja de archivo en l\u00edneas [overrides] o incluso [EQUIVALENTE]\nf) Intenta iniciar el unido ufw (o firewalld) todav\u00eda Enmascarado. Puedes? Desenmascara y vuelve a intentarlo. puedes\nahora?\ng) Ejecutar el pedido systemctl edit ufw (o systemctl edit firewalld ) y, en el editor de texto que aparece, escribe la\nl\u00ednea Description = Hola amigo y guarda. A continuaci\u00f3n, ejecuta systemctl cat ufw (o systemctl cat firewalld ) .\n\u00bfQu\u00e9 ves? Y si vuelves a ejecutar systemd-delta ?\n2.-a) Crear un archivo llamado /etc/systemd/system/pepe.service con el siguiente contenido ...:\n[Unido]\nDescription = Pepe se colega\n[Service]\nType = oneshot\nExecStart = / bin / ls -l\nExecStop = / bin / df -h\n[Install]\nWantedBy = multi-user.target\n... y a continuaci\u00f3n (despu\u00e9s de systemctl daemon-reload) ejecuta systemctl start pepe Qu\u00e9 ves? Y si haces journalctl\n-e, \u00bfqu\u00e9 ves? \u00bfPor qu\u00e9?\nb) \u00bfQu\u00e9 deber\u00edas modificar del archivo anterior para que el comando / bin / df -h no ejecutara justo despu\u00e9s de /\nbin / ls -l sino s\u00f3lo cuando se escriba systemctl stop pepe ? Pista: consulta la explicaci\u00f3n del tipo \"oneshot\" en la\nteor\u00eda. Pru\u00e9balo utilizando los pedidos systemctl -full edit pepe, systemctl daemon-reload y, de nuevo,\njournalctl -e\nPage 11\nc) Para qu\u00e9 sirve la l\u00ednea WantedBy = ... ? O dicho de otro modo: \u00bfqu\u00e9 relaci\u00f3n tiene esta l\u00ednea con la\npedido systemctl enable ? Pista: observa el contenido de la carpeta / etc / systemd / system / multi-\nuser.target.wants\nd) \u00bfQu\u00e9 deber\u00edas modificar del archivo anterior para que la salida de los pedidos ejecutadas por la unido (ya\nsea \u200b\u200ba ExectStart = oa ExecStop =) no vaya a parar al Journal sino que se visualice el terminal / dev / tty4?\nPru\u00e9balo.\n3.-a) Crear un script llamado \"/ opt / yeah\" con el siguiente contenido (y dale permisos de ejecuci\u00f3n):",
            "title": "Comandos para gestionar Units (principalmente de tipo \"service\")"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#bin-bash",
            "text": "while [[true]]\ndo\ncurl -s ipinfo.io/ip\n/ Bin / sleep 3\nd\u00e9\nb) Crear un archivo llamado \"/etc/systemd/system/pepa.service\" con el siguiente contenido ...:\n[Unido]\nDescription = Pepa se colega\n[Service]\nType = simple\nExecStartPre = / usr / bin / systemd-cat -t PEPA -p grito echo \"Empieza\"\nExecStart = / opt / yeah\nExecStop = / usr / bin / systemd-cat -t PEPA -p grito echo \"Termino\"",
            "title": "! / Bin / bash"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#standardoutput-null",
            "text": "[Install]\nWantedBy = multi-user.target\n... y a continuaci\u00f3n (despu\u00e9s de systemctl daemon-reload) ejecuta systemctl start pepa. S y haces journalctl -f, que\nvoces? \u00bfPor qu\u00e9? Y si ejecutas systemctl stop pepa , que ves entonces el Journal? \u00bfPor qu\u00e9? Y si Descomente\nl\u00ednea que aparece comentada y vuelves a probar?\n4.-a) Crear un archivo llamado \"fiufiu.service\" dentro de \"/ etc / systemd / system\" con el siguiente contenido ...:\n[Unido]\nDescription = All we are saying is give peace a chance\n[Service]\nType = simple\nExecStart = / usr / bin / nc -l -p 5555\nRestart = on-success\n... y seguidamente ponerlo en marcha con el comando sudo systemctl start fiufiu . Comprueba con systemctl status\nfiufiu (o tambi\u00e9n con ss -tnl ) que se haya iniciado correctamente\nb) Ejecutar el pedido journalctl -ef y seguidamente, abre otro terminal para ejecutar en ellos el pedido nc\n127.0.0.1 5555 . Escribe algo la conexi\u00f3n abierta para este cliente Netcat y observa a la vez el\nque aparece en tiempo real en el Journal. \u00bfQu\u00e9 pasa? \u00bfPor qu\u00e9?\nc) Cerrar el cliente y vuelve a ejecutar. \u00bfEl servicio sigue funcionando? Ahora comenta la l\u00ednea Restart = ... que\naparece en el archivo fiufiu.service, reinicia el servicio y vuelve a ejecutar el cliente un par de veces. la primera\nvez deber\u00e1 conectarse sin problemas como siempre pero la segunda ya no. \u00bfPor qu\u00e9?\nPage 12\n5.-a) Instal.la el paquete \"apache2\" y observa, ejecutando el comando systemctl cat apache2 , el valor que tiene la\ndirectiva Restart =. Ejecuta entonces systemctl --signal = 9 kill apache2 y comprueba con systemctl status\napache2 si el servicio reinicia solo o no. \u00bfPor qu\u00e9 pasa lo que pasa?\nb) Cambiar ahora el valor de la directiva Restart = del unido del Apache2 mediante systemctl edit --full apache2\npara que valga \"no\" (recuerda que escribir como primera l\u00ednea el t\u00edtulo de la secci\u00f3n a la que pertenece la directiva\nque quieres sobreescribir -es decir, [Service] -). Despu\u00e9s de hacer systemctl daemon-reload (y de comprobar que la\nmodificaci\u00f3n es efectiva con systemd-delta o tambi\u00e9n systemctl cat apache2) , inicia el servicio de nuevo y\ncomprueba que efectivamente est\u00e9 iniciado. Vuelve a matar de nuevo con systemctl -signal = 9 kill apache2\ny vuelve a comprobar de nuevo si el servicio ha reiniciado autom\u00e1ticamente o no. \u00bfQu\u00e9 pasa ahora?\nc) Agregar mediante systemctl edit apache2 la l\u00ednea necesaria para llamar a una unido que se encargue\nejecutarse en el modo \"oneshot\" el pedido play /ruta/un/fitxer.mp3 cada vez que el Apache finalice debido a\nalguna situaci\u00f3n inesperada (como por ejemplo ser\u00eda una se\u00f1al kill 9)\nNOTA: El comando play encarga de reproducir el archivo de sonido indicado y admite muchos formatos posibles, no\ns\u00f3lo mp3. Forma parte del paquete \"sox\"\n6.a) Ejecuta systemctl disable ufw (o systemctl disable firewalld ) y seguidamente systemctl show --property\n\"Wants\" multi-user.target | grep -E \"(ufw | firewalld)\" \u00bfQu\u00e9 ves? \u00bfPor qu\u00e9? Pista: observa el mensaje que\naparece en pantalla en deshabilitar el servicio ufw\nb) Y si ahora ejecutas systemctl enable ufw (o systemctl enable firewalld ) y vuelves a ejecutar la misma\npedido? \u00bfQu\u00e9 ves ahora? \u00bfPor qu\u00e9? Pista: observa el contenido de la carpeta / etc / systemd / system / multi-\nuser.target.wants\nc) Deduce y di por qu\u00e9 la l\u00ednea After = de la unido ufw.service (o firewalld.service) tiene el valor que tiene.\nd) systemd puede no ser el proceso INIT de nuestro sistema Linux: aunque sea el m\u00e1s extendido con diferencia,\nte puedes encontrar distribuciones que utilicen sistemas INIT alternativos. Dime, de los siguientes comandos,\ncu\u00e1les sirven para comprobar si el proceso INIT de tu sistema es systemd (o no):\nfile / sbin / init\nman init\npgrep ^ systemd $\nPage 13\nSystemd (II)\ntargets\nPodemos definir un \"target\" como un \"estado\" del sistema definido por un determinado conjunto de servicios\npuestos en marcha (y otros que no). La idea es que, al arrancar el sistema, se llegue a un determinado \"target\"\n(Y, opcionalmente, a partir de all\u00ed, poder pasar a otro si fuera necesario). A continuaci\u00f3n se listan los \"targets\"\nm\u00e1s importantes (todos ellos ubicados dentro de / usr / lib / systemd / system):\npoweroff.target (o \"runlevel0.target\") Si se llega a este \"target\", se apaga el sistema\nreboot.target (o \"runlevel6.target\"): Si se llega a este \"target\", se reinicia el sistema\nrescue.target (o \"runlevel1.target\"): Si se llega a este \"target\", se inicia el sistema en modo texto,\nsin red y s\u00f3lo por el usuario root. Ser\u00eda similar a otro\ntarget llamado \" emergency.target \", pero el \"emergency\"\nes m\u00e1s \"radical\" que el \"rescate\" porque gracias a montar la\npartici\u00f3n ra\u00edz en modo s\u00f3lo lectura permite arrancar sistemas\nque el \"rescate\" quiz\u00e1s no puede.\nmulti-user.target (o \"runlevel3.target\"): En este caso se inicia el sistema en modo texto pero con\nred y multiusuario (el target predeterminado en servidores)\ngraphical.target (o \"runlevel5.target\"): En este caso, se inicia el sistema en modo gr\u00e1fico con red\ny multiusuario (el target por defecto en sistemas de escritorio)\nImplica haber pasado por el target \"multi-user\" previamente.\nOtros targets predefinidos que se instalan con systemd y que hay que conocer son:\nctrl-alt-del.target\nTarget activado cuando es pulsado CTRL + ALT + SUPR. Por defecto es un enlace a \"reboot.target\"\nsysinit.target\nTarget que ejecuta los primeros scripts de arranque\nsockets.target\nTarget que activa, al arrancar, todas las unidos de tipo \"socket\". Se recomienda, por tanto, que\ntodos los archivos de configuraci\u00f3n de una unido \"socket\" tengan a su l\u00ednea Wants = este target\nindicado (o bien WantedBy =)\ntimers.target\nTarget que activa, al arrancar, todas las unidos de tipo \"timer\". Se recomienda, por tanto, que\ntodos los archivos de configuraci\u00f3n de una unido \"timer\" tengan a su l\u00ednea Wants = este target\nindicado (o bien WantedBy =)\npaths.target\nTarget que activa, al arrancar, todas las unidos de tipo \"path\". Se recomienda, por tanto, que\ntodos los archivos de configuraci\u00f3n de una unido \"path\" tengan a su l\u00ednea Wants = este target\nindicado (o bien WantedBy =)\nswap.target\nTarget que habilita la memoria swap\nbasic.target\nTarget que pone en marcha todos los target relacionados con puntos de montaje, memorias swaps,\npaths, timers, sockets y otras unidades b\u00e1sicas necesarias para el funcionamiento del sistema.\nPage 14\ninitrd-fs.target\nEl generador systemd-fstab-generator a\u00f1ade autom\u00e1ticamente las unidos indicadas en la\ndirectiva Before = de esta unido a la unido especial \"sysroot-usr.mount\" (adem\u00e1s de todos los\npuntos de montaje existentes en / etc / fstab que tengan establecidas las opciones \"auto\" y\n\"X-initrd.mount\"). Ver m\u00e1s adelante una explicaci\u00f3n de las unidos de tipo mount.\ninitrd-root-fs.target\nEl generador systemd-fstab-generator a\u00f1ade autom\u00e1ticamente las unidos indicadas en la\ndirectiva Before = de esta unido a la unido especial \"sysroot-usr.mount\", la cual es generada a\npartir de los par\u00e1metros del kernel. Lo estudiaremos m\u00e1s adelante\nlocal-fs.target\nEl generador systemd-fstab-generator a\u00f1ade autom\u00e1ticamente las unidos indicadas en la\ndirectiva Before = de esta unido a todas las unidos de tipo \"mount\" que se refieren a puntos\nde montaje locales. Tambi\u00e9n a\u00f1ade a este target las dependencias de tipo Wants =\ncorrespondientes a los puntos de montaje existentes en / etc / fstab que tienen la opci\u00f3n \"auto\" establecida.\nVer m\u00e1s adelante una explicaci\u00f3n de las unidos de tipo mount.\nnetwork-online.target\nTarget que se activa autom\u00e1ticamente en cuanto el subsistema de red es funcional.\nCualquier servicio que tenga que trabajar en red se deber\u00e1 iniciar al menos en este target\nNOTA: Existe otro tarjet relacionado con la red llamado \"pre-network.target\" que est\u00e1 pensado para iniciar servicios\nantes de que cualquier tarjeta de red se configure. Su prop\u00f3sito principal es hacerlo servi con servicios de tipo cortafuegos,\npara establecer las reglas antes de que la configuraci\u00f3n de red funcione. Estos servicios deber\u00e1n tener una l\u00ednea\nBefore = network-pre.target y tambi\u00e9n una l\u00ednea Wants = network-pre.target a su archivo de configuraci\u00f3n\nNOTA: Existe otro tarjet relacionado con la red llamado simplemente \"network.target\" que s\u00f3lo indica que el stack\nsoftware de red ya se ha cargado en memoria pero esto no implica que las interfaces se hayan configurado todav\u00eda. este\ntarget est\u00e1 m\u00e1s pensado para el proceso de apagado de la m\u00e1quina para realizar este proceso de forma ordenada: pues\nla orden de apagado es al rev\u00e9s que el de arranque, cualquier unido que tenga una l\u00ednea After = network.target apagar\u00e1 antes\nque la red se descargue y esto har\u00e1 que esta unido apague sin interrumpir ninguna conexi\u00f3n que est\u00e9 pendiente\nprinter.target\nTarget que se activa autom\u00e1ticamente tan pronto como una impresora es enchufada o aparece\ndisponible durante el arranque. Aqu\u00ed donde se suele iniciar, por ejemplo, el servicio Cups.\nsound.target\nTarget que se activa autom\u00e1ticamente tan pronto como una tarjeta de audio es enchufada o\naparece disponible durante el arranque.\nbluetooth.target\nTarget que se activa autom\u00e1ticamente tan pronto como un controlador Bluetooth es enchufado o\naparece disponible durante el arranque.\nsmartcard.target\nTarget que se activa autom\u00e1ticamente tan pronto como un controlador Smartcard es enchufado o\naparece disponible durante el arranque.\nsystem-update.target\nTarget especial utilizada para actualizaciones del sistema. El generador systemd-System-\nupdate-generator redireccionar\u00e1 el proceso de arranque autom\u00e1ticamente a este target si la\ncarpeta / system-update existe\numount.target\nTarget que desmonta todos los puntos \"mount\" y \"automount\" durante el apagado del sistema\nfinal.target\nTarget utilizado durante el apagado del sistema que puede utilizarse para apagar los \u00faltimos servicios\ndespu\u00e9s de que los servicios \"normales\" ya se han detenido y los puntos de montaje se han desmontado.\nPage 15\nPara saber el target donde nos encontramos en este momento podemos hacer: systemctl get-default\nHay que tener en cuenta que m\u00faltiples targets pueden estar activados a la vez. Un target activado indica\nque systemd ha intentado iniciar todas las unidos asociadas a este target. Esto significa que el comando anterior\ns\u00f3lo nos dice cu\u00e1l es el target \"final\" donde hemos llegado, pero a lo largo del camino desde el arranque de la m\u00e1quina\nhasta llegar a este target \"final\" se han ido activando diferentes targets a modo de \"escalones\" intermedios. por\nver todos los targets activados, hay que hacer systemctl list-unidos -type = target\nSe puede cambiar el target actual a otro simplemente ejecutando: systemctl Isolate\nnomTargetDesti.target Para cambiar el target por defecto donde ir\u00e1 a parar autom\u00e1ticamente a cada arranque del\nsistema se puede hacer: systemctl set-default nomTargetDefecte.target\nNOTA: El comando anterior, en realidad lo \u00fanico que hace es revincular el link \"/etc/systemd/system/default.target\" en el archivo\n* .Target adecuado.\nNOTA: Otra manera de entrar al final del arranque del sistema en un determinado target predeterminado es a\u00f1adir la l\u00ednea\nsystemd.unit = nomTargetDesti.target a la lista de par\u00e1metros del kernel indicada en la configuraci\u00f3n del gestor de arranque\nHay una serie de pedidos espec\u00edficos para pasar a determinados estados (poweroff, reboot, etc) que se\npueden usar en vez del pedido systemctl Isolate gen\u00e9rica. Por ejemplo:\nsudo systemctl rescue : Similar a systemctl Isolate rescue.target\nsudo systemctl poweroff (o sudo poweroff a secas): Similar a systemctl Isolate poweroff.target\nsudo systemctl reboot (o sudo reboot a secas): Similar a systemctl Isolate reboot.target\nSi se quiere detener (-P) o reiniciar (-r) la m\u00e1quina en un momento futuro determinado (hh: mm), entonces habr\u00e1\nejecutar el comando: sudo shutdown {-P | -r} hh: mm\nSi se quiere detener (-P) o reiniciar (-r) la m\u00e1quina dentro de una cierta cantidad de minutos, entonces habr\u00e1 que ejecutar\nel pedido: sudo shutdown {-P | -r} + m\nNOTA: Dentro de la carpeta \"/ usr / lib / systemd / system-shutdown\" pueden haber archivos * .shutdown, que son scripts ejecutables que\nejecutar\u00e1n justo antes del apag\u00f3n / reinicio del sistema (es decir, justo en poner en marcha los servicios \"poweroff.service\" o\n\"Reboot.service\"). Quien ejecutar\u00e1 estos scripts es el binario / usr / lib / systemd / systemd-shutdown, el cual es invocado siempre por\nestos servicios, que lo colocan como PID 1 y es el responsable de desmontar los sistemas de ficheros, deshabilitar la swap, matar\nlos procesos que queden pendientes, etc. A los scripts ejecutados por / usr / lib / systemd / systemd-shutdown podemos utilizar un par\u00e1metro\n($ 1) que puede valer \"poweroff\" o \"reboot\" dependiendo de la acci\u00f3n que realizar\u00e1 y que nos podr\u00eda servir para distinguir qu\u00e9 queremos que haga\neste script seg\u00fan la acci\u00f3n indicada. Todos los scripts se ejecutan en paralelo. Hay que tener en cuenta, finalmente, que el sistema de ficheros\nen ese momento permanece montado pero en modo s\u00f3lo lectura.\nNOTA: En el pedido systemctl reboot le podemos a\u00f1adir varios par\u00e1metros interesantes, los cuales s\u00f3lo funcionan, sin embargo, en sistemas\nUEFI que han arrancado mediante el gestor de arranque systemd-boot :\n--firmware-setup : INDICATE to the system s firmware to reboot into the firmware setup interface (aka the \"UEFI control panel\")\n--boot-loader-menu = n\u00basegons : INDICATE to the system s boot loader to show the boot loader menu on the following boot the number\nof seconds specified as value. Pass 0 value in order to disable the menu timeout.\n- boot-loader-entry = entryID : INDICATE to the system s boot loader to boot into a specific boot loader entry on the following boot.\nTakes a boot loader entry identifier as argumento, oro \"help\" in order to list available entries.\nLo que hacen los par\u00e1metros anteriores es modificar determinados valores de variables EFI concretas (tal como se podr\u00eda haber hecho tambi\u00e9n\ncon el pedido efibootmgr ) para as\u00ed modificar el comportamiento de la UEFI el pr\u00f3ximo arranque\nPor otra parte, con el pedido sudo systemctl suspend podemos suspender el sistema (o dicho de otro\nmanera, nos permiten llegar al target \"suspend.target\") y con el pedido sudo systemctl hibernate la\npodemos poner a hibernar (o dicho de otro modo, permiten llegar al target \"hibernate.target\").\n\"Suspender\" significa que se guarda todo el estado del sistema en la RAM y se apaga la mayor\u00eda de dispositivos de la\nm\u00e1quina; cuando se pone en marcha de nuevo, el sistema restaura su estado previo de la RAM sin tener que reiniciarse\nde nuevo: este proceso es muy r\u00e1pido pero tiene el inconveniente de que obliga a mantener con alimentaci\u00f3n\nel\u00e9ctrica la m\u00e1quina todo el tiempo. \"Hibernar\" significa que se guarda todo el estado del sistema en el disco duro (si tiene\nespacio libre) y se apaga por completo la m\u00e1quina: cuando se pone en marcha de nuevo, el sistema restaura su estado previo desde el\ndisco duro sin tener que reiniciar de nuevo: este proceso es bastante lento pero tiene la ventaja de no tener que\nmantener con alimentaci\u00f3n el\u00e9ctrica la m\u00e1quina.\nPage 16\nNOTA: Dentro de la carpeta \"/ usr / lib / systemd / system-sleep\" pueden haber archivos * .sleep, que son scripts ejecutables que se ejecutar\u00e1n\njusto antes de la hibernaci\u00f3n o suspensi\u00f3n del sistema (es decir, justo en poner en marcha internamente los servicios \"systemd-\nhibernate.service \"o\" systemd-suspend.service \", los cuales, por cierto, nunca deben ser invocados directamente con systemctl start ... sino\nutilizando los pedidos explicadas en el p\u00e1rrafo anterior: systemctl hibernate o systemctl suspend ). Quien ejecutar\u00e1 estos scripts es\nel binario / usr / lib / systemd / systemd-sleep, el cual es invocado siempre por estos servicios y admite dos par\u00e1metros que podemos utilizar\nen estos scripts como $ 1 y $ 2 respectivamente. El primer par\u00e1metro puede valer \"pre\" o \"post\" dependiendo de si la m\u00e1quina est\u00e1 yendo a\nla suspensi\u00f3n / hibernaci\u00f3n o est\u00e1 volviendo, respectivamente. El segundo par\u00e1metro puede valer \"suspend\" o \"hibernate\" dependiendo de la acci\u00f3n\nque realizar\u00e1 y que nos podr\u00eda server para distinguir qu\u00e9 queremos que haga este script seg\u00fan la acci\u00f3n indicada. Todos los scripts\nejecutan en paralelo.\nSi se quiere realizar una tarea larga y asegurarse de que la m\u00e1quina no se suspender\u00e1 o apagar\u00e1 mientras tanto,\nse puede invocar el pedido correspondiente a esta tarea as\u00ed: systemd-inhibido comanda_llarga El pedido\nsystemd-inhibido --list muestra las tareas que tienen este truco en marcha. Si se quiere especificar una acci\u00f3n\nconcreta a inhibir se puede indicar con el par\u00e1metro - what = acci\u00f3n , donde \"acci\u00f3n\" puede ser por ejemplo la palabra\n\"Shutdown\" o \"sleep\" (equivalente a hibernaci\u00f3n o suspensi\u00f3n), entre otros. Encontrar\u00e1 m\u00e1s informaci\u00f3n en los\nprimeros p\u00e1rrafos de https://www.freedesktop.org/wiki/Software/systemd/inhibit/\nPara que el inicio con systemctl start de un determinado servicio (o target) se produzca dentro de un target\ndeterminado -llamado-el \"a.target\" - desde el propio archivo de configuraci\u00f3n del servicio en cuesti\u00f3n hay que escribir\nlas directivas Wants = a.target, Requires = a.target y / o After = a.target (estas directivas se aseguran de llegar\nprimero al target \"a.target\" para iniciar entonces el servicio en cuesti\u00f3n). Por otra parte, tambi\u00e9n existe la directiva\nConflicts = a.target , la que se asegura de no estar en el target \"a.target\" para poder iniciar el servicio en cuesti\u00f3n.\nEn el caso de querer iniciar siempre un servicio determinado autom\u00e1ticamente en el target \"a.target\", entonces\nhabr\u00e1 que escribir adem\u00e1s las directivas WantedBy = a.target o RequiredBy = a.target del archivo de configuraci\u00f3n del\nservicio (en este \u00faltimo caso, al hacer systemctl enable nomServei se crea un enlace a su archivo de configuraci\u00f3n\ndentro de \"/lib/systemd/system/a.target.wants\").\nLos archivos de configuraci\u00f3n de los targets s\u00f3lo tienen secciones [Unido] (y muy pocas la secci\u00f3n\n[Install]). En este sentido, es interesante consultar los archivos correspondientes, por ejemplo, a multi-user.target\no graphical.target: s\u00f3lo encontramos las directivas Description, Documentation, Wants, Requires, After,\nConflicts y AllowIsolate (ya partir de ellas podemos deducir las dependencias que hay entre targets ... aunque\npor eso hay pedidos espec\u00edficos que enseguida veremos).\nEJERCICIOS:\n1.- Crear un target nuevo llamado \"manolo.target\" donde el sistema deber\u00e1 entrar justo despu\u00e9s de activar\ngraphical.target (es decir, debe ser el \u00faltimo target al activarse). La idea ser\u00e1 asegurarte de que entras en\neste target para ejecutar un determinado servicio (lo llamaremos \"manolo.service\") el \u00faltimo de todos. para hacer\nesto, tienes que hacer lo siguiente:\na) Crear un nuevo fichero llamado \"/etc/systemd/system/manolo.target\" con el siguiente contenido:\n[Unido]\nDescription = Manolo is kind\nDocumentation = http: //www.lecturas.com\nRequires = graphical.target\nAfter = graphical.target\nConflicts = rescue.service rescue.target\nAllowIsolate = yes\nb) Crear un nuevo fichero llamado \"/etc/systemd/system/manolo.service\" con el siguiente contenido:\n[Unido]\nDescription = Manolo is soberbio\nPage 17\nDocumentation = http: //www.hola.com\nRequires = manolo.target\nAfter = manolo.target\n[Service]\nExecStart = / usr / bin / printf \"MANOLO \\ n\"\nRemainAfterExit = yes\n[Install]\nWantedBy = manolo.target\nc) Ejecutar systemctl enable manolo.service y reinicia la m\u00e1quina. \u00bfCrees que el servicio \"manolo\" estar\u00e1\nfuncionando autom\u00e1ticamente o no? \u00bfPor qu\u00e9 lo crees? Compru\u00e9balo ejecutando el pedido systemctl status\nmanolo.service (o tambi\u00e9n observando si aparece la palabra \"MANOLO\" en el Journal). PISTA: La respuesta de\nporque el servicio \"manolo\" estar\u00e1 funcionando (o no) se encuentra en el que muestra el pedido systemctl list-unidos -\nt target | grep \"manolo\" y en entender el significado de la l\u00ednea WantedBy =\nd ) A continuaci\u00f3n ejecuta systemctl start manolo.service . Despu\u00e9s de observar que el servicio se haya puesto en marcha\ncorrectamente (en la salida del pedido systemctl status manolo.service o tambi\u00e9n observando si aparece la\npalabra \"MANOLO\" en el Journal), \u00bfcrees que el pedido systemctl list-unidos -t target | grep \"manolo\"\nmostrar\u00e1 algo diferente respecto del apartado anterior? \u00bfPor qu\u00e9 lo crees? PISTA: La respuesta se encuentra en\nentender el significado de las l\u00edneas Requires = y After = del archivo \"manolo.service\"\ne) Ejecutar systemctl set-default manolo.target y vuelve a reiniciar la m\u00e1quina. \u00bfCrees que el servicio \"manolo\"\nahora estar\u00e1 funcionando autom\u00e1ticamente o no? \u00bfPor qu\u00e9 lo crees? Compru\u00e9balo ejecutando el pedido systemctl\nstatus manolo.service (o tambi\u00e9n observando si aparece la palabra \"MANOLO\" en el Journal). PISTA: La respuesta\nse encuentra en entender el significado de las l\u00edneas Requires = y After = del archivo \"manolo.target\"\n2.-a) Entra en el target de rescate. \u00bfQu\u00e9 pasa?\nb) Entra en el target de suspensi\u00f3n. \u00bfQu\u00e9 pasa?\nc) Entra en el target multi-user. \u00bfQu\u00e9 pasa?\nd) Crear un script ejecutable dentro de la carpeta \"/ usr / lib / systemd / system-sleep\" con el siguiente contenido ...:",
            "title": "StandardOutput = null"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#bin-bash_1",
            "text": "if [[ \"$ 1\" == \"pre\"]]\nthen\necho \"we are suspending oro hibernating at $ (date) ...\"> / tmp / systemd_suspend_test\nElif [[ \"$ 1\" == \"post\"]]\nthen\necho \"... and we are back from $ (date)\" >> / tmp / systemd_suspend_test\nfin\n... y prueba de suspender el sistema y volver a \"despertar\". \u00bfQu\u00e9 pasar\u00e1?\ne) \u00bfPara qu\u00e9 sirve este programa: https://github.com/ryran/reboot-guard ?\nPage 18\nboot chain\nPara saber la jerarqu\u00eda de dependencias de targets para llegar a iniciar un target (o service!) Determinado\nse puede utilizar el comando: systemctl list-dependencias nomTarget.target (o nomUnit.service )\nNOTA: Una forma alternativa de obtener una informaci\u00f3n similar ser\u00eda ejecutando systemctl show -p \"Wants\"\nnomTarget.target && systemctl show -p \"Requires\" nomTarget.target . Tambi\u00e9n se puede ejecutar systemctl status\nLas dependencias mostradas se corresponden a unidos que han sido \"required\" o \"wanted\" por las\nunidos superiores. Las dependencias recursivas s\u00f3lo se muestran los targets intermedios; si se quieren ver\ntambi\u00e9n por los service, mounts paths, socket, etc intermedios hay que incluir el par\u00e1metro --all al pedido\nanterior.\nTambi\u00e9n se pueden mostrar cu\u00e1les unidos dependen para funcionar del correcto inicio de un target (o service!)\ndeterminado con el pedido: systemctl list-dependencias --reverse nomTarget.target (o nomUnit.service )\nNOTA: Una forma alternativa de obtener una informaci\u00f3n similar ser\u00eda ejecutando systemctl show -p \"WantedBy\"\nnomTarget.target && systemctl show -p \"RequiredBy\" nomTarget.target\nOtros par\u00e1metros interesantes de este comando son --before y - after , los cuales sirven para\nmostrar unidos que dependen para funcionar del correcto inicio anterior o posterior de un target, respectivamente.\nPor otra parte, respecto al arranque del sistema podemos obtener una informaci\u00f3n m\u00e1s detallada sobre los\ntiempo que tarda cada unido en cargarse y el orden en que lo hace gracias al pedido systemd-analyze , lo\ntiene varias posibilidades\nsystemd-analyze : Muestra el tiempo total empleado en el arranque del sistema y qu\u00e9 parte de este tiempo ha sido\nempleado en tareas del kernel, qu\u00e9 parte en uso de initrd y qu\u00e9 parte en tareas de usuario\nsystemd-analyze blame : Muestra los tiempos disgregados por servicio. Hay que indicar que estos tiempos son \"en\nparalelo \", as\u00ed que la suma total que sale ser\u00e1 siempre muy superior al tiempo real empleado en\nel arranque.\nsystemd-analyze dote [nomTarget.target] | dot -T {png | svg} -o foto. {png | svg} : Genera una salida que\nsi se pasa a la aplicaci\u00f3n \"dot\" (perteneciente al paquete \"GraphViz\") generar\u00e1 finalmente un gr\u00e1fico\n(En formato png o svg) donde se pueden visualizar todas las dependencias del target (o servicio!)\nindicado (o, si no se indica, del \"default.target\"; tambi\u00e9n se pueden indicar comodines en el nombre del\ntarget / servicio).\nsystemd-analyze plot [nomTarget.target]> something.svg : Genera un gr\u00e1fico donde se muestra los tiempos\nde ejecuci\u00f3n y de bloqueo de cada unido durante el arranque hasta llegar al target (o servicio!)\nindicado (o, si no se indica, del \"default.target\")\nsystemd-analyze critical-chain [nomTarget.target] : Muestra el \u00e1rbol de dependencias bloqueantes por target (o\nservicio!) indicado. El tiempo mostrado despu\u00e9s de \"@\" indica el tiempo que hace que la unido est\u00e1 activa; el tiempo\nmostrado despu\u00e9s de \"+\" indica el tiempo que la unido ha tardado en activarse.\nOtras opciones del pedido systemd-analyze son syscall-filter, verify, dump, log-level, security, time ...\nSe puede ver si, una vez iniciado el sistema, a\u00fan quedan tareas pertenecientes al arranque para completar\nejecutando el pedido systemctl list-jobs\nPage 19\nEJERCICIOS:\n1.- a) \u00bfQu\u00e9 targets deben haberse iniciado para que el servicio gdm se pueda poner en marcha? (esto lo puedes\nsaber con el pedido s ystemctl list-dependencias ... )\nb) Ejecutar el pedido systemctl list-dependencias --reverse gdm.service Qu\u00e9 ves?\nc) \u00bfQu\u00e9 hace el pedido tree / etc / systemd / system y para qu\u00e9 podr\u00eda servirte?\n2.-a) Ejecutar systemd-analyze plot ... y observa qu\u00e9 unido bloquea m\u00e1s tiempo el arranque de tu sistema. prueba\nde desactivarla (esperemos no romper nada!) y reinicia. Ejecuta ahora systemd-analyze blame para comprobar si el\ntiempo total de arranque ha disminuido efectivamente.\nb) Instal.la el paquete \"GraphViz\" y genera un gr\u00e1fico Png con las dependencias del target multi-user. Haz una\nlista de las dependencias all\u00ed mostradas y adjunta la captura del gr\u00e1fico\nplantillas\nUna plantilla es un archivo de configuraci\u00f3n de tipo \"service\" que tiene la particularidad de permitir poner\nen marcha variantes de un mismo servicio sin tener que escribir un archivo \"service\" diferente para cada variante.\nB\u00e1sicamente, para utilizar una plantilla hay que hacer los siguientes pasos:\n1.- El archivo \"service\" que har\u00e1 de plantilla debe llamarse \"nomServei @ .service\". Es decir, hay que indicar\nel s\u00edmbolo arroba antes del punto\n2.- El contenido de este archivo plantilla puede ser exactamente igual que el de un archivo \"service\" est\u00e1ndar\n3.- A la hora de iniciar, parar, activar, desactivar, ver el estado, etc de una plantilla, se deber\u00e1 indicar\nel identificador concreto de la variante con la que queremos trabajar. Este identificador se establece la\nprimera vez que arranca la variante y simplemente consiste en una cadena entre la arroba y el punto,\nas\u00ed: systemctl start nomServei @ identificador. service A partir de aqu\u00ed, este identificador se har\u00e1\nservir de la misma manera por el resto de tareas relacionadas con la gesti\u00f3n de esta variante\nNOTA: An instance file is usually created as a symbolic link to the template file, with the link name including the instance\nidentifier. In this way, multiple links with unique Identifiers can point back to a single template file. When managing a\u00f1o\ninstance unido, systemd will look for a file with the exact instance name you Specify on the command line to use but if it\ncan not find one, it will look for an associated template file.\n4.- La gracia de las plantillas es que el valor del identificador indicado en el punto anterior se puede utilizar\ndin\u00e1micamente dentro del contenido del archivo plantilla (concretamente mediante el s\u00edmbolo \" % y \"), de\nlo que seg\u00fan el valor que haya adquirido% y por esa variante se podr\u00eda poner en marcha el\nservicio escuchando en un puerto diferente (si% y representa un n\u00famero de puerto), o bien utilizando un archivo de\nconfiguraci\u00f3n diferente (si% y representa un nombre de archivo), o lo que nos convenga.\nNOTA: Otros s\u00edmbolos especiales que se pueden indicar en un archivo de configuraci\u00f3n de una plantilla pueden ser\n% p : representa the unido name prefijo (this is the Portion of the unido name that comes before the @ symbol)\n% n : representa the full resulting unido name (% p plus% e)\n% u : The name of the user configured to run the unido.\n% U : The same as above, but as a numeric UID instead of name.\n% H : The host name of the system that is running the unido.\n%% : This is used to insert a literal percentage sign.\nPage 20\nPongamos un ejemplo. Imaginemos que tenemos un determinado servidor web que queremos ejecutar con dos\nconfiguraciones diferentes a la vez. La soluci\u00f3n ser\u00eda crear un archivo plantilla llamado por ejemplo\n\"Servidorweb @ .service\" con un contenido similar al siguiente:\n[Unido]\nDescription = My HTTP server\n[Service]\nType = simple\nExecStart = / usr / sbin / WebServer --config-file /etc/%i.conf\n[Install]\nWantedBy = multi-user.target\nCon este archivo, se podr\u00eda iniciar entonces el servidor dos veces, cada una indicando el nombre del archivo de\nconfiguraci\u00f3n deseado, as\u00ed:\nsudo systemctl start servidorweb@config1.service\nsudo systemctl start servidorweb@config2.service\nLos pedidos anteriores lo que har\u00e1n ser\u00e1 ejecutar, respectivamente, los pedidos: / usr / sbin / WebServer -\nconfig-file /etc/config1.conf y / usr / sbin / WebServer -config-file /etc/config2.conf\nEJERCICIOS:\n1.-a) Crear un archivo plantilla que permita poner en marcha diferentes servidores Ncat de forma permanente\n(Recuerda el par\u00e1metro -k) escuchando cada uno de ellos en un puerto diferente.\nNOTA: Deber\u00e1s instalar el paquete \"nmap\" para disponer del pedido ncat\nb) Iniciar un servidor Ncat a partir de la plantilla anterior escuchando en el puerto 2.222 y otro escuchando en el puerto\n3333. Comprueba que, efectivamente, estos dos puertos est\u00e9n abiertos observando la salida del pedido ss\n-tnl\nc) Conecta con el cliente Ncat a uno de los servidores anteriores y env\u00edale alg\u00fan mensaje. Cerrar el cliente (con\nCTRL + C) y ahora vuelve a ejecutarlo para conectar al otro servidor; vuelve a enviarle alg\u00fan otro mensaje y\nci\u00e9rralo de nuevo. Observa las \u00faltimas l\u00edneas del Journal: \u00bfqu\u00e9 ves?\n2.- Lee el siguiente p\u00e1rrafo y seguidamente contesta:\nWhen the user switches consolas using Ctrl + Alt + F2, Ctrl + Alt + F3, and so on, a new terminal then is spawned. in this\ncase systemd callos a service named getty @ .service providing the appropriate argumento such as tty2 oro tty3 to the unido\nfile. The% y identifier provides this argumento value to the agetty binary sonido the terminal starts on that new console (as it\ncan seen in ExecStart = line from template file).\na) Para qu\u00e9 sirve el pedido agetty? Busca en su p\u00e1gina del manual que hace su par\u00e1metro -ay\na\u00f1\u00e1delo a la invocaci\u00f3n del pedido escrita a la l\u00ednea ExecStart de dentro del archivo getty @ .service (recuerda\nde ejecutar sudo systemctl daemon-reload justo despu\u00e9s). \u00bfQu\u00e9 pasa ahora cuando pulses Ctrl + Alt + F2, etc?\nb) enmascarado la instancia tty5 de la plantilla getty @ .service. \u00bfQu\u00e9 pasa ahora si haces Ctrl + Alt + F5?\nNOTA: Es posible que tambi\u00e9n hayas de enmascarar la plantilla autovt @ .service para que funcione el ejercicio\nNOTA: Hay otras maneras m\u00e1s sofisticadas de desactivar terminales virtuales pero las veremos m\u00e1s adelante\nc) \u00bfQu\u00e9 te muestra el pedido systemctl status getty @ * ?\nPage 21\n3.- Supone que tienes un archivo llamado \"/etc/systemd/system/pepe@.service\" con el siguiente contenido:\n[Unido]\nDescription = lerele\n[Service]\nType = oneshot\nExecStart = / usr / local / bin / systemd-email% y admin@elpuig.xeill.net\nUser = nobody\nGroup = systemd-journal\ndonde \"systemd-email\" es un bash shell script escrito por nosotros dise\u00f1ado para enviar correos (suponiendo que\ntenemos un servidor Postfix o similar configurado en la m\u00e1quina) que tiene el siguiente c\u00f3digo:",
            "title": "! / Bin / bash"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#bin-bash_2",
            "text": "systemctl status -full \"$ 1\" | mail -s \"$ 1\" $ 2\ny supone que has a\u00f1adido la l\u00ednea OnFailure=pepe@%i.service en la secci\u00f3n [Unido] del archivo \".service\"\ncorrespondiente al / los servicio / s que quiere monitorear.\na) \u00bfCu\u00e1l pedido deber\u00edas ejecutar para poner en marcha una instancia del servicio-plantilla pepe @ que\nse encargan de enviar mails en el momento que el servicio Cups falle?\nsockets\nUn aspecto muy interesante de systemd es que permite que un servidor no est\u00e9 permanentemente\nencendido sino que s\u00f3lo arranque \"bajo demanda\" (es decir, cuando detecte una conexi\u00f3n, normalmente externa).\nDe este modo, este servidor no consume m\u00e1s recursos que los m\u00ednimos imprescindibles, en el momento\njusto. Para lograr esto, lo que pasa es que s\u00ed hay un componente \"escuchando\" todo el rato posibles\nintentos de conexiones, pero este componente no es la unido \"service\" en s\u00ed sino un \"perro guardi\u00e1n\" que\ns\u00f3lo despertar\u00e1 unido \"service\" cuando sea necesario. Este \"perro guardi\u00e1n\" es la unido de tipo \"socket\".\nCada archivo de configuraci\u00f3n de una unido \"socket\" debe tener exactamente el mismo nombre que el archivo de\nconfiguraci\u00f3n de la unido \"service\" que quiere despertar (es decir, si tenemos el servicio \"a.service\", el socket\ncorrespondiente deber\u00e1 llamarse \"a.socket\"). La idea es tener la unido \"socket\" siempre encendido ( systemctl\nenable a.socket ) pero la unido \"service\" no ( systemctl disable a.service ); cuando se detecte una conexi\u00f3n, el\n\"socket\" autom\u00e1ticamente encender\u00e1 la unido \"service\" (esto se puede ver haciendo systemctl status a.service mientras\nexiste la conexi\u00f3n) y la apagar\u00e1 de nuevo pasado un determinado tiempo sin actividad (por defecto 5 minutos).\nObviamente, si par\u00e1ramos el \"socket\" ( systemctl stop a.socket ) o el deshabilit\u00e9ssim el pr\u00f3ximo reinicio ( systemctl\ndisable a.socket ) ya no habr\u00eda \"perro guardi\u00e1n\" atento y, por tanto, el servicio ya no se pondr\u00eda en marcha\nautom\u00e1ticamente.\nPara cambiar el puerto donde escucha un \"socket\" (entre otras cosas) hay que modificar la configuraci\u00f3n del\n\"Socket\" propiamente dicho y eso no depende de la configuraci\u00f3n del servidor en cuesti\u00f3n. Los archivos de configuraci\u00f3n\nde cada \"socket\" se pueden encontrar, como cualquier otra unido, o bien dentro de la carpeta \"/ usr / lib / systemd / system\"\no bien dentro de \"/ etc / systemd / system\" y se puede utilizar igualmente el pedido systemctl edit a.socket para\ngenerar archivos \"override\". La secci\u00f3n que nos interesa en estos tipos de ficheros es la secci\u00f3n [Socket] , lo\npuede contener alguna de las siguientes directivas m\u00e1s importantes:\nListenStream = [IP:] n\u00baport\nIndica el n\u00famero de puerto TCP por donde escuchar\u00e1 el socket. Opcionalmente, se puede indicar una IP\nconcreta para especificar que s\u00f3lo escuchar\u00e1 en el puerto ofrecido por aquella IP y ninguna m\u00e1s.\nNOTA: Se pueden indicar varias l\u00edneas ListemStream para hacer que el socket escuche en varios puertos a la vez. Por otra parte,\ncomo que esta l\u00ednea puede estar escrita en diferentes archivos, si se quiere asegurar que s\u00f3lo se escuche en un puerto concreto sin\ntener en cuenta otras l\u00edneas que pueda haber le\u00eddo systemd previamente, se puede a\u00f1adir primero una l\u00ednea ListemStream vac\u00eda\n(as\u00ed: ListemStream = ) y luego la l\u00ednea ListenStream asociada al puerto deseado; lo que hace la l\u00ednea ListemStream vac\u00eda es\n\"resetear\" todas las l\u00edneas ListemStream anteriores\nPage 22\nListenDatagram = [IP:] n\u00baport\nIndica el n\u00famero de puerto UDP por donde escuchar\u00e1 el socket. Opcionalmente, se puede indicar una IP\nconcreta para especificar que s\u00f3lo escuchar\u00e1 en el puerto ofrecido por aquella IP y ninguna m\u00e1s.\nListenSequentialPacket = / ruta / arxiu.socket\nIndica el socket de tipo UNIX por donde se escuchar\u00e1. S\u00f3lo sirve para comunicaciones entre\nprocesos de la misma m\u00e1quina\nService = unNomAlternatiu\nSi el nombre del archivo \"service\" no es igual que el nombre del archivo \"socket\", aqu\u00ed se puede indicar\nentonces el nombre que tiene el archivo \"service\" para que el socket el sepa encontrar.\nAccept = yes\nSi se indica, hace que se genere una instancia del servicio diferente para cada conexi\u00f3n. \u00datil cuando se\nutilizan plantillas. Si su valor es no (por defecto) s\u00f3lo una instancia del servicio\ngestionar\u00e1 todas las conexiones.\nEl pedido systemctl status * .socket nos permite saber cu\u00e1ntos y cu\u00e1les sockets est\u00e1n escuchando ahora\nmismo; el valor \"Accepted\" muestra cu\u00e1ntas conexiones se han realizado en total desde que el socket ha sido\niniciado y el valor \"Connected\" muestra cu\u00e1ntas conexiones est\u00e1n actualmente activas\nComo cualquier otra unido, se pueden ver la lista de sockets con el pedido s ystemctl list-unidos -t\nsocket pero adem\u00e1s disponemos del pedido espec\u00edfica systemctl list-sockets , la cual informa de qu\u00e9 servicio\ncorrespondiente activan y en qu\u00e9 puerto / socket UNIX escuchan.\nEJERCICIOS:\n1.-a) Crea el fichero \"/etc/systemd/system/dateserver.socket\" con el siguiente contenido:\n[Unido]\nDescription = Servicio de fecha en el puerto 55555\n[Socket]\nListenStream = 55555\nAccept = true\n[Install]\nWantedBy = sockets.target\nb) Crear el fichero \"/etc/systemd/system/dateserver@.service\" con el siguiente contenido:\n[Unido]\nDescription = Servicio de fecha\n[Service]\nType = simple\nExecStart = / opt / dateserver.sh\nStandardOutput = socket\nStandardError = journal\nc) Crear el fichero \"/opt/dateserver.sh\" con el siguiente contenido (y dale permisos de ejecuci\u00f3n!):",
            "title": "! / Bin / bash"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#bin-bash_3",
            "text": "while [[true]]\ndo\nPage 23",
            "title": "! / Bin / bash"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#atencion-comprueba-que-date-se-encuentre-dentro-de-usr-bin-dependiendo-de-la-distribucion-eso-cambia",
            "text": "/ Usr / bin / date\nsleep 1\nd\u00e9\nd) Abre un terminal y ejecuta el comando nc ipServidor 55555 . \u00bfQu\u00e9 ves? Abre otro terminal diferente y\nejecuta el mismo pedido. \u00bfQu\u00e9 ves? \u00bfQu\u00e9 te muestra el pedido systemctl status dateserver.socket ? \u00bfY la\npedido systemctl status dateserver @ * ? \u00bfY el pedido systemctl list-unidos dateserver @ * ?\n2.- Haz que el servidor SSH que tengas instal.lat a la m\u00e1quina (si no lo tienes, instal.la'l) inicie s\u00f3lo a trav\u00e9s\nde un socket. concretamente:\na) Crear el fichero \"/etc/systemd/system/sshMitjo.socket\" con el siguiente contenido:\n[Unido]\nDescription = Mi SSH Socket\n[Socket]\nListenStream = 22\nAccept = yes\n[Install]\nWantedBy = sockets.target\nb) Crear el fichero \"/etc/systemd/system/sshMitjo@.service\" con el siguiente contenido:\n[Unido]\nDescription = Mi SSH Server\n[Service]\nType = simple\nExecStart = - / usr / sbin / sshd -y\nStandardInput = socket\nStandardOutput = socket\nNOTA: Aqu\u00ed la clave est\u00e1 en la combinaci\u00f3n del par\u00e1metro -y del binario sshd (el cual hace que habilitar la posibilidad de que pueda recibir\npeticiones a trav\u00e9s de sockets), y la directiva StandardInput (lo realiza de forma efectiva este tipo de comunicaci\u00f3n entre el\nsocket y el servidor SSH)\nNOTA: Importante is the \"-\" in front of the binary name. This ENSUR that the exit status of the para-connection sshd process is\nforgotten by systemd. Normally, systemd will store the exit status of a all service instances that die abnormally. SSH will sometimes\ndie abnormally with an exit code of 1 oro similar, and we want to make sure that this does not cause systemd to keep around\ninformation for numerous previous connections that died this way (until this information is forgotten with systemctl reset-failed).\nc) Ejecutar el pedido systemctl enable sshMitjo.socket y systemctl disable ssh.service (si fuera necesario) y reinicia\nla m\u00e1quina. Una vez hecho, comprueba que el socket sshMitjo est\u00e9 funcionando pero no el servicio sshMitjo.\nEjecuta ssh usuario @ ipServidor para entrar en el servidor SSH (deber\u00edas de conseguir sin problemas) y\ncomprueba seguidamente que ahora s\u00ed est\u00e1 funcionando una instancia del servicio sshMitjo\nd) \u00bfQu\u00e9 har\u00eda un pedido como systemctl killsshd@172.31.0.52 : 22-172.31.0.4: 47779.service?\nPage 24\n3.-a) En el ejercicio anterior hemos tenido la suerte de que el servidor SSH ofrece un par\u00e1metro (-y) que le permite\ndelegar la apertura de los sockets (puertos) a un \"agente externo\" como es systemd. Pero no siempre tendremos un\nservidor que ofrezca esta posibilidad. En este sentido, lee los siguientes p\u00e1rrafos y resumen con las\ntus propias palabras que explica:\nOne of the limitations of socket activaci\u00f3n is that it requires the activated application to be aware that it may be socket-activated; the\nprocess of accepting an existing socket is different from creating a listening socket from scratch. Consequently a lot of widely used\napplications do not support it. The systemd developers have known that it may take some time to get activaci\u00f3n apoyo everywhere, sonido\nthey Introduced \"systemd-socket-proxyd\", a small TCP and Unix domain socket proxy server. This does understand activaci\u00f3n, and\nwill sit between the network and our server, transparently forwarding packets between the two. The steps to use this tool are:\nStep 1: We create a socket that Listener on the puerto that will eventually be served by the proxy / server combination.\nStep 2: On the first connection to the socket systemd activados the proxy service and hands it the socket.\nStep 3: When the proxy is started the corresponding server is first Broughten up (thanks to the Requires / After dependency)\nThe proxy then shuttles all traffic between the server and the network. The only trick here is that we need to bind the server to a puerto\nother than the real-target puerto (8080 instead of 80 if we are running a webserver, for instance). This is because that puerto will be\nowned by the socket / proxy, and you can not bind two processes to the same socket and interface.\nStep 1: \"myserver-proxy.socket\" file\n[Socket]\nListenStream = 0.0.0.0: 80\n[Install]\nWantedBy = sockets.target\nStep 2: \"myserver-proxy.service\" file\n[Unido]\nRequires = myserver.service\nAfter = myserver.service\n[Service]\nExecStart = / usr / lib / systemd / systemd-socket-proxyd 127.0.0.1:8080\nStep 3: \"myserver.service\" file\n[Unido]\nDescription = Server example (replace ExecStart value with something more realistic)\n[Service]",
            "title": "Atenci\u00f3n: comprueba que date se encuentre dentro de / usr / bin; dependiendo de la distribuci\u00f3n eso cambia"
        },
        {
            "location": "/LPIC3/1-Previos/Systemd/#we-listening-server-s-listening-puerto-only-to-loopback-interface-because-it-s-there-where-input-packages-comas-from-proxy",
            "text": "ExecStart = / usr / bin / ncat -k -l 127.0.0.1 8080",
            "title": "We listening server s listening puerto only to loopback interface because it 's there where input packages comas from proxy"
        }
    ]
}